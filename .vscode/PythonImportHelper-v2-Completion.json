[
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "scipy.sparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "csr_matrix",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "csr_matrix",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "find",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "find",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "issparse",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "CategoricalDtype",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "scanpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scanpy",
        "description": "scanpy",
        "detail": "scanpy",
        "documentation": {}
    },
    {
        "label": "filter_unwanted_cell_types",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_cite_seq_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_cite_seq_protein",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_cite_seq_rna",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "mad_outlier_removal",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "preprocess_rna_initial_steps",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "save_processed_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "z_normalize_codex",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "filter_unwanted_cell_types",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "harmonize_cell_types_names",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "mad_outlier_removal",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "preprocess_rna_initial_steps",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "read_legacy_adata",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "save_processed_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "download_tonsil_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "filter_unwanted_cell_types",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_tonsil_protein",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_tonsil_rna",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "mad_outlier_removal",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "preprocess_rna_initial_steps",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "save_processed_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "z_normalize_codex",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "analyze_and_visualize",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "balance_datasets",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_adata_latest",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "preprocess_rna_final_steps",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "qc_metrics",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "save_processed_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "spatial_analysis",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "validate_adata_requirements",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "create_smart_neighbors",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_adata_latest",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "save_processed_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_adata_latest",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "save_processed_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "compute_pca_and_umap",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_adata_latest",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "order_cells_by_type",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "save_processed_data",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_adata_latest",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "load_adata_latest",
        "importPath": "arcadia.data_utils",
        "description": "arcadia.data_utils",
        "isExtraImport": true,
        "detail": "arcadia.data_utils",
        "documentation": {}
    },
    {
        "label": "general",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "spatial",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "general",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "spatial",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "spatial",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "training",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "training",
        "importPath": "arcadia.plotting",
        "description": "arcadia.plotting",
        "isExtraImport": true,
        "detail": "arcadia.plotting",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "arcadia.utils",
        "description": "arcadia.utils",
        "isExtraImport": true,
        "detail": "arcadia.utils",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "arcadia.utils",
        "description": "arcadia.utils",
        "isExtraImport": true,
        "detail": "arcadia.utils",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "arcadia.utils",
        "description": "arcadia.utils",
        "isExtraImport": true,
        "detail": "arcadia.utils",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "arcadia.utils",
        "description": "arcadia.utils",
        "isExtraImport": true,
        "detail": "arcadia.utils",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "arcadia.utils",
        "description": "arcadia.utils",
        "isExtraImport": true,
        "detail": "arcadia.utils",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "arcadia.utils",
        "description": "arcadia.utils",
        "isExtraImport": true,
        "detail": "arcadia.utils",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "arcadia.utils",
        "description": "arcadia.utils",
        "isExtraImport": true,
        "detail": "arcadia.utils",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "arcadia.utils",
        "description": "arcadia.utils",
        "isExtraImport": true,
        "detail": "arcadia.utils",
        "documentation": {}
    },
    {
        "label": "matplotlib.colors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "to_hex",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "to_hex",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "LinearSegmentedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "TwoSlopeNorm",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "to_rgb",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "product",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "combinations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "KneeLocator",
        "importPath": "kneed",
        "description": "kneed",
        "isExtraImport": true,
        "detail": "kneed",
        "documentation": {}
    },
    {
        "label": "KneeLocator",
        "importPath": "kneed",
        "description": "kneed",
        "isExtraImport": true,
        "detail": "kneed",
        "documentation": {}
    },
    {
        "label": "here",
        "importPath": "arcadia.utils.paths",
        "description": "arcadia.utils.paths",
        "isExtraImport": true,
        "detail": "arcadia.utils.paths",
        "documentation": {}
    },
    {
        "label": "here",
        "importPath": "arcadia.utils.paths",
        "description": "arcadia.utils.paths",
        "isExtraImport": true,
        "detail": "arcadia.utils.paths",
        "documentation": {}
    },
    {
        "label": "here",
        "importPath": "arcadia.utils.paths",
        "description": "arcadia.utils.paths",
        "isExtraImport": true,
        "detail": "arcadia.utils.paths",
        "documentation": {}
    },
    {
        "label": "here",
        "importPath": "arcadia.utils.paths",
        "description": "arcadia.utils.paths",
        "isExtraImport": true,
        "detail": "arcadia.utils.paths",
        "documentation": {}
    },
    {
        "label": "parse_pipeline_arguments",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_pipeline_arguments",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_pipeline_arguments",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_pipeline_arguments",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_pipeline_arguments",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "apply_baseline_settings",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "apply_command_line_overrides",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "find_latest_checkpoint_folder",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "find_checkpoint_from_experiment_name",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_compare_arguments",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "find_checkpoint_from_experiment_name",
        "importPath": "arcadia.utils.args",
        "description": "arcadia.utils.args",
        "isExtraImport": true,
        "detail": "arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "anndata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "anndata",
        "description": "anndata",
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "AnnData",
        "importPath": "anndata",
        "description": "anndata",
        "isExtraImport": true,
        "detail": "anndata",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "silhouette_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "f1_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "silhouette_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "adjusted_rand_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "f1_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "silhouette_samples",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "silhouette_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "silhouette_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "ConfusionMatrixDisplay",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "ConfusionMatrixDisplay",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "plot_feature_value_distributions",
        "importPath": "arcadia.plotting.spatial",
        "description": "arcadia.plotting.spatial",
        "isExtraImport": true,
        "detail": "arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_protein_cn_subset_umaps",
        "importPath": "arcadia.plotting.spatial",
        "description": "arcadia.plotting.spatial",
        "isExtraImport": true,
        "detail": "arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_protein_vs_cn_statistics",
        "importPath": "arcadia.plotting.spatial",
        "description": "arcadia.plotting.spatial",
        "isExtraImport": true,
        "detail": "arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_spatial_data_histograms",
        "importPath": "arcadia.plotting.spatial",
        "description": "arcadia.plotting.spatial",
        "isExtraImport": true,
        "detail": "arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_feature_mean_distributions",
        "importPath": "arcadia.plotting.spatial",
        "description": "arcadia.plotting.spatial",
        "isExtraImport": true,
        "detail": "arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_feature_means_line",
        "importPath": "arcadia.plotting.spatial",
        "description": "arcadia.plotting.spatial",
        "isExtraImport": true,
        "detail": "arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "cosine_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "finalize_archetype_generation_with_visualizations",
        "importPath": "arcadia.archetypes.generation",
        "description": "arcadia.archetypes.generation",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "find_optimal_k_across_modalities",
        "importPath": "arcadia.archetypes.generation",
        "description": "arcadia.archetypes.generation",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "validate_batch_archetype_consistency",
        "importPath": "arcadia.archetypes.generation",
        "description": "arcadia.archetypes.generation",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "add_matched_archetype_weight",
        "importPath": "arcadia.archetypes.generation",
        "description": "arcadia.archetypes.generation",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "validate_extreme_archetypes_matching",
        "importPath": "arcadia.archetypes.matching",
        "description": "arcadia.archetypes.matching",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "find_best_pair_by_row_matching",
        "importPath": "arcadia.archetypes.matching",
        "description": "arcadia.archetypes.matching",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "identify_extreme_archetypes_balanced",
        "importPath": "arcadia.archetypes.matching",
        "description": "arcadia.archetypes.matching",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "identify_extreme_archetypes_balanced",
        "importPath": "arcadia.archetypes.matching",
        "description": "arcadia.archetypes.matching",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "evaluate_distance_metrics",
        "importPath": "arcadia.archetypes.metrics",
        "description": "arcadia.archetypes.metrics",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.metrics",
        "documentation": {}
    },
    {
        "label": "plot_batch_archetype_visualization",
        "importPath": "arcadia.plotting.archetypes",
        "description": "arcadia.plotting.archetypes",
        "isExtraImport": true,
        "detail": "arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_cn_features_correlation",
        "importPath": "arcadia.plotting.archetypes",
        "description": "arcadia.plotting.archetypes",
        "isExtraImport": true,
        "detail": "arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_cross_modal_archetype_similarity_matrix",
        "importPath": "arcadia.plotting.archetypes",
        "description": "arcadia.plotting.archetypes",
        "isExtraImport": true,
        "detail": "arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_archetype_heatmaps",
        "importPath": "arcadia.plotting.archetypes",
        "description": "arcadia.plotting.archetypes",
        "isExtraImport": true,
        "detail": "arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_extreme_archetypes_alignment",
        "importPath": "arcadia.plotting.archetypes",
        "description": "arcadia.plotting.archetypes",
        "isExtraImport": true,
        "detail": "arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_archetype_embedding",
        "importPath": "arcadia.plotting.archetypes",
        "description": "arcadia.plotting.archetypes",
        "isExtraImport": true,
        "detail": "arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "set_consistent_cell_type_colors",
        "importPath": "arcadia.plotting.general",
        "description": "arcadia.plotting.general",
        "isExtraImport": true,
        "detail": "arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "plot_cell_type_distribution",
        "importPath": "arcadia.plotting.general",
        "description": "arcadia.plotting.general",
        "isExtraImport": true,
        "detail": "arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "compute_opacity_per_cell_type",
        "importPath": "arcadia.plotting.general",
        "description": "arcadia.plotting.general",
        "isExtraImport": true,
        "detail": "arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "safe_mlflow_log_figure",
        "importPath": "arcadia.plotting.general",
        "description": "arcadia.plotting.general",
        "isExtraImport": true,
        "detail": "arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "safe_mlflow_log_figure",
        "importPath": "arcadia.plotting.general",
        "description": "arcadia.plotting.general",
        "isExtraImport": true,
        "detail": "arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "safe_mlflow_log_figure",
        "importPath": "arcadia.plotting.general",
        "description": "arcadia.plotting.general",
        "isExtraImport": true,
        "detail": "arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "safe_mlflow_log_figure",
        "importPath": "arcadia.plotting.general",
        "description": "arcadia.plotting.general",
        "isExtraImport": true,
        "detail": "arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "select_gene_likelihood",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "ensure_correct_dtype",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "is_already_integer",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "select_gene_likelihood",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "simulate_counts_zero_inflated",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "transfer_to_integer_range_nb",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "transfer_to_integer_range_normal",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "calculate_post_training_metrics",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "clear_memory",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "generate_post_training_visualizations",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "log_memory_usage",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "log_parameters",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "match_cells_and_calculate_distances",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "process_latent_spaces",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "validate_scvi_training_mixin",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "calculate_post_training_metrics",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "clear_memory",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "generate_post_training_visualizations",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "log_memory_usage",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "log_parameters",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "match_cells_and_calculate_distances",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "process_latent_spaces",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "validate_scvi_training_mixin",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "metrics",
        "importPath": "arcadia.training",
        "description": "arcadia.training",
        "isExtraImport": true,
        "detail": "arcadia.training",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "scipy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy",
        "description": "scipy",
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "compute_archetype_distances",
        "importPath": "arcadia.archetypes",
        "description": "arcadia.archetypes",
        "isExtraImport": true,
        "detail": "arcadia.archetypes",
        "documentation": {}
    },
    {
        "label": "identify_extreme_archetypes_balanced",
        "importPath": "arcadia.archetypes",
        "description": "arcadia.archetypes",
        "isExtraImport": true,
        "detail": "arcadia.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_b_cells_analysis",
        "importPath": "arcadia.plotting.preprocessing",
        "description": "arcadia.plotting.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_original_data_visualizations",
        "importPath": "arcadia.plotting.preprocessing",
        "description": "arcadia.plotting.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_pca_and_umap",
        "importPath": "arcadia.plotting.preprocessing",
        "description": "arcadia.plotting.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_protein_umap",
        "importPath": "arcadia.plotting.preprocessing",
        "description": "arcadia.plotting.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_umap_visualizations_original_data",
        "importPath": "arcadia.plotting.preprocessing",
        "description": "arcadia.plotting.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_spatial_only_umap",
        "importPath": "arcadia.plotting.preprocessing",
        "description": "arcadia.plotting.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "get_umap_filtered_fucntion",
        "importPath": "arcadia.utils.environment",
        "description": "arcadia.utils.environment",
        "isExtraImport": true,
        "detail": "arcadia.utils.environment",
        "documentation": {}
    },
    {
        "label": "setup_environment",
        "importPath": "arcadia.utils.environment",
        "description": "arcadia.utils.environment",
        "isExtraImport": true,
        "detail": "arcadia.utils.environment",
        "documentation": {}
    },
    {
        "label": "get_umap_filtered_fucntion",
        "importPath": "arcadia.utils.environment",
        "description": "arcadia.utils.environment",
        "isExtraImport": true,
        "detail": "arcadia.utils.environment",
        "documentation": {}
    },
    {
        "label": "setup_environment",
        "importPath": "arcadia.utils.environment",
        "description": "arcadia.utils.environment",
        "isExtraImport": true,
        "detail": "arcadia.utils.environment",
        "documentation": {}
    },
    {
        "label": "get_umap_filtered_fucntion",
        "importPath": "arcadia.utils.environment",
        "description": "arcadia.utils.environment",
        "isExtraImport": true,
        "detail": "arcadia.utils.environment",
        "documentation": {}
    },
    {
        "label": "get_umap_filtered_fucntion",
        "importPath": "arcadia.utils.environment",
        "description": "arcadia.utils.environment",
        "isExtraImport": true,
        "detail": "arcadia.utils.environment",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "mlflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mlflow",
        "description": "mlflow",
        "detail": "mlflow",
        "documentation": {}
    },
    {
        "label": "scvi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scvi",
        "description": "scvi",
        "detail": "scvi",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "plot_umap_with_extremes",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_first_batch_umaps",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_rna_protein_matching_means_and_scale",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_similarity_loss_history",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_warmup_loss_distributions",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_all_fits_for_gene",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_cell_type_distributions",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_combined_latent_space",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_latent_pca_both_modalities_by_celltype",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_latent_pca_both_modalities_cn",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_normalized_losses",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_rna_protein_latent_cn_cell_type_umap",
        "importPath": "arcadia.plotting.training",
        "description": "arcadia.plotting.training",
        "isExtraImport": true,
        "detail": "arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "DualVAETrainingPlan",
        "importPath": "arcadia.training.dual_vae_training_plan",
        "description": "arcadia.training.dual_vae_training_plan",
        "isExtraImport": true,
        "detail": "arcadia.training.dual_vae_training_plan",
        "documentation": {}
    },
    {
        "label": "load_loss_scales_from_cache",
        "importPath": "arcadia.training.loss_scaling",
        "description": "arcadia.training.loss_scaling",
        "isExtraImport": true,
        "detail": "arcadia.training.loss_scaling",
        "documentation": {}
    },
    {
        "label": "save_loss_scales_to_cache",
        "importPath": "arcadia.training.loss_scaling",
        "description": "arcadia.training.loss_scaling",
        "isExtraImport": true,
        "detail": "arcadia.training.loss_scaling",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "estimate_training_time",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "filter_and_transform",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "log_epoch_end",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "log_step",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "importPath": "arcadia.utils.logging",
        "description": "arcadia.utils.logging",
        "isExtraImport": true,
        "detail": "arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "SCVI",
        "importPath": "scvi.model",
        "description": "scvi.model",
        "isExtraImport": true,
        "detail": "scvi.model",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "ParameterGrid",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "Parallel",
        "importPath": "joblib",
        "description": "joblib",
        "isExtraImport": true,
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "delayed",
        "importPath": "joblib",
        "description": "joblib",
        "isExtraImport": true,
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "minimize",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "nnls",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "linear_sum_assignment",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "OrthogonalMatchingPursuit",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "PCHA",
        "importPath": "py_pcha",
        "description": "py_pcha",
        "isExtraImport": true,
        "detail": "py_pcha",
        "documentation": {}
    },
    {
        "label": "PCHA",
        "importPath": "py_pcha",
        "description": "py_pcha",
        "isExtraImport": true,
        "detail": "py_pcha",
        "documentation": {}
    },
    {
        "label": "plot_archetype_proportions_before_after_matching",
        "importPath": "arcadia.archetypes.visualization",
        "description": "arcadia.archetypes.visualization",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_cross_modal_archetype_comparison",
        "importPath": "arcadia.archetypes.visualization",
        "description": "arcadia.archetypes.visualization",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "visualize_archetype_proportions_analysis",
        "importPath": "arcadia.archetypes.visualization",
        "description": "arcadia.archetypes.visualization",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "create_tsne_visualization",
        "importPath": "arcadia.archetypes.visualization",
        "description": "arcadia.archetypes.visualization",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetype_heatmap",
        "importPath": "arcadia.archetypes.visualization",
        "description": "arcadia.archetypes.visualization",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetype_umap",
        "importPath": "arcadia.archetypes.visualization",
        "description": "arcadia.archetypes.visualization",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_distance_comparison",
        "importPath": "arcadia.archetypes.visualization",
        "description": "arcadia.archetypes.visualization",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_matching_accuracy_by_cell_type",
        "importPath": "arcadia.archetypes.visualization",
        "description": "arcadia.archetypes.visualization",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "pdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "identify_extreme_archetypes_percentile",
        "importPath": "arcadia.archetypes.cell_representations",
        "description": "arcadia.archetypes.cell_representations",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "adjusted_mutual_info_score",
        "importPath": "sklearn.metrics.cluster",
        "description": "sklearn.metrics.cluster",
        "isExtraImport": true,
        "detail": "sklearn.metrics.cluster",
        "documentation": {}
    },
    {
        "label": "MinMaxScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "LabelEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "mixing_score",
        "importPath": "arcadia.training.metrics",
        "description": "arcadia.training.metrics",
        "isExtraImport": true,
        "detail": "arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_iLISI",
        "importPath": "arcadia.training.metrics",
        "description": "arcadia.training.metrics",
        "isExtraImport": true,
        "detail": "arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "compute_ari_f1",
        "importPath": "arcadia.training.metrics",
        "description": "arcadia.training.metrics",
        "isExtraImport": true,
        "detail": "arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "compute_silhouette_f1",
        "importPath": "arcadia.training.metrics",
        "description": "arcadia.training.metrics",
        "isExtraImport": true,
        "detail": "arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "kbet_within_cell_types",
        "importPath": "arcadia.training.metrics",
        "description": "arcadia.training.metrics",
        "isExtraImport": true,
        "detail": "arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "matching_accuracy",
        "importPath": "arcadia.training.metrics",
        "description": "arcadia.training.metrics",
        "isExtraImport": true,
        "detail": "arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calc_dist",
        "importPath": "arcadia.training.metrics",
        "description": "arcadia.training.metrics",
        "isExtraImport": true,
        "detail": "arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calc_dist",
        "importPath": "arcadia.training.metrics",
        "description": "arcadia.training.metrics",
        "isExtraImport": true,
        "detail": "arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "umap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "umap",
        "description": "umap",
        "detail": "umap",
        "documentation": {}
    },
    {
        "label": "UMAP",
        "importPath": "umap",
        "description": "umap",
        "isExtraImport": true,
        "detail": "umap",
        "documentation": {}
    },
    {
        "label": "UMAP",
        "importPath": "umap",
        "description": "umap",
        "isExtraImport": true,
        "detail": "umap",
        "documentation": {}
    },
    {
        "label": "FancyArrowPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "TSNE",
        "importPath": "sklearn.manifold",
        "description": "sklearn.manifold",
        "isExtraImport": true,
        "detail": "sklearn.manifold",
        "documentation": {}
    },
    {
        "label": "sklearn.neighbors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "cpu_count",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "compute_covet",
        "importPath": "arcadia.covet.core",
        "description": "arcadia.covet.core",
        "isExtraImport": true,
        "detail": "arcadia.covet.core",
        "documentation": {}
    },
    {
        "label": "compute_mi_batch",
        "importPath": "arcadia.covet.utils",
        "description": "arcadia.covet.utils",
        "isExtraImport": true,
        "detail": "arcadia.covet.utils",
        "documentation": {}
    },
    {
        "label": "extract_lower_triangle",
        "importPath": "arcadia.covet.utils",
        "description": "arcadia.covet.utils",
        "isExtraImport": true,
        "detail": "arcadia.covet.utils",
        "documentation": {}
    },
    {
        "label": "generate_covet_feature_names",
        "importPath": "arcadia.covet.utils",
        "description": "arcadia.covet.utils",
        "isExtraImport": true,
        "detail": "arcadia.covet.utils",
        "documentation": {}
    },
    {
        "label": "mutual_info_regression",
        "importPath": "sklearn.feature_selection",
        "description": "sklearn.feature_selection",
        "isExtraImport": true,
        "detail": "sklearn.feature_selection",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "h5py",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "h5py",
        "description": "h5py",
        "detail": "h5py",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "mmread",
        "importPath": "scipy.io",
        "description": "scipy.io",
        "isExtraImport": true,
        "detail": "scipy.io",
        "documentation": {}
    },
    {
        "label": "mmread",
        "importPath": "scipy.io",
        "description": "scipy.io",
        "isExtraImport": true,
        "detail": "scipy.io",
        "documentation": {}
    },
    {
        "label": "clean_uns_for_h5ad",
        "importPath": "arcadia.data_utils.cleaning",
        "description": "arcadia.data_utils.cleaning",
        "isExtraImport": true,
        "detail": "arcadia.data_utils.cleaning",
        "documentation": {}
    },
    {
        "label": "clean_uns_for_h5ad",
        "importPath": "arcadia.data_utils.cleaning",
        "description": "arcadia.data_utils.cleaning",
        "isExtraImport": true,
        "detail": "arcadia.data_utils.cleaning",
        "documentation": {}
    },
    {
        "label": "_add_source_file_to_metadata",
        "importPath": "arcadia.utils.metadata",
        "description": "arcadia.utils.metadata",
        "isExtraImport": true,
        "detail": "arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "get_caller_file",
        "importPath": "arcadia.utils.metadata",
        "description": "arcadia.utils.metadata",
        "isExtraImport": true,
        "detail": "arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "scipy.stats",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "median_abs_deviation",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "nbinom",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "norm",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "poisson",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "chisquare",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "anderson_ksamp",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "nbinom",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "norm",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "poisson",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "Line2D",
        "importPath": "matplotlib.lines",
        "description": "matplotlib.lines",
        "isExtraImport": true,
        "detail": "matplotlib.lines",
        "documentation": {}
    },
    {
        "label": "linkage",
        "importPath": "scipy.cluster.hierarchy",
        "description": "scipy.cluster.hierarchy",
        "isExtraImport": true,
        "detail": "scipy.cluster.hierarchy",
        "documentation": {}
    },
    {
        "label": "compute_archetype_distances",
        "importPath": "arcadia.archetypes.distances",
        "description": "arcadia.archetypes.distances",
        "isExtraImport": true,
        "detail": "arcadia.archetypes.distances",
        "documentation": {}
    },
    {
        "label": "log1p_rna",
        "importPath": "arcadia.data_utils.preprocessing",
        "description": "arcadia.data_utils.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "analyze_and_visualize",
        "importPath": "arcadia.data_utils.preprocessing",
        "description": "arcadia.data_utils.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "log1p_rna",
        "importPath": "arcadia.data_utils.preprocessing",
        "description": "arcadia.data_utils.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "qc_metrics",
        "importPath": "arcadia.data_utils.preprocessing",
        "description": "arcadia.data_utils.preprocessing",
        "isExtraImport": true,
        "detail": "arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "TrainingPlan",
        "importPath": "scvi.train",
        "description": "scvi.train",
        "isExtraImport": true,
        "detail": "scvi.train",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "GradNorm",
        "importPath": "arcadia.training.gradnorm",
        "description": "arcadia.training.gradnorm",
        "isExtraImport": true,
        "detail": "arcadia.training.gradnorm",
        "documentation": {}
    },
    {
        "label": "calculate_cross_modal_cell_type_loss",
        "importPath": "arcadia.training.losses",
        "description": "arcadia.training.losses",
        "isExtraImport": true,
        "detail": "arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "calculate_modality_balance_loss",
        "importPath": "arcadia.training.losses",
        "description": "arcadia.training.losses",
        "isExtraImport": true,
        "detail": "arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "cn_distribution_separation_loss",
        "importPath": "arcadia.training.losses",
        "description": "arcadia.training.losses",
        "isExtraImport": true,
        "detail": "arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "extreme_archetypes_loss",
        "importPath": "arcadia.training.losses",
        "description": "arcadia.training.losses",
        "isExtraImport": true,
        "detail": "arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "run_cell_type_clustering_loss",
        "importPath": "arcadia.training.losses",
        "description": "arcadia.training.losses",
        "isExtraImport": true,
        "detail": "arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "compute_pairwise_distances",
        "importPath": "arcadia.training.utils",
        "description": "arcadia.training.utils",
        "isExtraImport": true,
        "detail": "arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "compute_pairwise_kl_two_items",
        "importPath": "arcadia.training.utils",
        "description": "arcadia.training.utils",
        "isExtraImport": true,
        "detail": "arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "create_counterfactual_adata",
        "importPath": "arcadia.training.utils",
        "description": "arcadia.training.utils",
        "isExtraImport": true,
        "detail": "arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "get_latent_embedding",
        "importPath": "arcadia.training.utils",
        "description": "arcadia.training.utils",
        "isExtraImport": true,
        "detail": "arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "predict_rna_cn_from_protein_neighbors",
        "importPath": "arcadia.training.utils",
        "description": "arcadia.training.utils",
        "isExtraImport": true,
        "detail": "arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "normalize",
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "isExtraImport": true,
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "importPath": "sklearn.mixture",
        "description": "sklearn.mixture",
        "isExtraImport": true,
        "detail": "sklearn.mixture",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "align_data",
        "importPath": "arcadia.analysis.comparison_utils",
        "description": "arcadia.analysis.comparison_utils",
        "isExtraImport": true,
        "detail": "arcadia.analysis.comparison_utils",
        "documentation": {}
    },
    {
        "label": "calculate_single_model_metrics",
        "importPath": "arcadia.analysis.comparison_utils",
        "description": "arcadia.analysis.comparison_utils",
        "isExtraImport": true,
        "detail": "arcadia.analysis.comparison_utils",
        "documentation": {}
    },
    {
        "label": "merge_model_results",
        "importPath": "arcadia.analysis.comparison_utils",
        "description": "arcadia.analysis.comparison_utils",
        "isExtraImport": true,
        "detail": "arcadia.analysis.comparison_utils",
        "documentation": {}
    },
    {
        "label": "save_comparison_results",
        "importPath": "arcadia.analysis.comparison_utils",
        "description": "arcadia.analysis.comparison_utils",
        "isExtraImport": true,
        "detail": "arcadia.analysis.comparison_utils",
        "documentation": {}
    },
    {
        "label": "align_data",
        "importPath": "arcadia.analysis.comparison_utils",
        "description": "arcadia.analysis.comparison_utils",
        "isExtraImport": true,
        "detail": "arcadia.analysis.comparison_utils",
        "documentation": {}
    },
    {
        "label": "assign_rna_cn_from_protein",
        "importPath": "arcadia.analysis.post_hoc_utils",
        "description": "arcadia.analysis.post_hoc_utils",
        "isExtraImport": true,
        "detail": "arcadia.analysis.post_hoc_utils",
        "documentation": {}
    },
    {
        "label": "load_checkpoint_data",
        "importPath": "arcadia.analysis.post_hoc_utils",
        "description": "arcadia.analysis.post_hoc_utils",
        "isExtraImport": true,
        "detail": "arcadia.analysis.post_hoc_utils",
        "documentation": {}
    },
    {
        "label": "load_checkpoint_data",
        "importPath": "arcadia.analysis.post_hoc_utils",
        "description": "arcadia.analysis.post_hoc_utils",
        "isExtraImport": true,
        "detail": "arcadia.analysis.post_hoc_utils",
        "documentation": {}
    },
    {
        "label": "load_adata_latest",
        "importPath": "arcadia.data_utils.loading",
        "description": "arcadia.data_utils.loading",
        "isExtraImport": true,
        "detail": "arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "plot_individual_and_combined_umaps",
        "importPath": "arcadia.plotting.post_hoc",
        "description": "arcadia.plotting.post_hoc",
        "isExtraImport": true,
        "detail": "arcadia.plotting.post_hoc",
        "documentation": {}
    },
    {
        "label": "plot_morans_i",
        "importPath": "arcadia.plotting.post_hoc",
        "description": "arcadia.plotting.post_hoc",
        "isExtraImport": true,
        "detail": "arcadia.plotting.post_hoc",
        "documentation": {}
    },
    {
        "label": "plot_umap_latent_arcadia",
        "importPath": "arcadia.plotting.post_hoc",
        "description": "arcadia.plotting.post_hoc",
        "isExtraImport": true,
        "detail": "arcadia.plotting.post_hoc",
        "documentation": {}
    },
    {
        "label": "plot_umap_per_cell_type",
        "importPath": "arcadia.plotting.post_hoc",
        "description": "arcadia.plotting.post_hoc",
        "isExtraImport": true,
        "detail": "arcadia.plotting.post_hoc",
        "documentation": {}
    },
    {
        "label": "maxfuse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "maxfuse",
        "description": "maxfuse",
        "detail": "maxfuse",
        "documentation": {}
    },
    {
        "label": "get_latest_file",
        "importPath": "comparison_utils",
        "description": "comparison_utils",
        "isExtraImport": true,
        "detail": "comparison_utils",
        "documentation": {}
    },
    {
        "label": "here",
        "importPath": "comparison_utils",
        "description": "comparison_utils",
        "isExtraImport": true,
        "detail": "comparison_utils",
        "documentation": {}
    },
    {
        "label": "get_latest_file",
        "importPath": "comparison_utils",
        "description": "comparison_utils",
        "isExtraImport": true,
        "detail": "comparison_utils",
        "documentation": {}
    },
    {
        "label": "here",
        "importPath": "comparison_utils",
        "description": "comparison_utils",
        "isExtraImport": true,
        "detail": "comparison_utils",
        "documentation": {}
    },
    {
        "label": "get_latest_file",
        "importPath": "comparison_utils",
        "description": "comparison_utils",
        "isExtraImport": true,
        "detail": "comparison_utils",
        "documentation": {}
    },
    {
        "label": "here",
        "importPath": "comparison_utils",
        "description": "comparison_utils",
        "isExtraImport": true,
        "detail": "comparison_utils",
        "documentation": {}
    },
    {
        "label": "get_latest_file",
        "importPath": "comparison_utils",
        "description": "comparison_utils",
        "isExtraImport": true,
        "detail": "comparison_utils",
        "documentation": {}
    },
    {
        "label": "here",
        "importPath": "comparison_utils",
        "description": "comparison_utils",
        "isExtraImport": true,
        "detail": "comparison_utils",
        "documentation": {}
    },
    {
        "label": "scmodal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scmodal",
        "description": "scmodal",
        "detail": "scmodal",
        "documentation": {}
    },
    {
        "label": "here",
        "kind": 2,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "def here():\n    try:\n        return Path(__file__).resolve().parent\n    except NameError:\n        return Path.cwd()\nFILENAME = \"_0_preprocess_cite_seq.py\"\ndataset_name = \"cite_seq\"\nimport scipy.sparse as sp\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "FILENAME = \"_0_preprocess_cite_seq.py\"\ndataset_name = \"cite_seq\"\nimport scipy.sparse as sp\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\n# Determine ROOT based on whether we're running as script or notebook\ntry:\n    # Running as script - use __file__ to find root\n    _script_dir = Path(__file__).resolve().parent\n    ROOT = _script_dir.parent  # scripts/ -> root",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "dataset_name = \"cite_seq\"\nimport scipy.sparse as sp\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\n# Determine ROOT based on whether we're running as script or notebook\ntry:\n    # Running as script - use __file__ to find root\n    _script_dir = Path(__file__).resolve().parent\n    ROOT = _script_dir.parent  # scripts/ -> root\nexcept NameError:",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "THIS_DIR = here()\n# Add src to path for arcadia package\nif str(ROOT / \"src\") not in sys.path:\n    sys.path.insert(0, str(ROOT / \"src\"))\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nos.chdir(str(ROOT))\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "config_path = Path(\"configs/config.json\")\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "start_time",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "start_time = datetime.now()\ntimestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\")\n# %% --- Directory Structure Definition ---\n# Base path relative to the project root\nbase_path = \"raw_datasets\"\n# Core directories to be created under the base path\n# Sub-directories are handled automatically by os.makedirs\ndirectories = [\n    \"checkpoints\",",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "timestamp_str",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "timestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\")\n# %% --- Directory Structure Definition ---\n# Base path relative to the project root\nbase_path = \"raw_datasets\"\n# Core directories to be created under the base path\n# Sub-directories are handled automatically by os.makedirs\ndirectories = [\n    \"checkpoints\",\n    \"processed_data\",",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "base_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "base_path = \"raw_datasets\"\n# Core directories to be created under the base path\n# Sub-directories are handled automatically by os.makedirs\ndirectories = [\n    \"checkpoints\",\n    \"processed_data\",\n    \"raw_data/schreiber\",\n    \"raw_data/tonsil\",\n    \"raw_data/cite_seq\",\n    \"trained_data\",",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "directories",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "directories = [\n    \"checkpoints\",\n    \"processed_data\",\n    \"raw_data/schreiber\",\n    \"raw_data/tonsil\",\n    \"raw_data/cite_seq\",\n    \"trained_data\",\n]\nprint(f\"Creating directory structure under: {os.path.abspath(base_path)}\")\nfor rel_path in directories:",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "selected_batches",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "selected_batches = [\"SLN111-D1\", \"SLN208-D1\"]\nadata = load_cite_seq_data(batches=selected_batches)\n# todo remove this if we want to use batches\nadata.obs[\"batch\"] = \"batch_1\"  # ignore bacthes for now\n# temporary subsample to 10k cells\nadata = adata[~adata.obs[\"cell_types\"].isna()].copy()\n# subsampel the cell tpyes Mature B  for the size fo\n# sc.pp.subsample(adata, n_obs=5000)\n# Initialize pipeline metadata with start time\nadata.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata = load_cite_seq_data(batches=selected_batches)\n# todo remove this if we want to use batches\nadata.obs[\"batch\"] = \"batch_1\"  # ignore bacthes for now\n# temporary subsample to 10k cells\nadata = adata[~adata.obs[\"cell_types\"].isna()].copy()\n# subsampel the cell tpyes Mature B  for the size fo\n# sc.pp.subsample(adata, n_obs=5000)\n# Initialize pipeline metadata with start time\nadata.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata.obs[\"batch\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata.obs[\"batch\"] = \"batch_1\"  # ignore bacthes for now\n# temporary subsample to 10k cells\nadata = adata[~adata.obs[\"cell_types\"].isna()].copy()\n# subsampel the cell tpyes Mature B  for the size fo\n# sc.pp.subsample(adata, n_obs=5000)\n# Initialize pipeline metadata with start time\nadata.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\nadata.uns[\"pipeline_metadata\"][\"applied_batch_correction\"] = (",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata = adata[~adata.obs[\"cell_types\"].isna()].copy()\n# subsampel the cell tpyes Mature B  for the size fo\n# sc.pp.subsample(adata, n_obs=5000)\n# Initialize pipeline metadata with start time\nadata.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\nadata.uns[\"pipeline_metadata\"][\"applied_batch_correction\"] = (\n    True if all([\"-D1\" in batch for batch in selected_batches]) else False\n)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata.uns[\"pipeline_metadata\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\nadata.uns[\"pipeline_metadata\"][\"applied_batch_correction\"] = (\n    True if all([\"-D1\" in batch for batch in selected_batches]) else False\n)\n# %% --- Cell Type Mapping and Major Cell Type Assignment ---\nprint(\"\\n=== Creating cell type mappings ===\")\n# Create cell type mapping following CITE-seq archetype methodology\n# Based on exact mapping from archetype_generation_cite_seq.py",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata.uns[\"pipeline_metadata\"][\"applied_batch_correction\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata.uns[\"pipeline_metadata\"][\"applied_batch_correction\"] = (\n    True if all([\"-D1\" in batch for batch in selected_batches]) else False\n)\n# %% --- Cell Type Mapping and Major Cell Type Assignment ---\nprint(\"\\n=== Creating cell type mappings ===\")\n# Create cell type mapping following CITE-seq archetype methodology\n# Based on exact mapping from archetype_generation_cite_seq.py\n# Use proper major cell type mapping (as you requested)\n# Major cell types become the primary cell_types, minor ones used for spatial placement only\n# Proper major cell type mapping (as originally intended)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "cell_type_mapping",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "cell_type_mapping = {\n    \"CD4 T\": \"CD4 T\",\n    \"Activated CD4 T\": \"CD4 T\",\n    \"Ifit3-high CD4 T\": \"CD4 T\",\n    \"CD8 T\": \"CD8 T\",\n    \"Ifit3-high CD8 T\": \"CD8 T\",\n    \"CD122+ CD8 T\": \"CD8 T\",\n    \"GD T\": \"T cells\",\n    \"NKT\": \"T cells\",\n    \"Mature B\": \"B cells\",",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "mapped_cell_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "mapped_cell_types = set(cell_type_mapping.keys())\ncurrent_cell_types = set(adata.obs[\"cell_types\"].unique())\nunmapped_types = current_cell_types - mapped_cell_types\nif unmapped_types:\n    print(f\"Dropping cells with unmapped cell types: {unmapped_types}\")\n    mask = adata.obs[\"cell_types\"].isin(mapped_cell_types)\n    adata = adata[mask].copy()\n    print(f\"Data shape after filtering: {adata.shape}\")\n# Store the original minor cell types BEFORE mapping to major cell types\nadata.obs[\"minor_cell_types\"] = adata.obs[\"cell_types\"].copy()  # Store original fine-grained types",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "current_cell_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "current_cell_types = set(adata.obs[\"cell_types\"].unique())\nunmapped_types = current_cell_types - mapped_cell_types\nif unmapped_types:\n    print(f\"Dropping cells with unmapped cell types: {unmapped_types}\")\n    mask = adata.obs[\"cell_types\"].isin(mapped_cell_types)\n    adata = adata[mask].copy()\n    print(f\"Data shape after filtering: {adata.shape}\")\n# Store the original minor cell types BEFORE mapping to major cell types\nadata.obs[\"minor_cell_types\"] = adata.obs[\"cell_types\"].copy()  # Store original fine-grained types\nadata.obs[\"cell_types\"] = pd.Categorical(",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "unmapped_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "unmapped_types = current_cell_types - mapped_cell_types\nif unmapped_types:\n    print(f\"Dropping cells with unmapped cell types: {unmapped_types}\")\n    mask = adata.obs[\"cell_types\"].isin(mapped_cell_types)\n    adata = adata[mask].copy()\n    print(f\"Data shape after filtering: {adata.shape}\")\n# Store the original minor cell types BEFORE mapping to major cell types\nadata.obs[\"minor_cell_types\"] = adata.obs[\"cell_types\"].copy()  # Store original fine-grained types\nadata.obs[\"cell_types\"] = pd.Categorical(\n    adata.obs[\"cell_types\"].map(cell_type_mapping)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata.obs[\"minor_cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata.obs[\"minor_cell_types\"] = adata.obs[\"cell_types\"].copy()  # Store original fine-grained types\nadata.obs[\"cell_types\"] = pd.Categorical(\n    adata.obs[\"cell_types\"].map(cell_type_mapping)\n)  # Major types become primary\n# Create major_to_minor_dict for spatial function\nmajor_to_minor_dict = {}\nfor minor, major in cell_type_mapping.items():\n    if major not in major_to_minor_dict:\n        major_to_minor_dict[major] = []\n    major_to_minor_dict[major].append(minor)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata.obs[\"cell_types\"] = pd.Categorical(\n    adata.obs[\"cell_types\"].map(cell_type_mapping)\n)  # Major types become primary\n# Create major_to_minor_dict for spatial function\nmajor_to_minor_dict = {}\nfor minor, major in cell_type_mapping.items():\n    if major not in major_to_minor_dict:\n        major_to_minor_dict[major] = []\n    major_to_minor_dict[major].append(minor)\n# Print cell type mapping summary",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "major_to_minor_dict",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "major_to_minor_dict = {}\nfor minor, major in cell_type_mapping.items():\n    if major not in major_to_minor_dict:\n        major_to_minor_dict[major] = []\n    major_to_minor_dict[major].append(minor)\n# Print cell type mapping summary\nprint(\"Cell type mapping created:\")\nfor major_type, minor_list in major_to_minor_dict.items():\n    print(f\"  {major_type}: {minor_list}\")\n# %% --- Create Color Scheme for Major and Minor Cell Types ---",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "major_cell_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "major_cell_types = list(major_to_minor_dict.keys())\nprint(f\"Major cell types: {major_cell_types}\")\n# Create base colors for major cell types using scanpy default colors\nmajor_colors = dict(\n    zip(\n        major_cell_types,\n        [to_hex(c) for c in plt.cm.tab20(np.linspace(0, 1, len(major_cell_types)))],\n    )\n)\nprint(\"Major cell type colors:\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "major_colors",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "major_colors = dict(\n    zip(\n        major_cell_types,\n        [to_hex(c) for c in plt.cm.tab20(np.linspace(0, 1, len(major_cell_types)))],\n    )\n)\nprint(\"Major cell type colors:\")\nfor major_type, color in major_colors.items():\n    print(f\"  {major_type}: {color}\")\n# Create minor cell type colors as shades of major cell type colors",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "minor_colors",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "minor_colors = {}\nfor major_type, minor_list in major_to_minor_dict.items():\n    base_color = major_colors[major_type]\n    if len(minor_list) == 1:\n        # If only one minor type, use the base color\n        minor_colors[minor_list[0]] = base_color\n    else:\n        # Create shades of the base color for multiple minor types\n        # Convert hex to RGB\n        rgb = mcolors.hex2color(base_color)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna = load_cite_seq_rna(adata)\nadata_prot = load_cite_seq_protein(adata, major_to_minor_dict)\nprint(f\"Loaded RNA data: {adata_rna.shape}\")\nprint(f\"Loaded protein data: {adata_prot.shape}\")\nprint(\"\\n=== Applying cell type strategy to both datasets ===\")\n# %% Apply mapping\nprint(\"Applying cell type mapping\")\n# Store the original minor cell types for both datasets (keep originals)\n# Note: minor_cell_types should already be set from the initial loading\n# Just verify they exist, don't overwrite them",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot = load_cite_seq_protein(adata, major_to_minor_dict)\nprint(f\"Loaded RNA data: {adata_rna.shape}\")\nprint(f\"Loaded protein data: {adata_prot.shape}\")\nprint(\"\\n=== Applying cell type strategy to both datasets ===\")\n# %% Apply mapping\nprint(\"Applying cell type mapping\")\n# Store the original minor cell types for both datasets (keep originals)\n# Note: minor_cell_types should already be set from the initial loading\n# Just verify they exist, don't overwrite them\nif \"minor_cell_types\" not in adata_rna.obs.columns:",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_unmapped_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "rna_unmapped_types = set(adata_rna.obs[\"minor_cell_types\"].unique()) - set(cell_type_mapping.keys())\nprot_unmapped_types = set(adata_prot.obs[\"minor_cell_types\"].unique()) - set(\n    cell_type_mapping.keys()\n)\nif rna_unmapped_types:\n    raise ValueError(f\"RNA dataset contains unmapped cell types: {rna_unmapped_types}\")\nif prot_unmapped_types:\n    raise ValueError(f\"Protein dataset contains unmapped cell types: {prot_unmapped_types}\")\n# Map to major cell types (these become the primary cell_types)\n# Use the original minor_cell_types (which are the fine-grained types) for mapping",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "prot_unmapped_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "prot_unmapped_types = set(adata_prot.obs[\"minor_cell_types\"].unique()) - set(\n    cell_type_mapping.keys()\n)\nif rna_unmapped_types:\n    raise ValueError(f\"RNA dataset contains unmapped cell types: {rna_unmapped_types}\")\nif prot_unmapped_types:\n    raise ValueError(f\"Protein dataset contains unmapped cell types: {prot_unmapped_types}\")\n# Map to major cell types (these become the primary cell_types)\n# Use the original minor_cell_types (which are the fine-grained types) for mapping\nadata_rna.obs[\"cell_types\"] = pd.Categorical(",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.obs[\"cell_types\"] = pd.Categorical(\n    adata_rna.obs[\"minor_cell_types\"].map(cell_type_mapping)\n)\nadata_prot.obs[\"cell_types\"] = pd.Categorical(\n    adata_prot.obs[\"minor_cell_types\"].map(cell_type_mapping)\n)\n# Check for any unmapped values and handle NaNs\nrna_unmapped = adata_rna.obs[\"cell_types\"].isna().sum()\nprot_unmapped = adata_prot.obs[\"cell_types\"].isna().sum()\n# %% Processing",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot.obs[\"cell_types\"] = pd.Categorical(\n    adata_prot.obs[\"minor_cell_types\"].map(cell_type_mapping)\n)\n# Check for any unmapped values and handle NaNs\nrna_unmapped = adata_rna.obs[\"cell_types\"].isna().sum()\nprot_unmapped = adata_prot.obs[\"cell_types\"].isna().sum()\n# %% Processing\nif rna_unmapped > 0:\n    print(f\"Warning: {rna_unmapped} RNA cells with unmapped cell types\")\n    print(",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_unmapped",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "rna_unmapped = adata_rna.obs[\"cell_types\"].isna().sum()\nprot_unmapped = adata_prot.obs[\"cell_types\"].isna().sum()\n# %% Processing\nif rna_unmapped > 0:\n    print(f\"Warning: {rna_unmapped} RNA cells with unmapped cell types\")\n    print(\n        f\"Unmapped cell types: {adata_rna.obs['cell_types'][adata_rna.obs['cell_types'].isna()].value_counts()}\"\n    )\n    adata_rna = adata_rna[~adata_rna.obs[\"cell_types\"].isna()].copy()\nif prot_unmapped > 0:",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "prot_unmapped",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "prot_unmapped = adata_prot.obs[\"cell_types\"].isna().sum()\n# %% Processing\nif rna_unmapped > 0:\n    print(f\"Warning: {rna_unmapped} RNA cells with unmapped cell types\")\n    print(\n        f\"Unmapped cell types: {adata_rna.obs['cell_types'][adata_rna.obs['cell_types'].isna()].value_counts()}\"\n    )\n    adata_rna = adata_rna[~adata_rna.obs[\"cell_types\"].isna()].copy()\nif prot_unmapped > 0:\n    print(f\"Warning: {prot_unmapped} protein cells with unmapped cell types\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "cell_type_counts_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "cell_type_counts_rna = adata_rna.obs[\"cell_types\"].value_counts()\nvalid_cell_types_rna = cell_type_counts_rna[cell_type_counts_rna > 100].index\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(valid_cell_types_rna)].copy()\ncell_type_counts_prot = adata_prot.obs[\"cell_types\"].value_counts()\nvalid_cell_types_prot = cell_type_counts_prot[cell_type_counts_prot > 100].index\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(valid_cell_types_prot)].copy()\nprint(f\"RNA dataset - Major cell types: {adata_rna.obs['cell_types'].value_counts()}\")\nprint(f\"Protein dataset - Major cell types: {adata_prot.obs['cell_types'].value_counts()}\")\n# %% --- Apply Color Scheme to Datasets ---\nprint(\"\\n=== Applying color scheme to datasets ===\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "valid_cell_types_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "valid_cell_types_rna = cell_type_counts_rna[cell_type_counts_rna > 100].index\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(valid_cell_types_rna)].copy()\ncell_type_counts_prot = adata_prot.obs[\"cell_types\"].value_counts()\nvalid_cell_types_prot = cell_type_counts_prot[cell_type_counts_prot > 100].index\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(valid_cell_types_prot)].copy()\nprint(f\"RNA dataset - Major cell types: {adata_rna.obs['cell_types'].value_counts()}\")\nprint(f\"Protein dataset - Major cell types: {adata_prot.obs['cell_types'].value_counts()}\")\n# %% --- Apply Color Scheme to Datasets ---\nprint(\"\\n=== Applying color scheme to datasets ===\")\n# Apply colors to both datasets",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(valid_cell_types_rna)].copy()\ncell_type_counts_prot = adata_prot.obs[\"cell_types\"].value_counts()\nvalid_cell_types_prot = cell_type_counts_prot[cell_type_counts_prot > 100].index\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(valid_cell_types_prot)].copy()\nprint(f\"RNA dataset - Major cell types: {adata_rna.obs['cell_types'].value_counts()}\")\nprint(f\"Protein dataset - Major cell types: {adata_prot.obs['cell_types'].value_counts()}\")\n# %% --- Apply Color Scheme to Datasets ---\nprint(\"\\n=== Applying color scheme to datasets ===\")\n# Apply colors to both datasets\nfor adata_temp, modality_name in [(adata_rna, \"RNA\"), (adata_prot, \"Protein\")]:",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "cell_type_counts_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "cell_type_counts_prot = adata_prot.obs[\"cell_types\"].value_counts()\nvalid_cell_types_prot = cell_type_counts_prot[cell_type_counts_prot > 100].index\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(valid_cell_types_prot)].copy()\nprint(f\"RNA dataset - Major cell types: {adata_rna.obs['cell_types'].value_counts()}\")\nprint(f\"Protein dataset - Major cell types: {adata_prot.obs['cell_types'].value_counts()}\")\n# %% --- Apply Color Scheme to Datasets ---\nprint(\"\\n=== Applying color scheme to datasets ===\")\n# Apply colors to both datasets\nfor adata_temp, modality_name in [(adata_rna, \"RNA\"), (adata_prot, \"Protein\")]:\n    # Set major cell type colors",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "valid_cell_types_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "valid_cell_types_prot = cell_type_counts_prot[cell_type_counts_prot > 100].index\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(valid_cell_types_prot)].copy()\nprint(f\"RNA dataset - Major cell types: {adata_rna.obs['cell_types'].value_counts()}\")\nprint(f\"Protein dataset - Major cell types: {adata_prot.obs['cell_types'].value_counts()}\")\n# %% --- Apply Color Scheme to Datasets ---\nprint(\"\\n=== Applying color scheme to datasets ===\")\n# Apply colors to both datasets\nfor adata_temp, modality_name in [(adata_rna, \"RNA\"), (adata_prot, \"Protein\")]:\n    # Set major cell type colors\n    adata_temp.uns[\"cell_types_colors\"] = [",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(valid_cell_types_prot)].copy()\nprint(f\"RNA dataset - Major cell types: {adata_rna.obs['cell_types'].value_counts()}\")\nprint(f\"Protein dataset - Major cell types: {adata_prot.obs['cell_types'].value_counts()}\")\n# %% --- Apply Color Scheme to Datasets ---\nprint(\"\\n=== Applying color scheme to datasets ===\")\n# Apply colors to both datasets\nfor adata_temp, modality_name in [(adata_rna, \"RNA\"), (adata_prot, \"Protein\")]:\n    # Set major cell type colors\n    adata_temp.uns[\"cell_types_colors\"] = [\n        major_colors[ct] for ct in adata_temp.obs[\"cell_types\"].cat.categories",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "total_elements",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "total_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nzero_elements = total_elements - adata_rna.X.nnz\nprint(f\"Number of zero elements proportion in RNA dataset: {zero_elements/total_elements}\")\n# Verify data is count data\nif issparse(adata_rna.X):\n    assert np.allclose(adata_rna.X.data, np.round(adata_rna.X.data))\nelse:\n    assert np.allclose(adata_rna.X, np.round(adata_rna.X))\n# %% --- Initial Analysis and Plots ---\npp_plots.plot_count_distribution(adata_rna, plot_flag)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "zero_elements",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "zero_elements = total_elements - adata_rna.X.nnz\nprint(f\"Number of zero elements proportion in RNA dataset: {zero_elements/total_elements}\")\n# Verify data is count data\nif issparse(adata_rna.X):\n    assert np.allclose(adata_rna.X.data, np.round(adata_rna.X.data))\nelse:\n    assert np.allclose(adata_rna.X, np.round(adata_rna.X))\n# %% --- Initial Analysis and Plots ---\npp_plots.plot_count_distribution(adata_rna, plot_flag)\npp_plots.plot_expression_heatmap(adata_rna, plot_flag)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\", \"nk cells\"])\nprint(\"Protein dataset:\")\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\", \"nk cells\"])\n# Get common cell types\ncommon_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types: {sorted(common_cell_types)}\")\n# Filter to common cell types\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(common_cell_types)].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\", \"nk cells\"])\n# Get common cell types\ncommon_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types: {sorted(common_cell_types)}\")\n# Filter to common cell types\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(common_cell_types)].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")\nprint(f\"RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Protein dataset shape: {adata_prot.shape}\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "common_cell_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "common_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types: {sorted(common_cell_types)}\")\n# Filter to common cell types\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(common_cell_types)].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")\nprint(f\"RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Protein dataset shape: {adata_prot.shape}\")\n# %% --- Apply Initial Preprocessing ---\nprint(\"\\n=== Applying initial preprocessing (MaxFuse methodology) ===\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(common_cell_types)].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")\nprint(f\"RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Protein dataset shape: {adata_prot.shape}\")\n# %% --- Apply Initial Preprocessing ---\nprint(\"\\n=== Applying initial preprocessing (MaxFuse methodology) ===\")\nadata_rna_processed = preprocess_rna_initial_steps(\n    adata_rna.copy(),\n    min_genes=200,",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")\nprint(f\"RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Protein dataset shape: {adata_prot.shape}\")\n# %% --- Apply Initial Preprocessing ---\nprint(\"\\n=== Applying initial preprocessing (MaxFuse methodology) ===\")\nadata_rna_processed = preprocess_rna_initial_steps(\n    adata_rna.copy(),\n    min_genes=200,\n    min_cells=3,",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna_processed",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna_processed = preprocess_rna_initial_steps(\n    adata_rna.copy(),\n    min_genes=200,\n    min_cells=3,\n    plot_flag=plot_flag,\n)\nprint(f\"Processed RNA dataset shape: {adata_rna_processed.shape}\")\nprint(f\"Cell type distribution in processed RNA dataset:\")\nprint(adata_rna_processed.obs[\"cell_types\"].value_counts())\n# Update main RNA dataset",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna = adata_rna_processed\n# Plot highly variable genes (CITE-seq-style)\nif plot_flag:\n    sc.pl.highly_variable_genes(adata_rna)\n# %% --- Apply Custom Setup for CITE-seq Dataset ---\nprint(f\"\\n=== Applying custom setup for CITE-seq dataset ===\")\nprint(f\"RNA cell types: {sorted(set(adata_rna.obs['cell_types']))}\")\nprint(f\"Protein cell types: {sorted(set(adata_prot.obs['cell_types']))}\")\n# Initialize pipeline metadata (like setup_dataset but without problematic cell type mapping)\n# Preserve applied_batch_correction if it exists from earlier initialization",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "applied_batch_correction",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "applied_batch_correction = adata_rna.uns.get(\"pipeline_metadata\", {}).get(\n    \"applied_batch_correction\", None\n)\nif applied_batch_correction is not None:\n    adata_rna.uns[\"pipeline_metadata\"][\"applied_batch_correction\"] = applied_batch_correction\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"day_of_collection\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"patient_id\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"day_of_collection\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"day_of_collection\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"patient_id\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n    \"protein\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n    \"metadata\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n}\nadata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"patient_id\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"patient_id\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n    \"protein\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n    \"metadata\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n}\nadata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)\nminor_cell_type_key = (",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n    \"protein\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n    \"metadata\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n}\nadata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)\nminor_cell_type_key = (\n    \"minor_cell_types\" if \"minor_cell_types\" in adata_rna.obs.columns else \"cell_types\"",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n    \"protein\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n    \"metadata\": \"raw_datasets/cite_seq/spleen_lymph_cite_seq.h5ad\",\n}\nadata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)\nminor_cell_type_key = (\n    \"minor_cell_types\" if \"minor_cell_types\" in adata_rna.obs.columns else \"cell_types\"\n)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"pipeline_metadata\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)\nminor_cell_type_key = (\n    \"minor_cell_types\" if \"minor_cell_types\" in adata_rna.obs.columns else \"cell_types\"\n)\nadata_rna = adata_rna[adata_rna.obs[minor_cell_type_key].argsort(), :].copy()\nadata_prot = adata_prot[adata_prot.obs[minor_cell_type_key].argsort(), :].copy()\n# Remove redundant gene columns if they exist\nif \"gene\" in adata_rna.var.columns and np.array_equal(\n    adata_rna.var[\"gene\"].values, (adata_rna.var.index.values)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "minor_cell_type_key",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "minor_cell_type_key = (\n    \"minor_cell_types\" if \"minor_cell_types\" in adata_rna.obs.columns else \"cell_types\"\n)\nadata_rna = adata_rna[adata_rna.obs[minor_cell_type_key].argsort(), :].copy()\nadata_prot = adata_prot[adata_prot.obs[minor_cell_type_key].argsort(), :].copy()\n# Remove redundant gene columns if they exist\nif \"gene\" in adata_rna.var.columns and np.array_equal(\n    adata_rna.var[\"gene\"].values, (adata_rna.var.index.values)\n):\n    adata_rna.var.drop(columns=\"gene\", inplace=True)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna = adata_rna[adata_rna.obs[minor_cell_type_key].argsort(), :].copy()\nadata_prot = adata_prot[adata_prot.obs[minor_cell_type_key].argsort(), :].copy()\n# Remove redundant gene columns if they exist\nif \"gene\" in adata_rna.var.columns and np.array_equal(\n    adata_rna.var[\"gene\"].values, (adata_rna.var.index.values)\n):\n    adata_rna.var.drop(columns=\"gene\", inplace=True)\nif \"gene\" in adata_prot.var.columns and np.array_equal(\n    adata_prot.var[\"gene\"].values, (adata_prot.var.index.values)\n):",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot = adata_prot[adata_prot.obs[minor_cell_type_key].argsort(), :].copy()\n# Remove redundant gene columns if they exist\nif \"gene\" in adata_rna.var.columns and np.array_equal(\n    adata_rna.var[\"gene\"].values, (adata_rna.var.index.values)\n):\n    adata_rna.var.drop(columns=\"gene\", inplace=True)\nif \"gene\" in adata_prot.var.columns and np.array_equal(\n    adata_prot.var[\"gene\"].values, (adata_prot.var.index.values)\n):\n    adata_prot.var.drop(columns=\"gene\", inplace=True)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\"])\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\npp_plots.plot_protein_violin(adata_prot, plot_flag)\nplt.figure(figsize=(10, 6))\nplt.title(\"Protein expression before outlier removal\")\nadata_prot_plot = adata_prot[np.random.choice(adata_prot.n_obs, size=2000, replace=False)].copy()\n# sort by cell_types\nadata_prot_plot = adata_prot_plot[adata_prot_plot.obs[\"cell_types\"].argsort(), :].copy()\nplt.plot(np.sort(adata_prot_plot.X[:, :50], axis=0))\nplt.show()",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\npp_plots.plot_protein_violin(adata_prot, plot_flag)\nplt.figure(figsize=(10, 6))\nplt.title(\"Protein expression before outlier removal\")\nadata_prot_plot = adata_prot[np.random.choice(adata_prot.n_obs, size=2000, replace=False)].copy()\n# sort by cell_types\nadata_prot_plot = adata_prot_plot[adata_prot_plot.obs[\"cell_types\"].argsort(), :].copy()\nplt.plot(np.sort(adata_prot_plot.X[:, :50], axis=0))\nplt.show()\nadata_prot = mad_outlier_removal(adata_prot.copy()).copy()",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot_plot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot_plot = adata_prot[np.random.choice(adata_prot.n_obs, size=2000, replace=False)].copy()\n# sort by cell_types\nadata_prot_plot = adata_prot_plot[adata_prot_plot.obs[\"cell_types\"].argsort(), :].copy()\nplt.plot(np.sort(adata_prot_plot.X[:, :50], axis=0))\nplt.show()\nadata_prot = mad_outlier_removal(adata_prot.copy()).copy()\nplt.figure(figsize=(10, 6))\nplt.title(\"Protein expression after outlier removal\")\nplt.plot(np.sort(adata_prot.X[:, :50], axis=0))\nplt.show()",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot_plot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot_plot = adata_prot_plot[adata_prot_plot.obs[\"cell_types\"].argsort(), :].copy()\nplt.plot(np.sort(adata_prot_plot.X[:, :50], axis=0))\nplt.show()\nadata_prot = mad_outlier_removal(adata_prot.copy()).copy()\nplt.figure(figsize=(10, 6))\nplt.title(\"Protein expression after outlier removal\")\nplt.plot(np.sort(adata_prot.X[:, :50], axis=0))\nplt.show()\n# Add major_cell_types column (needed for downstream compatibility)\nadata_rna.obs[\"major_cell_types\"] = adata_rna.obs[\"cell_types\"]",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot = mad_outlier_removal(adata_prot.copy()).copy()\nplt.figure(figsize=(10, 6))\nplt.title(\"Protein expression after outlier removal\")\nplt.plot(np.sort(adata_prot.X[:, :50], axis=0))\nplt.show()\n# Add major_cell_types column (needed for downstream compatibility)\nadata_rna.obs[\"major_cell_types\"] = adata_rna.obs[\"cell_types\"]\nadata_prot.obs[\"major_cell_types\"] = adata_prot.obs[\"cell_types\"]\n# %% --- Protein Analysis Following MaxFuse Methodology ---\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag, modality=\"Protein\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.obs[\"major_cell_types\"] = adata_rna.obs[\"cell_types\"]\nadata_prot.obs[\"major_cell_types\"] = adata_prot.obs[\"cell_types\"]\n# %% --- Protein Analysis Following MaxFuse Methodology ---\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag, modality=\"Protein\")\n# Take subsample for spatial analysis\nadata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(6000, adata_prot.n_obs), replace=False)\n].copy()\n# Apply spatial analysis (following MaxFuse methodology)\nsc.pp.pca(adata_prot_subsampled, copy=False)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot.obs[\"major_cell_types\"] = adata_prot.obs[\"cell_types\"]\n# %% --- Protein Analysis Following MaxFuse Methodology ---\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag, modality=\"Protein\")\n# Take subsample for spatial analysis\nadata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(6000, adata_prot.n_obs), replace=False)\n].copy()\n# Apply spatial analysis (following MaxFuse methodology)\nsc.pp.pca(adata_prot_subsampled, copy=False)\nsc.pp.neighbors(adata_prot_subsampled, use_rep=\"X_pca\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot_subsampled",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(6000, adata_prot.n_obs), replace=False)\n].copy()\n# Apply spatial analysis (following MaxFuse methodology)\nsc.pp.pca(adata_prot_subsampled, copy=False)\nsc.pp.neighbors(adata_prot_subsampled, use_rep=\"X_pca\")\nsc.tl.umap(adata_prot_subsampled)\npp_plots.plot_umap_analysis(adata_prot_subsampled, \"cell_types\", \"Cell Types\", plot_flag)\n# %% --- Finalize Pipeline Metadata ---\n# Create sample names for metadata (cite-seq doesn't have multiple samples)",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "sample_names",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "sample_names = [\"cite_seq_sample\"]\npipeline_metadata_utils.finalize_preprocess_metadata(adata_rna, adata_prot, sample_names)\nadata_prot.obs[\"cell_types\"].unique()\n# Remove duplicates from adata_prot.obs.index and adata_prot.var.index\nprint(f\"Before removing duplicates: {adata_prot.shape[0]} cells, {adata_prot.shape[1]} features\")\nprint(f\"Obs index is unique: {adata_prot.obs.index.is_unique}\")\nprint(f\"Var index is unique: {adata_prot.var.index.is_unique}\")\n# Remove duplicate obs indices\nif not adata_prot.obs.index.is_unique:\n    duplicate_obs = adata_prot.obs.index.duplicated(keep=\"first\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.layers[\"normalized\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.layers[\"normalized\"] = adata_rna.X.copy()\n# Apply log1p transformation\nsc.pp.log1p(adata_rna)\nprint(f\"  After log1p - X range: [{adata_rna.X.min():.2f}, {adata_rna.X.max():.2f}]\")\n# Save log1p data to layer (backup)\nadata_rna.layers[\"log1p\"] = adata_rna.X.copy()\nprint(\"  Kept log1p(normalized) data in X for VAE training\")\n# Update metadata\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"normalize_total\",",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.layers[\"log1p\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.layers[\"log1p\"] = adata_rna.X.copy()\nprint(\"  Kept log1p(normalized) data in X for VAE training\")\n# Update metadata\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"normalize_total\",\n    \"target_sum\": 40000,\n    \"applied\": True,\n    \"log1p_applied\": True,\n    \"layers_info\": {\n        \"counts\": \"raw counts (backup only)\",",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"normalization\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"normalize_total\",\n    \"target_sum\": 40000,\n    \"applied\": True,\n    \"log1p_applied\": True,\n    \"layers_info\": {\n        \"counts\": \"raw counts (backup only)\",\n        \"normalized\": \"normalized counts (target_sum=40000, backup only)\",\n        \"log1p\": \"log1p(normalized counts) - in X for VAE\",\n    },",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot = z_normalize_codex(adata_prot.copy(), apply_log1p=False)\nprint(f\"  After z-normalization - X range: [{adata_prot.X.min():.2f}, {adata_prot.X.max():.2f}]\")\n# Keep z-normalized data in X for VAE training (this is what VAE needs)\n# Save backup to layer as well\nadata_prot.layers[\"z_normalized\"] = adata_prot.X.copy()\nprint(\"  Kept z-normalized data in X for VAE training (protein VAE trains on normalized data)\")\n# Update metadata\nadata_prot.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"z_normalize\",\n    \"applied\": True,",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot.layers[\"z_normalized\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot.layers[\"z_normalized\"] = adata_prot.X.copy()\nprint(\"  Kept z-normalized data in X for VAE training (protein VAE trains on normalized data)\")\n# Update metadata\nadata_prot.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"z_normalize\",\n    \"applied\": True,\n    \"log1p_applied\": False,\n    \"layers_info\": {\n        \"counts\": \"raw counts (backup only)\",\n        \"z_normalized\": \"z-normalized protein expression (no log1p) - in X for VAE\",",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"pipeline_metadata\"][\"normalization\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"z_normalize\",\n    \"applied\": True,\n    \"log1p_applied\": False,\n    \"layers_info\": {\n        \"counts\": \"raw counts (backup only)\",\n        \"z_normalized\": \"z-normalized protein expression (no log1p) - in X for VAE\",\n    },\n    \"note\": \"Protein X contains z-normalized data for VAE training\",\n}",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_rna.uns[\"dataset_name\"] = dataset_name\nadata_prot.uns[\"dataset_name\"] = dataset_name\nsave_processed_data(adata_rna, adata_prot, \"processed_data\", caller_filename=FILENAME)\nprint(\" CITE-seq dataset preprocessing completed successfully using MaxFuse methodology!\")\nprint(f\"Final RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Final protein dataset shape: {adata_prot.shape}\")\nprint(f\"Common cell types: {sorted(set(adata_rna.obs['cell_types']))}\")\nprint(f\"Output saved to: processed_data/\")\n# %% --- Final Preprocessing Results Plots ---\nif plot_flag:",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_cite_seq",
        "description": "ARCADIA.scripts._0_preprocess_cite_seq",
        "peekOfCode": "adata_prot.uns[\"dataset_name\"] = dataset_name\nsave_processed_data(adata_rna, adata_prot, \"processed_data\", caller_filename=FILENAME)\nprint(\" CITE-seq dataset preprocessing completed successfully using MaxFuse methodology!\")\nprint(f\"Final RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Final protein dataset shape: {adata_prot.shape}\")\nprint(f\"Common cell types: {sorted(set(adata_rna.obs['cell_types']))}\")\nprint(f\"Output saved to: processed_data/\")\n# %% --- Final Preprocessing Results Plots ---\nif plot_flag:\n    print(\"Generating final preprocessing results plots...\")",
        "detail": "ARCADIA.scripts._0_preprocess_cite_seq",
        "documentation": {}
    },
    {
        "label": "here",
        "kind": 2,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "def here():\n    try:\n        return Path(__file__).resolve().parent\n    except NameError:\n        return Path.cwd()\n# Determine ROOT based on whether we're running as script or notebook\ntry:\n    ROOT = Path(__file__).resolve().parent.parent\nexcept NameError:\n    # Running as notebook - use current working directory",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "THIS_DIR = here()\n# Add src to path for arcadia package\nif str(ROOT / \"src\") not in sys.path:\n    sys.path.insert(0, str(ROOT / \"src\"))\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nos.chdir(str(ROOT))\nimport numpy as np\nimport pandas as pd",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "config_path = Path(\"configs/config.json\")\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "start_time",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "start_time = datetime.now()\ntimestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\")\n# %% --- Directory Structure Definition ---\nbase_path = \".\"\ndataset_name = \"schreiber\"\nFILENAME = f\"_0_preprocess_{dataset_name}.py\"\ndirectories = [\n    \"processed_data\",\n    \"raw_datasets/{dataset_name}\",",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "timestamp_str",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "timestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\")\n# %% --- Directory Structure Definition ---\nbase_path = \".\"\ndataset_name = \"schreiber\"\nFILENAME = f\"_0_preprocess_{dataset_name}.py\"\ndirectories = [\n    \"processed_data\",\n    \"raw_datasets/{dataset_name}\",\n]",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "base_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "base_path = \".\"\ndataset_name = \"schreiber\"\nFILENAME = f\"_0_preprocess_{dataset_name}.py\"\ndirectories = [\n    \"processed_data\",\n    \"raw_datasets/{dataset_name}\",\n]\nprint(f\"Creating directory structure under: {os.path.abspath(base_path)}\")\ndataset_path = f\"raw_datasets/{dataset_name}\"\nfor rel_path in directories:",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "dataset_name = \"schreiber\"\nFILENAME = f\"_0_preprocess_{dataset_name}.py\"\ndirectories = [\n    \"processed_data\",\n    \"raw_datasets/{dataset_name}\",\n]\nprint(f\"Creating directory structure under: {os.path.abspath(base_path)}\")\ndataset_path = f\"raw_datasets/{dataset_name}\"\nfor rel_path in directories:\n    full_path = os.path.join(base_path, rel_path)",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "FILENAME = f\"_0_preprocess_{dataset_name}.py\"\ndirectories = [\n    \"processed_data\",\n    \"raw_datasets/{dataset_name}\",\n]\nprint(f\"Creating directory structure under: {os.path.abspath(base_path)}\")\ndataset_path = f\"raw_datasets/{dataset_name}\"\nfor rel_path in directories:\n    full_path = os.path.join(base_path, rel_path)\n    os.makedirs(full_path, exist_ok=True)",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "directories",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "directories = [\n    \"processed_data\",\n    \"raw_datasets/{dataset_name}\",\n]\nprint(f\"Creating directory structure under: {os.path.abspath(base_path)}\")\ndataset_path = f\"raw_datasets/{dataset_name}\"\nfor rel_path in directories:\n    full_path = os.path.join(base_path, rel_path)\n    os.makedirs(full_path, exist_ok=True)\n# %%",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "dataset_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "dataset_path = f\"raw_datasets/{dataset_name}\"\nfor rel_path in directories:\n    full_path = os.path.join(base_path, rel_path)\n    os.makedirs(full_path, exist_ok=True)\n# %%\nrna_annotation_cell_kevin = pd.read_csv(\n    f\"{dataset_path}/annotated_cells_for_Kevin.tsv\", sep=\"\\t\", index_col=0\n)\nharmonization_mapping_path = f\"{dataset_path}/modality_cell_type_harmonization.yaml\"\nwith open(harmonization_mapping_path, \"r\") as f:",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "rna_annotation_cell_kevin",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "rna_annotation_cell_kevin = pd.read_csv(\n    f\"{dataset_path}/annotated_cells_for_Kevin.tsv\", sep=\"\\t\", index_col=0\n)\nharmonization_mapping_path = f\"{dataset_path}/modality_cell_type_harmonization.yaml\"\nwith open(harmonization_mapping_path, \"r\") as f:\n    harmonization_mapping = yaml.safe_load(f)\nfile_path = f\"{dataset_path}/mouse_ICB_scRNA_umap_labelled.h5ad\"\nadata_rna = read_legacy_adata(file_path)\nadata_rna.X = adata_rna.layers[\"counts\"]\n# to sparse matrix if needed",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "harmonization_mapping_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "harmonization_mapping_path = f\"{dataset_path}/modality_cell_type_harmonization.yaml\"\nwith open(harmonization_mapping_path, \"r\") as f:\n    harmonization_mapping = yaml.safe_load(f)\nfile_path = f\"{dataset_path}/mouse_ICB_scRNA_umap_labelled.h5ad\"\nadata_rna = read_legacy_adata(file_path)\nadata_rna.X = adata_rna.layers[\"counts\"]\n# to sparse matrix if needed\nadata_rna.X = adata_rna.X.tocsr()\nadata_rna.obs[\"cell_types\"] = pd.Categorical(\n    rna_annotation_cell_kevin.loc[adata_rna.obs.index, \"annotation\"]",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "file_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "file_path = f\"{dataset_path}/mouse_ICB_scRNA_umap_labelled.h5ad\"\nadata_rna = read_legacy_adata(file_path)\nadata_rna.X = adata_rna.layers[\"counts\"]\n# to sparse matrix if needed\nadata_rna.X = adata_rna.X.tocsr()\nadata_rna.obs[\"cell_types\"] = pd.Categorical(\n    rna_annotation_cell_kevin.loc[adata_rna.obs.index, \"annotation\"]\n)\nadata_rna.obs[\"batch\"] = \"batch_0\"\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna = read_legacy_adata(file_path)\nadata_rna.X = adata_rna.layers[\"counts\"]\n# to sparse matrix if needed\nadata_rna.X = adata_rna.X.tocsr()\nadata_rna.obs[\"cell_types\"] = pd.Categorical(\n    rna_annotation_cell_kevin.loc[adata_rna.obs.index, \"annotation\"]\n)\nadata_rna.obs[\"batch\"] = \"batch_0\"\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.X = adata_rna.layers[\"counts\"]\n# to sparse matrix if needed\nadata_rna.X = adata_rna.X.tocsr()\nadata_rna.obs[\"cell_types\"] = pd.Categorical(\n    rna_annotation_cell_kevin.loc[adata_rna.obs.index, \"annotation\"]\n)\nadata_rna.obs[\"batch\"] = \"batch_0\"\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.X = adata_rna.X.tocsr()\nadata_rna.obs[\"cell_types\"] = pd.Categorical(\n    rna_annotation_cell_kevin.loc[adata_rna.obs.index, \"annotation\"]\n)\nadata_rna.obs[\"batch\"] = \"batch_0\"\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\n# %%\ntotal_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.obs[\"cell_types\"] = pd.Categorical(\n    rna_annotation_cell_kevin.loc[adata_rna.obs.index, \"annotation\"]\n)\nadata_rna.obs[\"batch\"] = \"batch_0\"\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\n# %%\ntotal_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nprint(",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"batch\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.obs[\"batch\"] = \"batch_0\"\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\n# %%\ntotal_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nprint(\n    f\"Number of zero elements proportion in new dataset: num of genes is {adata_rna.X.shape[1]} and the proportion of zero elements is {(total_elements - adata_rna.X.nnz)/total_elements}\"\n)\n# %%",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\n# %%\ntotal_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nprint(\n    f\"Number of zero elements proportion in new dataset: num of genes is {adata_rna.X.shape[1]} and the proportion of zero elements is {(total_elements - adata_rna.X.nnz)/total_elements}\"\n)\n# %%\npp_plots.plot_count_distribution(adata_rna, plot_flag)",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "total_elements",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "total_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nprint(\n    f\"Number of zero elements proportion in new dataset: num of genes is {adata_rna.X.shape[1]} and the proportion of zero elements is {(total_elements - adata_rna.X.nnz)/total_elements}\"\n)\n# %%\npp_plots.plot_count_distribution(adata_rna, plot_flag)\npp_plots.plot_expression_heatmap(adata_rna, plot_flag)\nadata_rna.X = adata_rna.X.tocsr()\n# %%\nassert np.allclose(adata_rna.X.data, np.round(adata_rna.X.data))",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.X = adata_rna.X.tocsr()\n# %%\nassert np.allclose(adata_rna.X.data, np.round(adata_rna.X.data))\nadata_rna = preprocess_rna_initial_steps(adata_rna, min_genes=200, min_cells=3, plot_flag=plot_flag)\nprint(f\"\\nMerged dataset shape: {adata_rna.shape}\")\nprint(f\"Cell type distribution in merged dataset:\")\nprint(adata_rna.obs[\"cell_types\"].value_counts())\nprint(f\"Dataset source distribution:\")\nprint(adata_rna.obs[\"batch\"].value_counts())\n# %% Processing",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna = preprocess_rna_initial_steps(adata_rna, min_genes=200, min_cells=3, plot_flag=plot_flag)\nprint(f\"\\nMerged dataset shape: {adata_rna.shape}\")\nprint(f\"Cell type distribution in merged dataset:\")\nprint(adata_rna.obs[\"cell_types\"].value_counts())\nprint(f\"Dataset source distribution:\")\nprint(adata_rna.obs[\"batch\"].value_counts())\n# %% Processing\nbatch_means = (\n    pd.DataFrame(adata_rna.X.toarray() if hasattr(adata_rna.X, \"toarray\") else adata_rna.X)\n    .groupby(adata_rna.obs[\"batch\"].values)",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "batch_means",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "batch_means = (\n    pd.DataFrame(adata_rna.X.toarray() if hasattr(adata_rna.X, \"toarray\") else adata_rna.X)\n    .groupby(adata_rna.obs[\"batch\"].values)\n    .mean()\n)\n# plot heatmap of subsample of the adata_rna.X\nadata_rna.X = adata_rna.X.astype(float)\npp_plots.plot_merged_dataset_analysis(adata_rna, plot_flag)\nsc.pp.normalize_total(adata_rna)\nsc.pp.log1p(adata_rna)",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.X = adata_rna.X.astype(float)\npp_plots.plot_merged_dataset_analysis(adata_rna, plot_flag)\nsc.pp.normalize_total(adata_rna)\nsc.pp.log1p(adata_rna)\nadata_rna.uns[\"pipeline_metadata\"][\"log1p\"] = True\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {}\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"][\"log1p_applied\"] = False\nadata_rna.layers[\"log1p\"] = adata_rna.X.copy()\n# %% load protein data\nadata_prot = sc.read(f\"{dataset_path}/codex_cn_tumor.h5ad\")",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"log1p\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"log1p\"] = True\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {}\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"][\"log1p_applied\"] = False\nadata_rna.layers[\"log1p\"] = adata_rna.X.copy()\n# %% load protein data\nadata_prot = sc.read(f\"{dataset_path}/codex_cn_tumor.h5ad\")\nprot_metadata = pd.read_csv(f\"{dataset_path}/codex_meta.csv\")\nadata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\"])\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\n# Assign metadata and labels from codex csv to adata",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"normalization\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {}\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"][\"log1p_applied\"] = False\nadata_rna.layers[\"log1p\"] = adata_rna.X.copy()\n# %% load protein data\nadata_prot = sc.read(f\"{dataset_path}/codex_cn_tumor.h5ad\")\nprot_metadata = pd.read_csv(f\"{dataset_path}/codex_meta.csv\")\nadata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\"])\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\n# Assign metadata and labels from codex csv to adata\nadata_prot.obs[\"cell_types\"] = pd.Categorical(adata_prot.obs[\"cell_type\"])",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"normalization\"][\"log1p_applied\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"normalization\"][\"log1p_applied\"] = False\nadata_rna.layers[\"log1p\"] = adata_rna.X.copy()\n# %% load protein data\nadata_prot = sc.read(f\"{dataset_path}/codex_cn_tumor.h5ad\")\nprot_metadata = pd.read_csv(f\"{dataset_path}/codex_meta.csv\")\nadata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\"])\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\n# Assign metadata and labels from codex csv to adata\nadata_prot.obs[\"cell_types\"] = pd.Categorical(adata_prot.obs[\"cell_type\"])\nadata_prot.obs[\"granular_cell_types\"] = pd.Categorical(prot_metadata[\"cell_type\"])",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna.layers[\"log1p\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna.layers[\"log1p\"] = adata_rna.X.copy()\n# %% load protein data\nadata_prot = sc.read(f\"{dataset_path}/codex_cn_tumor.h5ad\")\nprot_metadata = pd.read_csv(f\"{dataset_path}/codex_meta.csv\")\nadata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\"])\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\n# Assign metadata and labels from codex csv to adata\nadata_prot.obs[\"cell_types\"] = pd.Categorical(adata_prot.obs[\"cell_type\"])\nadata_prot.obs[\"granular_cell_types\"] = pd.Categorical(prot_metadata[\"cell_type\"])\nadata_prot.obs[\"Image\"] = prot_metadata[\"Image\"].astype(str).values",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot = sc.read(f\"{dataset_path}/codex_cn_tumor.h5ad\")\nprot_metadata = pd.read_csv(f\"{dataset_path}/codex_meta.csv\")\nadata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\"])\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\n# Assign metadata and labels from codex csv to adata\nadata_prot.obs[\"cell_types\"] = pd.Categorical(adata_prot.obs[\"cell_type\"])\nadata_prot.obs[\"granular_cell_types\"] = pd.Categorical(prot_metadata[\"cell_type\"])\nadata_prot.obs[\"Image\"] = prot_metadata[\"Image\"].astype(str).values\nadata_prot.obs[\"lab_CN\"] = pd.Categorical(adata_prot.obs[\"neighborhood\"])\nadata_prot.obs[\"lab_CN\"] = (",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "prot_metadata",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "prot_metadata = pd.read_csv(f\"{dataset_path}/codex_meta.csv\")\nadata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\"])\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\n# Assign metadata and labels from codex csv to adata\nadata_prot.obs[\"cell_types\"] = pd.Categorical(adata_prot.obs[\"cell_type\"])\nadata_prot.obs[\"granular_cell_types\"] = pd.Categorical(prot_metadata[\"cell_type\"])\nadata_prot.obs[\"Image\"] = prot_metadata[\"Image\"].astype(str).values\nadata_prot.obs[\"lab_CN\"] = pd.Categorical(adata_prot.obs[\"neighborhood\"])\nadata_prot.obs[\"lab_CN\"] = (\n    adata_prot.obs[\"lab_CN\"]",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\"])\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\n# Assign metadata and labels from codex csv to adata\nadata_prot.obs[\"cell_types\"] = pd.Categorical(adata_prot.obs[\"cell_type\"])\nadata_prot.obs[\"granular_cell_types\"] = pd.Categorical(prot_metadata[\"cell_type\"])\nadata_prot.obs[\"Image\"] = prot_metadata[\"Image\"].astype(str).values\nadata_prot.obs[\"lab_CN\"] = pd.Categorical(adata_prot.obs[\"neighborhood\"])\nadata_prot.obs[\"lab_CN\"] = (\n    adata_prot.obs[\"lab_CN\"]\n    .replace(harmonization_mapping[\"cn_to_codex_mapping\"])",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\"])\n# Assign metadata and labels from codex csv to adata\nadata_prot.obs[\"cell_types\"] = pd.Categorical(adata_prot.obs[\"cell_type\"])\nadata_prot.obs[\"granular_cell_types\"] = pd.Categorical(prot_metadata[\"cell_type\"])\nadata_prot.obs[\"Image\"] = prot_metadata[\"Image\"].astype(str).values\nadata_prot.obs[\"lab_CN\"] = pd.Categorical(adata_prot.obs[\"neighborhood\"])\nadata_prot.obs[\"lab_CN\"] = (\n    adata_prot.obs[\"lab_CN\"]\n    .replace(harmonization_mapping[\"cn_to_codex_mapping\"])\n    .astype(\"category\")",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot.obs[\"cell_types\"] = pd.Categorical(adata_prot.obs[\"cell_type\"])\nadata_prot.obs[\"granular_cell_types\"] = pd.Categorical(prot_metadata[\"cell_type\"])\nadata_prot.obs[\"Image\"] = prot_metadata[\"Image\"].astype(str).values\nadata_prot.obs[\"lab_CN\"] = pd.Categorical(adata_prot.obs[\"neighborhood\"])\nadata_prot.obs[\"lab_CN\"] = (\n    adata_prot.obs[\"lab_CN\"]\n    .replace(harmonization_mapping[\"cn_to_codex_mapping\"])\n    .astype(\"category\")\n)\nadata_prot.layers[\"raw\"] = adata_prot.X",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"granular_cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot.obs[\"granular_cell_types\"] = pd.Categorical(prot_metadata[\"cell_type\"])\nadata_prot.obs[\"Image\"] = prot_metadata[\"Image\"].astype(str).values\nadata_prot.obs[\"lab_CN\"] = pd.Categorical(adata_prot.obs[\"neighborhood\"])\nadata_prot.obs[\"lab_CN\"] = (\n    adata_prot.obs[\"lab_CN\"]\n    .replace(harmonization_mapping[\"cn_to_codex_mapping\"])\n    .astype(\"category\")\n)\nadata_prot.layers[\"raw\"] = adata_prot.X\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag)",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"Image\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot.obs[\"Image\"] = prot_metadata[\"Image\"].astype(str).values\nadata_prot.obs[\"lab_CN\"] = pd.Categorical(adata_prot.obs[\"neighborhood\"])\nadata_prot.obs[\"lab_CN\"] = (\n    adata_prot.obs[\"lab_CN\"]\n    .replace(harmonization_mapping[\"cn_to_codex_mapping\"])\n    .astype(\"category\")\n)\nadata_prot.layers[\"raw\"] = adata_prot.X\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag)\n# # todo: remove later",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"lab_CN\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot.obs[\"lab_CN\"] = pd.Categorical(adata_prot.obs[\"neighborhood\"])\nadata_prot.obs[\"lab_CN\"] = (\n    adata_prot.obs[\"lab_CN\"]\n    .replace(harmonization_mapping[\"cn_to_codex_mapping\"])\n    .astype(\"category\")\n)\nadata_prot.layers[\"raw\"] = adata_prot.X\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag)\n# # todo: remove later\n# sc.pp.subsample(adata_prot, n_obs=min(10000, adata_prot.n_obs))",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"lab_CN\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot.obs[\"lab_CN\"] = (\n    adata_prot.obs[\"lab_CN\"]\n    .replace(harmonization_mapping[\"cn_to_codex_mapping\"])\n    .astype(\"category\")\n)\nadata_prot.layers[\"raw\"] = adata_prot.X\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag)\n# # todo: remove later\n# sc.pp.subsample(adata_prot, n_obs=min(10000, adata_prot.n_obs))\n# sc.pp.subsample(adata_rna, n_obs=min(10000, adata_rna.n_obs))",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot.layers[\"raw\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot.layers[\"raw\"] = adata_prot.X\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag)\n# # todo: remove later\n# sc.pp.subsample(adata_prot, n_obs=min(10000, adata_prot.n_obs))\n# sc.pp.subsample(adata_rna, n_obs=min(10000, adata_rna.n_obs))\nadata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(4000, adata_prot.n_obs), replace=False)\n]\nsc.pp.pca(adata_prot_subsampled)\nsc.pp.neighbors(adata_prot_subsampled, use_rep=\"X_pca\")",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot_subsampled",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(4000, adata_prot.n_obs), replace=False)\n]\nsc.pp.pca(adata_prot_subsampled)\nsc.pp.neighbors(adata_prot_subsampled, use_rep=\"X_pca\")\nsc.tl.umap(adata_prot_subsampled)\nsc.pl.umap(adata_prot_subsampled, color=\"cell_types\")\nsc.pl.umap(adata_prot_subsampled, color=\"condition\")\nsc.pl.umap(\n    adata_prot_subsampled[adata_prot_subsampled.obs[\"condition\"] == \"ICT\",], color=\"cell_types\"",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_rna_subsampled",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_rna_subsampled = adata_rna[\n    np.random.choice(adata_rna.n_obs, size=min(4000, adata_rna.n_obs), replace=False)\n]\nsc.pp.pca(adata_rna_subsampled)\nsc.pp.neighbors(adata_rna_subsampled)\nsc.tl.umap(adata_rna_subsampled)\nsc.pl.umap(adata_rna_subsampled, color=\"cell_types\")\n# %%\nif plot_flag:\n    images = set(adata_prot.obs[\"Image\"])",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "protein_sample_names",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "protein_sample_names = [\n    \"cntrl_n109_d10\",\n    \"cntrl_n130_d10\",\n    \"cntrl_n131_d10\",\n    \"cntrl_n140_d10\",\n    \"cntrl_n251_d10\",\n    \"ict_n112_d10\",\n    \"ict_n113_d10\",\n    \"ict_n205_d10\",\n    \"ict_n212_d10\",",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "valid_protein_sample_names",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "valid_protein_sample_names = [\"cntrl_n251_d10\", \"ict_n205_d10\"]\n# plot the barplot of\nfor sample in sorted(protein_sample_names):\n    counts = adata_prot[adata_prot.obs[\"Image\"] == sample].obs[\"cell_types\"].value_counts()\n    # drop tumor cells\n    counts = counts.sort_index()  # sort bars alphabetically by cell type\n    ax = counts.plot.bar(title=f\"Proportion of cell types in sample {sample}\", rot=45)\n    ax.set_ylabel(\"Proportion\")\n    ax.set_xlabel(\"Cell Type\")\n    plt.tight_layout()",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot = adata_prot[adata_prot.obs[\"Image\"].isin(valid_protein_sample_names)].copy()\nadata_prot.obs[\"batch\"] = adata_prot.obs[\"Image\"]\n# %% Treatment filtering has already been applied during merge process:\n# The merged adata_rna now contains only treated cells from both datasets\nprint(f\"Shape: {adata_rna.shape}\")\nprint(f'Dataset source distribution: {adata_rna.obs[\"batch\"].value_counts().to_dict()}')\nif \"Sample\" in adata_rna.obs.columns:\n    print(f'Sample values: {adata_rna.obs[\"Sample\"].value_counts().to_dict()}')\nif \"treated\" in adata_rna.obs.columns:\n    print(f'Treated values: {adata_rna.obs[\"treated\"].value_counts().to_dict()}')",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"batch\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot.obs[\"batch\"] = adata_prot.obs[\"Image\"]\n# %% Treatment filtering has already been applied during merge process:\n# The merged adata_rna now contains only treated cells from both datasets\nprint(f\"Shape: {adata_rna.shape}\")\nprint(f'Dataset source distribution: {adata_rna.obs[\"batch\"].value_counts().to_dict()}')\nif \"Sample\" in adata_rna.obs.columns:\n    print(f'Sample values: {adata_rna.obs[\"Sample\"].value_counts().to_dict()}')\nif \"treated\" in adata_rna.obs.columns:\n    print(f'Treated values: {adata_rna.obs[\"treated\"].value_counts().to_dict()}')\n# %% Debug/Logging",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot.layers[\"z_normalized\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot.layers[\"z_normalized\"] = adata_prot.X.copy()\nadata_prot_subsampled = sc.pp.subsample(\n    adata_prot, n_obs=min(9000, adata_prot.n_obs), copy=True\n).copy()\nsc.pp.pca(adata_prot_subsampled)\nsc.pp.neighbors(adata_prot_subsampled, use_rep=\"X_pca\")\nsc.tl.umap(adata_prot_subsampled)\nsc.pl.umap(adata_prot_subsampled, color=\"cell_types\")\nadata_prot = mad_outlier_removal(adata_prot)\n# Finalize pipeline metadata before saving",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot_subsampled",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot_subsampled = sc.pp.subsample(\n    adata_prot, n_obs=min(9000, adata_prot.n_obs), copy=True\n).copy()\nsc.pp.pca(adata_prot_subsampled)\nsc.pp.neighbors(adata_prot_subsampled, use_rep=\"X_pca\")\nsc.tl.umap(adata_prot_subsampled)\nsc.pl.umap(adata_prot_subsampled, color=\"cell_types\")\nadata_prot = mad_outlier_removal(adata_prot)\n# Finalize pipeline metadata before saving\npipeline_metadata_utils.finalize_preprocess_metadata(adata_rna, adata_prot, [\"batch_0\"])",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot = mad_outlier_removal(adata_prot)\n# Finalize pipeline metadata before saving\npipeline_metadata_utils.finalize_preprocess_metadata(adata_rna, adata_prot, [\"batch_0\"])\nfig, axs = plt.subplots(5, 6, figsize=(10, 6))\nplt.subplots_adjust(hspace=1.0)  # Increase hspace for more vertical space\nadata_prot_subsampled = sc.pp.subsample(adata_prot, n_obs=1000, copy=True)\nlayer = \"z_normalized\"\nfor i in range(30):\n    sns.kdeplot(\n        adata_prot_subsampled.to_df(layer=layer).iloc[:, i], legend=False, ax=axs[i // 6, i % 6]",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot_subsampled",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot_subsampled = sc.pp.subsample(adata_prot, n_obs=1000, copy=True)\nlayer = \"z_normalized\"\nfor i in range(30):\n    sns.kdeplot(\n        adata_prot_subsampled.to_df(layer=layer).iloc[:, i], legend=False, ax=axs[i // 6, i % 6]\n    )\n    axs[i // 6, i % 6].set_title(adata_prot_subsampled.var_names[i])\n    axs[i // 6, i % 6].set_xlabel(None)\n    axs[i // 6, i % 6].set_ylabel(None)\n    # axs[i//6, i%6].set_xticks([])",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "layer",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "layer = \"z_normalized\"\nfor i in range(30):\n    sns.kdeplot(\n        adata_prot_subsampled.to_df(layer=layer).iloc[:, i], legend=False, ax=axs[i // 6, i % 6]\n    )\n    axs[i // 6, i % 6].set_title(adata_prot_subsampled.var_names[i])\n    axs[i // 6, i % 6].set_xlabel(None)\n    axs[i // 6, i % 6].set_ylabel(None)\n    # axs[i//6, i%6].set_xticks([])\n    axs[i // 6, i % 6].set_yticks([])",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "adata_prot_subsampled",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_schreiber",
        "description": "ARCADIA.scripts._0_preprocess_schreiber",
        "peekOfCode": "adata_prot_subsampled = sc.pp.subsample(adata_prot, n_obs=1000, copy=True)\nfor i in range(30):\n    sns.kdeplot(adata_prot_subsampled.to_df().iloc[:, i], legend=False, ax=axs[i // 6, i % 6])\n    axs[i // 6, i % 6].set_title(adata_prot_subsampled.var_names[i])\n    axs[i // 6, i % 6].set_xlabel(None)\n    axs[i // 6, i % 6].set_ylabel(None)\n    # axs[i//6, i%6].set_xticks([])\n    axs[i // 6, i % 6].set_yticks([])\n# # take a subsample of the data\n# adata_prot_subsampled = adata_prot_normalized[",
        "detail": "ARCADIA.scripts._0_preprocess_schreiber",
        "documentation": {}
    },
    {
        "label": "here",
        "kind": 2,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "def here():\n    try:\n        return Path(__file__).resolve().parent\n    except NameError:\n        return Path.cwd()\n# Determine ROOT based on whether we're running as script or notebook\ntry:\n    # Running as script - use __file__ to find root\n    _script_dir = Path(__file__).resolve().parent\n    ROOT = _script_dir.parent  # scripts/ -> root",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "THIS_DIR = here()\n# Add src to path for arcadia package\nif str(ROOT / \"src\") not in sys.path:\n    sys.path.insert(0, str(ROOT / \"src\"))\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nos.chdir(str(ROOT))\nimport matplotlib as mpl\nimport numpy as np",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "config_path = Path(\"configs/config.json\")\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "FILENAME = \"_0_preprocess_tonsil.py\"\ndataset_name = \"tonsil\"\nstart_time = datetime.now()\ntimestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\")\n# %% --- Directory Structure Definition ---\n# Base path relative to the project root\nbase_path = \"raw_datasets\"\n# Core directories to be created under the base path\n# Sub-directories are handled automatically by os.makedirs",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "dataset_name = \"tonsil\"\nstart_time = datetime.now()\ntimestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\")\n# %% --- Directory Structure Definition ---\n# Base path relative to the project root\nbase_path = \"raw_datasets\"\n# Core directories to be created under the base path\n# Sub-directories are handled automatically by os.makedirs\ndirectories = [",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "start_time",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "start_time = datetime.now()\ntimestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\")\n# %% --- Directory Structure Definition ---\n# Base path relative to the project root\nbase_path = \"raw_datasets\"\n# Core directories to be created under the base path\n# Sub-directories are handled automatically by os.makedirs\ndirectories = [\n    \"checkpoints\",",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "timestamp_str",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "timestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\")\n# %% --- Directory Structure Definition ---\n# Base path relative to the project root\nbase_path = \"raw_datasets\"\n# Core directories to be created under the base path\n# Sub-directories are handled automatically by os.makedirs\ndirectories = [\n    \"checkpoints\",\n    \"processed_data\",",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "base_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "base_path = \"raw_datasets\"\n# Core directories to be created under the base path\n# Sub-directories are handled automatically by os.makedirs\ndirectories = [\n    \"checkpoints\",\n    \"processed_data\",\n    \"raw_data/tonsil\",\n    \"trained_data\",\n]\nprint(f\"Creating directory structure under: {os.path.abspath(base_path)}\")",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "directories",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "directories = [\n    \"checkpoints\",\n    \"processed_data\",\n    \"raw_data/tonsil\",\n    \"trained_data\",\n]\nprint(f\"Creating directory structure under: {os.path.abspath(base_path)}\")\nfor rel_path in directories:\n    full_path = os.path.join(base_path, rel_path)\n    os.makedirs(full_path, exist_ok=True)",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "data_dir",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "data_dir = Path(\"raw_datasets\")\ndata_dir.mkdir(parents=True, exist_ok=True)\n# Download and load data\ndownload_tonsil_data(data_dir)\nadata_rna = load_tonsil_rna(data_dir)\nadata_prot = load_tonsil_protein(data_dir)\nprint(f\"Loaded RNA data: {adata_rna.shape}\")\nprint(f\"Loaded protein data: {adata_prot.shape}\")\n# Initialize pipeline metadata with start time\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna = load_tonsil_rna(data_dir)\nadata_prot = load_tonsil_protein(data_dir)\nprint(f\"Loaded RNA data: {adata_rna.shape}\")\nprint(f\"Loaded protein data: {adata_prot.shape}\")\n# Initialize pipeline metadata with start time\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\n# %% Convert to CSR if needed\nif sp.isspmatrix_coo(adata_rna.X):",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot = load_tonsil_protein(data_dir)\nprint(f\"Loaded RNA data: {adata_rna.shape}\")\nprint(f\"Loaded protein data: {adata_prot.shape}\")\n# Initialize pipeline metadata with start time\nadata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\n# %% Convert to CSR if needed\nif sp.isspmatrix_coo(adata_rna.X):\n    adata_rna.X = adata_rna.X.tocsr()",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"] = pipeline_metadata_utils.initialize_pipeline_metadata(\n    timestamp_str, FILENAME, dataset_name\n)\n# %% Convert to CSR if needed\nif sp.isspmatrix_coo(adata_rna.X):\n    adata_rna.X = adata_rna.X.tocsr()\n    print(\"Converted to CSR\")\n# Add layers for raw data and counts (needed for downstream processing)\nadata_rna.layers[\"raw\"] = adata_rna.X.copy()\nadata_prot.layers[\"raw\"] = adata_prot.X.copy()",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.layers[\"raw\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.layers[\"raw\"] = adata_rna.X.copy()\nadata_prot.layers[\"raw\"] = adata_prot.X.copy()\n# Add counts layer (essential for downstream pipeline compatibility)\nadata_rna.layers[\"counts\"] = adata_rna.X.copy()\nadata_prot.layers[\"counts\"] = adata_prot.X.copy()\nprint(\"Added 'counts' layers for both RNA and protein datasets\")\n# Check sparsity\ntotal_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nzero_elements = total_elements - adata_rna.X.nnz\nprint(f\"Number of zero elements proportion in RNA dataset: {zero_elements/total_elements}\")",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.layers[\"raw\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot.layers[\"raw\"] = adata_prot.X.copy()\n# Add counts layer (essential for downstream pipeline compatibility)\nadata_rna.layers[\"counts\"] = adata_rna.X.copy()\nadata_prot.layers[\"counts\"] = adata_prot.X.copy()\nprint(\"Added 'counts' layers for both RNA and protein datasets\")\n# Check sparsity\ntotal_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nzero_elements = total_elements - adata_rna.X.nnz\nprint(f\"Number of zero elements proportion in RNA dataset: {zero_elements/total_elements}\")\n# Verify data is count data",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.layers[\"counts\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.layers[\"counts\"] = adata_rna.X.copy()\nadata_prot.layers[\"counts\"] = adata_prot.X.copy()\nprint(\"Added 'counts' layers for both RNA and protein datasets\")\n# Check sparsity\ntotal_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nzero_elements = total_elements - adata_rna.X.nnz\nprint(f\"Number of zero elements proportion in RNA dataset: {zero_elements/total_elements}\")\n# Verify data is count data\nif issparse(adata_rna.X):\n    assert np.allclose(adata_rna.X.data, np.round(adata_rna.X.data))",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.layers[\"counts\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot.layers[\"counts\"] = adata_prot.X.copy()\nprint(\"Added 'counts' layers for both RNA and protein datasets\")\n# Check sparsity\ntotal_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nzero_elements = total_elements - adata_rna.X.nnz\nprint(f\"Number of zero elements proportion in RNA dataset: {zero_elements/total_elements}\")\n# Verify data is count data\nif issparse(adata_rna.X):\n    assert np.allclose(adata_rna.X.data, np.round(adata_rna.X.data))\nelse:",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "total_elements",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "total_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\nzero_elements = total_elements - adata_rna.X.nnz\nprint(f\"Number of zero elements proportion in RNA dataset: {zero_elements/total_elements}\")\n# Verify data is count data\nif issparse(adata_rna.X):\n    assert np.allclose(adata_rna.X.data, np.round(adata_rna.X.data))\nelse:\n    assert np.allclose(adata_rna.X, np.round(adata_rna.X))\n# %% --- Initial Analysis and Plots ---\npp_plots.plot_count_distribution(adata_rna, plot_flag)",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "zero_elements",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "zero_elements = total_elements - adata_rna.X.nnz\nprint(f\"Number of zero elements proportion in RNA dataset: {zero_elements/total_elements}\")\n# Verify data is count data\nif issparse(adata_rna.X):\n    assert np.allclose(adata_rna.X.data, np.round(adata_rna.X.data))\nelse:\n    assert np.allclose(adata_rna.X, np.round(adata_rna.X))\n# %% --- Initial Analysis and Plots ---\npp_plots.plot_count_distribution(adata_rna, plot_flag)\npp_plots.plot_expression_heatmap(adata_rna, plot_flag)",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna = filter_unwanted_cell_types(adata_rna, [\"tumor\", \"dead\", \"nk cells\"])\nprint(\"Protein dataset:\")\nadata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\", \"nk cells\"])\n# Get common cell types\ncommon_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types: {sorted(common_cell_types)}\")\n# Filter to common cell types\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(common_cell_types)].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot = filter_unwanted_cell_types(adata_prot, [\"tumor\", \"dead\", \"nk cells\"])\n# Get common cell types\ncommon_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types: {sorted(common_cell_types)}\")\n# Filter to common cell types\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(common_cell_types)].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")\nprint(f\"RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Protein dataset shape: {adata_prot.shape}\")",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "common_cell_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "common_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types: {sorted(common_cell_types)}\")\n# Filter to common cell types\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(common_cell_types)].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")\nprint(f\"RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Protein dataset shape: {adata_prot.shape}\")\n# %% --- Apply Schreiber-style Initial Preprocessing ---\nprint(\"\\n=== Applying initial preprocessing (Schreiber methodology) ===\")",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna = adata_rna[adata_rna.obs[\"cell_types\"].isin(common_cell_types)].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")\nprint(f\"RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Protein dataset shape: {adata_prot.shape}\")\n# %% --- Apply Schreiber-style Initial Preprocessing ---\nprint(\"\\n=== Applying initial preprocessing (Schreiber methodology) ===\")\nadata_rna_processed = preprocess_rna_initial_steps(\n    adata_rna.copy(),\n    min_genes=200,",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot = adata_prot[adata_prot.obs[\"cell_types\"].isin(common_cell_types)].copy()\nprint(f\"After filtering to common cell types:\")\nprint(f\"RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Protein dataset shape: {adata_prot.shape}\")\n# %% --- Apply Schreiber-style Initial Preprocessing ---\nprint(\"\\n=== Applying initial preprocessing (Schreiber methodology) ===\")\nadata_rna_processed = preprocess_rna_initial_steps(\n    adata_rna.copy(),\n    min_genes=200,\n    min_cells=3,",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna_processed",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna_processed = preprocess_rna_initial_steps(\n    adata_rna.copy(),\n    min_genes=200,\n    min_cells=3,\n    plot_flag=plot_flag,\n)\nprint(f\"Processed RNA dataset shape: {adata_rna_processed.shape}\")\nprint(f\"Cell type distribution in processed RNA dataset:\")\nprint(adata_rna_processed.obs[\"cell_types\"].value_counts())\n# Update main RNA dataset",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna = adata_rna_processed\n# Plot highly variable genes (MaxFuse-style)\nif plot_flag:\n    sc.pl.highly_variable_genes(adata_rna)\n# %% --- Apply Custom Setup for MaxFuse Dataset ---\nprint(f\"\\n=== Applying custom setup for MaxFuse dataset ===\")\nprint(f\"RNA cell types: {sorted(set(adata_rna.obs['cell_types']))}\")\nprint(f\"Protein cell types: {sorted(set(adata_prot.obs['cell_types']))}\")\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"day_of_collection\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"patient_id\"] = None",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"day_of_collection\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"day_of_collection\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"patient_id\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/tonsil/tonsil_rna_counts.txt\",\n    \"protein\": \"raw_datasets/tonsil/tonsil_codex.csv\",\n    \"metadata\": \"raw_datasets/tonsil/tonsil_rna_meta.csv\",\n}\nadata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"patient_id\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"patient_id\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/tonsil/tonsil_rna_counts.txt\",\n    \"protein\": \"raw_datasets/tonsil/tonsil_codex.csv\",\n    \"metadata\": \"raw_datasets/tonsil/tonsil_rna_meta.csv\",\n}\nadata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].argsort(), :].copy()",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"zib_threshold\"] = None\nadata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/tonsil/tonsil_rna_counts.txt\",\n    \"protein\": \"raw_datasets/tonsil/tonsil_codex.csv\",\n    \"metadata\": \"raw_datasets/tonsil/tonsil_rna_meta.csv\",\n}\nadata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].argsort(), :].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].argsort(), :].copy()",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"preprocess\"][\"source_files\"] = {\n    \"rna\": \"raw_datasets/tonsil/tonsil_rna_counts.txt\",\n    \"protein\": \"raw_datasets/tonsil/tonsil_codex.csv\",\n    \"metadata\": \"raw_datasets/tonsil/tonsil_rna_meta.csv\",\n}\nadata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].argsort(), :].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].argsort(), :].copy()\n# Remove redundant gene columns if they exist",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"pipeline_metadata\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot.uns[\"pipeline_metadata\"] = adata_rna.uns[\"pipeline_metadata\"].copy()\n# Sort by cell types (standard preprocessing step)\nadata_rna = adata_rna[adata_rna.obs[\"cell_types\"].argsort(), :].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].argsort(), :].copy()\n# Remove redundant gene columns if they exist\nif \"gene\" in adata_rna.var.columns and np.array_equal(\n    adata_rna.var[\"gene\"].values, (adata_rna.var.index.values)\n):\n    adata_rna.var.drop(columns=\"gene\", inplace=True)\nif \"gene\" in adata_prot.var.columns and np.array_equal(",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna = adata_rna[adata_rna.obs[\"cell_types\"].argsort(), :].copy()\nadata_prot = adata_prot[adata_prot.obs[\"cell_types\"].argsort(), :].copy()\n# Remove redundant gene columns if they exist\nif \"gene\" in adata_rna.var.columns and np.array_equal(\n    adata_rna.var[\"gene\"].values, (adata_rna.var.index.values)\n):\n    adata_rna.var.drop(columns=\"gene\", inplace=True)\nif \"gene\" in adata_prot.var.columns and np.array_equal(\n    adata_prot.var[\"gene\"].values, (adata_prot.var.index.values)\n):",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot = adata_prot[adata_prot.obs[\"cell_types\"].argsort(), :].copy()\n# Remove redundant gene columns if they exist\nif \"gene\" in adata_rna.var.columns and np.array_equal(\n    adata_rna.var[\"gene\"].values, (adata_rna.var.index.values)\n):\n    adata_rna.var.drop(columns=\"gene\", inplace=True)\nif \"gene\" in adata_prot.var.columns and np.array_equal(\n    adata_prot.var[\"gene\"].values, (adata_prot.var.index.values)\n):\n    adata_prot.var.drop(columns=\"gene\", inplace=True)",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot = mad_outlier_removal(adata_prot).copy()\nadata_rna.obs[\"major_cell_types\"] = adata_rna.obs[\"cell_types\"]\nadata_prot.obs[\"major_cell_types\"] = adata_prot.obs[\"cell_types\"]\n# %% --- Protein Analysis Following Schreiber Methodology ---\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag)\n# Take subsample for spatial analysis\nadata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(6000, adata_prot.n_obs), replace=False)\n].copy()\n# Apply spatial analysis (following Schreiber methodology, not MaxFuse)",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.obs[\"major_cell_types\"] = adata_rna.obs[\"cell_types\"]\nadata_prot.obs[\"major_cell_types\"] = adata_prot.obs[\"cell_types\"]\n# %% --- Protein Analysis Following Schreiber Methodology ---\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag)\n# Take subsample for spatial analysis\nadata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(6000, adata_prot.n_obs), replace=False)\n].copy()\n# Apply spatial analysis (following Schreiber methodology, not MaxFuse)\nsc.pp.pca(adata_prot_subsampled, copy=False)",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot.obs[\"major_cell_types\"] = adata_prot.obs[\"cell_types\"]\n# %% --- Protein Analysis Following Schreiber Methodology ---\npp_plots.plot_protein_analysis(adata_prot, plot_flag=plot_flag)\n# Take subsample for spatial analysis\nadata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(6000, adata_prot.n_obs), replace=False)\n].copy()\n# Apply spatial analysis (following Schreiber methodology, not MaxFuse)\nsc.pp.pca(adata_prot_subsampled, copy=False)\nsc.pp.neighbors(adata_prot_subsampled, use_rep=\"X_pca\")",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot_subsampled",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot_subsampled = adata_prot[\n    np.random.choice(adata_prot.n_obs, size=min(6000, adata_prot.n_obs), replace=False)\n].copy()\n# Apply spatial analysis (following Schreiber methodology, not MaxFuse)\nsc.pp.pca(adata_prot_subsampled, copy=False)\nsc.pp.neighbors(adata_prot_subsampled, use_rep=\"X_pca\")\nsc.tl.umap(adata_prot_subsampled)\npp_plots.plot_umap_analysis(adata_prot_subsampled, \"cell_types\", \"Cell Types\", plot_flag)\n# %% --- Finalize Pipeline Metadata ---\n# Create sample names for metadata (tonsil doesn't have multiple samples)",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "sample_names",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "sample_names = [\"tonsil_sample\"]\npipeline_metadata_utils.finalize_preprocess_metadata(adata_rna, adata_prot, sample_names)\n# %% --- Apply Final Normalization and Create Layers ---\nprint(\"\\n=== Applying final normalization and creating layers ===\")\n# RNA: normalize_total + log1p, save both versions\nprint(\"RNA normalization:\")\nprint(f\"  Before normalization - X range: [{adata_rna.X.min():.2f}, {adata_rna.X.max():.2f}]\")\n# Ensure we have raw counts in layers[\"counts\"] (should already exist from line 288)\nif \"counts\" not in adata_rna.layers:\n    adata_rna.layers[\"counts\"] = adata_rna.X.copy()",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.layers[\"normalized\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.layers[\"normalized\"] = adata_rna.X.copy()\n# Apply log1p transformation\nsc.pp.log1p(adata_rna)\nprint(f\"  After log1p - X range: [{adata_rna.X.min():.2f}, {adata_rna.X.max():.2f}]\")\n# Save log1p data to layer (backup)\nadata_rna.layers[\"log1p\"] = adata_rna.X.copy()\nprint(\"  Kept log1p(normalized) data in X for VAE training\")\n# Update metadata\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"normalize_total\",",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.layers[\"log1p\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.layers[\"log1p\"] = adata_rna.X.copy()\nprint(\"  Kept log1p(normalized) data in X for VAE training\")\n# Update metadata\nadata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"normalize_total\",\n    \"target_sum\": 40000,\n    \"applied\": True,\n    \"log1p_applied\": True,\n    \"layers_info\": {\n        \"counts\": \"raw counts (backup only)\",",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pipeline_metadata\"][\"normalization\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"normalize_total\",\n    \"target_sum\": 40000,\n    \"applied\": True,\n    \"log1p_applied\": True,\n    \"layers_info\": {\n        \"counts\": \"raw counts (backup only)\",\n        \"normalized\": \"normalized counts (target_sum=40000, backup only)\",\n        \"log1p\": \"log1p(normalized counts) - in X for VAE\",\n    },",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot = z_normalize_codex(adata_prot.copy(), apply_log1p=False)\nprint(f\"  After z-normalization - X range: [{adata_prot.X.min():.2f}, {adata_prot.X.max():.2f}]\")\n# Keep z-normalized data in X for VAE training (this is what VAE needs)\n# Save backup to layer as well\nadata_prot.layers[\"z_normalized\"] = adata_prot.X.copy()\nprint(\"  Kept z-normalized data in X for VAE training (protein VAE trains on normalized data)\")\n# Update metadata\nadata_prot.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"z_normalize\",\n    \"applied\": True,",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.layers[\"z_normalized\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot.layers[\"z_normalized\"] = adata_prot.X.copy()\nprint(\"  Kept z-normalized data in X for VAE training (protein VAE trains on normalized data)\")\n# Update metadata\nadata_prot.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"z_normalize\",\n    \"applied\": True,\n    \"log1p_applied\": False,\n    \"layers_info\": {\n        \"counts\": \"raw counts (backup only)\",\n        \"z_normalized\": \"z-normalized protein expression (no log1p) - in X for VAE\",",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"pipeline_metadata\"][\"normalization\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot.uns[\"pipeline_metadata\"][\"normalization\"] = {\n    \"method\": \"z_normalize\",\n    \"applied\": True,\n    \"log1p_applied\": False,\n    \"layers_info\": {\n        \"counts\": \"raw counts (backup only)\",\n        \"z_normalized\": \"z-normalized protein expression (no log1p) - in X for VAE\",\n    },\n    \"note\": \"Protein X contains z-normalized data for VAE training\",\n}",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_rna.uns[\"dataset_name\"] = dataset_name\nadata_prot.uns[\"dataset_name\"] = dataset_name\nsave_processed_data(adata_rna, adata_prot, \"processed_data\", caller_filename=FILENAME)\nprint(\" MaxFuse dataset preprocessing completed successfully using Schreiber methodology!\")\nprint(f\"Final RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Final protein dataset shape: {adata_prot.shape}\")\nprint(f\"Common cell types: {sorted(set(adata_rna.obs['cell_types']))}\")\nprint(f\"Output saved to: processed_data/\")\n# %% --- Final Preprocessing Results Plots (MaxFuse-style) ---\nif plot_flag:",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._0_preprocess_tonsil",
        "description": "ARCADIA.scripts._0_preprocess_tonsil",
        "peekOfCode": "adata_prot.uns[\"dataset_name\"] = dataset_name\nsave_processed_data(adata_rna, adata_prot, \"processed_data\", caller_filename=FILENAME)\nprint(\" MaxFuse dataset preprocessing completed successfully using Schreiber methodology!\")\nprint(f\"Final RNA dataset shape: {adata_rna.shape}\")\nprint(f\"Final protein dataset shape: {adata_prot.shape}\")\nprint(f\"Common cell types: {sorted(set(adata_rna.obs['cell_types']))}\")\nprint(f\"Output saved to: processed_data/\")\n# %% --- Final Preprocessing Results Plots (MaxFuse-style) ---\nif plot_flag:\n    print(\"Generating final preprocessing results plots...\")",
        "detail": "ARCADIA.scripts._0_preprocess_tonsil",
        "documentation": {}
    },
    {
        "label": "verify_adata_validity",
        "kind": 2,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "def verify_adata_validity(adata_rna, adata_prot):\n    if \"cell_types\" not in adata_rna.obs:\n        raise ValueError(\"adata_rna does not have 'cell_types' in obs\")\n    if \"cell_types\" not in adata_prot.obs:\n        raise ValueError(\"adata_prot does not have 'cell_types' in obs\")\n    if \"batch\" not in adata_rna.obs:\n        raise ValueError(\"adata_rna does not have 'batch' in obs\")\n    if \"batch\" not in adata_prot.obs:\n        raise ValueError(\"adata_prot does not have 'batch' in obs\")\n    if \"spatial\" not in adata_prot.obsm:",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "FILENAME = \"_1_align_datasets.py\"\n# %% tags=[\"parameters\"]\n# Default parameters - can be overridden by papermill\ndataset_name = None\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\nfrom arcadia.utils.paths import here\nif here().parent.name == \"notebooks\":\n    os.chdir(\"../../\")",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "dataset_name = None\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\nfrom arcadia.utils.paths import here\nif here().parent.name == \"notebooks\":\n    os.chdir(\"../../\")\n# ROOT is already defined above (handles both script and notebook execution)\nos.chdir(str(ROOT))\nfrom arcadia.data_utils import (",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "config_path = Path(\"configs/config.json\")\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "X_data",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "X_data = adata_rna.X.toarray() if issparse(adata_rna.X) else adata_rna.X\nlog1p_data = (\n    adata_rna.layers[\"log1p\"].toarray()\n    if issparse(adata_rna.layers[\"log1p\"])\n    else adata_rna.layers[\"log1p\"]\n)\n# Protein: X should contain z_normalized data\nprint(\"\\nProtein verification:\")\nprint(f\"  Protein layers available: {list(adata_prot.layers.keys())}\")\n# Verify X contains z-normalized data",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "log1p_data",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "log1p_data = (\n    adata_rna.layers[\"log1p\"].toarray()\n    if issparse(adata_rna.layers[\"log1p\"])\n    else adata_rna.layers[\"log1p\"]\n)\n# Protein: X should contain z_normalized data\nprint(\"\\nProtein verification:\")\nprint(f\"  Protein layers available: {list(adata_prot.layers.keys())}\")\n# Verify X contains z-normalized data\nif \"z_normalized\" in adata_prot.layers:",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "non_constant_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "non_constant_mask = (gene_max - gene_min) != 0  # False  constant\nnon_constant_mask = np.asarray(non_constant_mask, dtype=bool)\nadata_rna = adata_rna[:, non_constant_mask].copy()\nsc.pp.pca(adata_rna, copy=False)\nbatch_key = \"batch\" if \"batch\" in adata_rna.obs else None\n# check for nan and inf in the adata_rna.X\nif issparse(adata_rna.X):\n    has_nan = np.isnan(adata_rna.X.data).any() if adata_rna.X.data.size > 0 else False\n    has_inf = np.isinf(adata_rna.X.data).any() if adata_rna.X.data.size > 0 else False\nelse:",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "non_constant_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "non_constant_mask = np.asarray(non_constant_mask, dtype=bool)\nadata_rna = adata_rna[:, non_constant_mask].copy()\nsc.pp.pca(adata_rna, copy=False)\nbatch_key = \"batch\" if \"batch\" in adata_rna.obs else None\n# check for nan and inf in the adata_rna.X\nif issparse(adata_rna.X):\n    has_nan = np.isnan(adata_rna.X.data).any() if adata_rna.X.data.size > 0 else False\n    has_inf = np.isinf(adata_rna.X.data).any() if adata_rna.X.data.size > 0 else False\nelse:\n    has_nan = np.isnan(adata_rna.X).any()",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna = adata_rna[:, non_constant_mask].copy()\nsc.pp.pca(adata_rna, copy=False)\nbatch_key = \"batch\" if \"batch\" in adata_rna.obs else None\n# check for nan and inf in the adata_rna.X\nif issparse(adata_rna.X):\n    has_nan = np.isnan(adata_rna.X.data).any() if adata_rna.X.data.size > 0 else False\n    has_inf = np.isinf(adata_rna.X.data).any() if adata_rna.X.data.size > 0 else False\nelse:\n    has_nan = np.isnan(adata_rna.X).any()\n    has_inf = np.isinf(adata_rna.X).any()",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "batch_key",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "batch_key = \"batch\" if \"batch\" in adata_rna.obs else None\n# check for nan and inf in the adata_rna.X\nif issparse(adata_rna.X):\n    has_nan = np.isnan(adata_rna.X.data).any() if adata_rna.X.data.size > 0 else False\n    has_inf = np.isinf(adata_rna.X.data).any() if adata_rna.X.data.size > 0 else False\nelse:\n    has_nan = np.isnan(adata_rna.X).any()\n    has_inf = np.isinf(adata_rna.X).any()\nprint(f\"Any nan in adata_rna.X: {has_nan}\")\nprint(f\"Any inf in adata_rna.X: {has_inf}\")",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "genes_to_keep",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "genes_to_keep = None\nfor batch in adata_rna.obs[\"batch\"].unique():\n    subset_mask = adata_rna.obs[\"batch\"] == batch\n    batch_subset = adata_rna[subset_mask]\n    # Skip batches with < 2 cells (can't compute variance)\n    if batch_subset.n_obs < 2:\n        print(\n            f\"  Skipping batch {batch}: only {batch_subset.n_obs} cell(s), cannot compute variance\"\n        )\n        continue",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna = adata_rna[:, genes_to_keep].copy()\n# HVG selection: Seurat v3 method needs raw counts, not log1p\n# Temporarily use counts layer for HVG selection\nprint(\"Running HVG selection on raw counts (Seurat v3 method requires counts)\")\nadata_rna_for_hvg = adata_rna.copy()\nif \"counts\" in adata_rna_for_hvg.layers:\n    adata_rna_for_hvg.X = adata_rna_for_hvg.layers[\"counts\"].copy()\n    print(\"  Using raw counts from layers['counts'] for HVG selection\")\nelse:\n    print(\"  WARNING: No counts layer found, using X as-is\")",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna_for_hvg",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna_for_hvg = adata_rna.copy()\nif \"counts\" in adata_rna_for_hvg.layers:\n    adata_rna_for_hvg.X = adata_rna_for_hvg.layers[\"counts\"].copy()\n    print(\"  Using raw counts from layers['counts'] for HVG selection\")\nelse:\n    print(\"  WARNING: No counts layer found, using X as-is\")\nsc.pp.highly_variable_genes(\n    adata_rna_for_hvg, n_top_genes=2000, batch_key=\"batch\", flavor=\"seurat_v3\"\n)\n# Copy HVG results back to main adata",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna.var[\"highly_variable\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna.var[\"highly_variable\"] = adata_rna_for_hvg.var[\"highly_variable\"]\nadata_rna.var[\"highly_variable_rank\"] = adata_rna_for_hvg.var.get(\"highly_variable_rank\", 0)\nadata_rna.var[\"means\"] = adata_rna_for_hvg.var.get(\"means\", 0)\nadata_rna.var[\"variances\"] = adata_rna_for_hvg.var.get(\"variances\", 0)\nadata_rna.var[\"variances_norm\"] = adata_rna_for_hvg.var.get(\"variances_norm\", 0)\nprint(f\"  Selected {adata_rna.var['highly_variable'].sum()} highly variable genes\")\ndel adata_rna_for_hvg\nvariances_sorted = np.sort(adata_rna.var[\"variances\"])[::-1]\npp_plots.plot_gene_variance_elbow(variances_sorted, plot_flag)\nkneedle = KneeLocator(",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna.var[\"highly_variable_rank\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna.var[\"highly_variable_rank\"] = adata_rna_for_hvg.var.get(\"highly_variable_rank\", 0)\nadata_rna.var[\"means\"] = adata_rna_for_hvg.var.get(\"means\", 0)\nadata_rna.var[\"variances\"] = adata_rna_for_hvg.var.get(\"variances\", 0)\nadata_rna.var[\"variances_norm\"] = adata_rna_for_hvg.var.get(\"variances_norm\", 0)\nprint(f\"  Selected {adata_rna.var['highly_variable'].sum()} highly variable genes\")\ndel adata_rna_for_hvg\nvariances_sorted = np.sort(adata_rna.var[\"variances\"])[::-1]\npp_plots.plot_gene_variance_elbow(variances_sorted, plot_flag)\nkneedle = KneeLocator(\n    range(1, len(variances_sorted) + 1),",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna.var[\"means\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna.var[\"means\"] = adata_rna_for_hvg.var.get(\"means\", 0)\nadata_rna.var[\"variances\"] = adata_rna_for_hvg.var.get(\"variances\", 0)\nadata_rna.var[\"variances_norm\"] = adata_rna_for_hvg.var.get(\"variances_norm\", 0)\nprint(f\"  Selected {adata_rna.var['highly_variable'].sum()} highly variable genes\")\ndel adata_rna_for_hvg\nvariances_sorted = np.sort(adata_rna.var[\"variances\"])[::-1]\npp_plots.plot_gene_variance_elbow(variances_sorted, plot_flag)\nkneedle = KneeLocator(\n    range(1, len(variances_sorted) + 1),\n    np.log(variances_sorted),",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna.var[\"variances\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna.var[\"variances\"] = adata_rna_for_hvg.var.get(\"variances\", 0)\nadata_rna.var[\"variances_norm\"] = adata_rna_for_hvg.var.get(\"variances_norm\", 0)\nprint(f\"  Selected {adata_rna.var['highly_variable'].sum()} highly variable genes\")\ndel adata_rna_for_hvg\nvariances_sorted = np.sort(adata_rna.var[\"variances\"])[::-1]\npp_plots.plot_gene_variance_elbow(variances_sorted, plot_flag)\nkneedle = KneeLocator(\n    range(1, len(variances_sorted) + 1),\n    np.log(variances_sorted),\n    S=20.0,",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna.var[\"variances_norm\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna.var[\"variances_norm\"] = adata_rna_for_hvg.var.get(\"variances_norm\", 0)\nprint(f\"  Selected {adata_rna.var['highly_variable'].sum()} highly variable genes\")\ndel adata_rna_for_hvg\nvariances_sorted = np.sort(adata_rna.var[\"variances\"])[::-1]\npp_plots.plot_gene_variance_elbow(variances_sorted, plot_flag)\nkneedle = KneeLocator(\n    range(1, len(variances_sorted) + 1),\n    np.log(variances_sorted),\n    S=20.0,\n    curve=\"convex\",",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "variances_sorted",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "variances_sorted = np.sort(adata_rna.var[\"variances\"])[::-1]\npp_plots.plot_gene_variance_elbow(variances_sorted, plot_flag)\nkneedle = KneeLocator(\n    range(1, len(variances_sorted) + 1),\n    np.log(variances_sorted),\n    S=20.0,\n    curve=\"convex\",\n    direction=\"decreasing\",\n)\npp_plots.plot_kneedle_analysis(kneedle, plot_flag)",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "kneedle",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "kneedle = KneeLocator(\n    range(1, len(variances_sorted) + 1),\n    np.log(variances_sorted),\n    S=20.0,\n    curve=\"convex\",\n    direction=\"decreasing\",\n)\npp_plots.plot_kneedle_analysis(kneedle, plot_flag)\n# %%\nadata_rna_processing = adata_rna.copy()",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna_processing",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna_processing = adata_rna.copy()\nadata_prot_processing = adata_prot.copy()\npp_plots.plot_variance_analysis_processed(adata_rna, plot_flag)\nadata_rna = adata_rna.copy()\n# rename seurat colns to scanpy\nrename_map = {\n    \"nCount_RNA\": \"total_counts\",\n    \"nFeature_RNA\": \"n_genes_by_counts\",  # if the fn ever expects this\n}\nfor old, new in rename_map.items():",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_prot_processing",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_prot_processing = adata_prot.copy()\npp_plots.plot_variance_analysis_processed(adata_rna, plot_flag)\nadata_rna = adata_rna.copy()\n# rename seurat colns to scanpy\nrename_map = {\n    \"nCount_RNA\": \"total_counts\",\n    \"nFeature_RNA\": \"n_genes_by_counts\",  # if the fn ever expects this\n}\nfor old, new in rename_map.items():\n    if new not in adata_rna.obs and old in adata_rna.obs:",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna = adata_rna.copy()\n# rename seurat colns to scanpy\nrename_map = {\n    \"nCount_RNA\": \"total_counts\",\n    \"nFeature_RNA\": \"n_genes_by_counts\",  # if the fn ever expects this\n}\nfor old, new in rename_map.items():\n    if new not in adata_rna.obs and old in adata_rna.obs:\n        adata_rna.obs[new] = adata_rna.obs[old]\nsc.pp.pca(adata_rna, copy=False)",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "rename_map",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "rename_map = {\n    \"nCount_RNA\": \"total_counts\",\n    \"nFeature_RNA\": \"n_genes_by_counts\",  # if the fn ever expects this\n}\nfor old, new in rename_map.items():\n    if new not in adata_rna.obs and old in adata_rna.obs:\n        adata_rna.obs[new] = adata_rna.obs[old]\nsc.pp.pca(adata_rna, copy=False)\nprint(f'variance explained by first 10 PCs {adata_rna.uns[\"pca\"][\"variance_ratio\"][:10].sum()}')\n# %% Debug/Logging",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna_copy",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna_copy = adata_rna.copy()  #  todo remove this\nprint(f\"DEBUG: Original data shape: {adata_rna.shape}\")\nprint(f\"DEBUG: Original X mean: {adata_rna.X.mean():.4f}\")\nprint(f\"DEBUG: Dataset source distribution: {adata_rna.obs['batch'].value_counts().to_dict()}\")\n# Check batch separation BEFORE correction\nif issparse(adata_rna.X):\n    X_dense = adata_rna.X.toarray()\nelse:\n    X_dense = adata_rna.X\nbatch_labels = adata_rna.obs[\"batch\"].unique()",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "batch_labels",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "batch_labels = adata_rna.obs[\"batch\"].unique()\nbatch_means = {b: X_dense[adata_rna.obs[\"batch\"] == b].mean(axis=0) for b in batch_labels}\nbatch_distance_before = np.mean(\n    [np.linalg.norm(batch_means[b1] - batch_means[b2]) for b1, b2 in combinations(batch_labels, 2)]\n)\nprint(f\"DEBUG: Batch separation BEFORE correction: {batch_distance_before:.4f}\")\n# %% Run preprocessing with batch correction\n# Compute zero proportion without creating full dense mask to save memory\nif sp.issparse(adata_rna.X):\n    total_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "batch_means",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "batch_means = {b: X_dense[adata_rna.obs[\"batch\"] == b].mean(axis=0) for b in batch_labels}\nbatch_distance_before = np.mean(\n    [np.linalg.norm(batch_means[b1] - batch_means[b2]) for b1, b2 in combinations(batch_labels, 2)]\n)\nprint(f\"DEBUG: Batch separation BEFORE correction: {batch_distance_before:.4f}\")\n# %% Run preprocessing with batch correction\n# Compute zero proportion without creating full dense mask to save memory\nif sp.issparse(adata_rna.X):\n    total_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\n    zero_proportion = (total_elements - adata_rna.X.nnz) / total_elements",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "batch_distance_before",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "batch_distance_before = np.mean(\n    [np.linalg.norm(batch_means[b1] - batch_means[b2]) for b1, b2 in combinations(batch_labels, 2)]\n)\nprint(f\"DEBUG: Batch separation BEFORE correction: {batch_distance_before:.4f}\")\n# %% Run preprocessing with batch correction\n# Compute zero proportion without creating full dense mask to save memory\nif sp.issparse(adata_rna.X):\n    total_elements = adata_rna.X.shape[0] * adata_rna.X.shape[1]\n    zero_proportion = (total_elements - adata_rna.X.nnz) / total_elements\nelse:",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna_processed",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna_processed = preprocess_rna_final_steps(\n    adata_rna.copy(),\n    n_top_genes=min(2000, kneedle.knee),\n    plot_flag=plot_flag,\n    gene_likelihood_dist=\"zinb\",\n)\nprint(f\"DEBUG: After preprocessing - shape: {adata_rna_processed.shape}\")\n# Handle mean/std for sparse matrices\nif issparse(adata_rna_processed.X):\n    X_mean = float(adata_rna_processed.X.mean())",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "batch_distance_after",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "batch_distance_after = np.mean(\n    [np.linalg.norm(batch_means[b1] - batch_means[b2]) for b1, b2 in combinations(batch_labels, 2)]\n)\nprint(f\"DEBUG: Batch separation AFTER correction: {batch_distance_after:.4f}\")\n# Calculate improvement\nimprovement = ((batch_distance_before - batch_distance_after) / batch_distance_before) * 100\nprint(f\"DEBUG: Batch correction improvement: {improvement:.1f}%\")\n# %%\nadata_rna = adata_rna_processed.copy()\nprint(f\"\\n DEBUG: Computing fresh PCA on batch-corrected data...\")",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "improvement",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "improvement = ((batch_distance_before - batch_distance_after) / batch_distance_before) * 100\nprint(f\"DEBUG: Batch correction improvement: {improvement:.1f}%\")\n# %%\nadata_rna = adata_rna_processed.copy()\nprint(f\"\\n DEBUG: Computing fresh PCA on batch-corrected data...\")\nprint(f\"DEBUG: Before PCA - X shape: {adata_rna.X.shape}\")\nprint(f\"DEBUG: Available embeddings after batch correction: {list(adata_rna.obsm.keys())}\")\nprint(f\"DEBUG: Before PCA - X contains batch-corrected data: \")\nsc.pp.pca(adata_rna, copy=False)\nprint(f\"DEBUG: After PCA - X_pca shape: {adata_rna.obsm['X_pca'].shape}\")",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_rna = adata_rna_processed.copy()\nprint(f\"\\n DEBUG: Computing fresh PCA on batch-corrected data...\")\nprint(f\"DEBUG: Before PCA - X shape: {adata_rna.X.shape}\")\nprint(f\"DEBUG: Available embeddings after batch correction: {list(adata_rna.obsm.keys())}\")\nprint(f\"DEBUG: Before PCA - X contains batch-corrected data: \")\nsc.pp.pca(adata_rna, copy=False)\nprint(f\"DEBUG: After PCA - X_pca shape: {adata_rna.obsm['X_pca'].shape}\")\nprint(f\"DEBUG: Available embeddings after PCA computation: {list(adata_rna.obsm.keys())}\")\n# %%\nif \"n_genes\" in adata_prot.obs.columns:",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "original_protein_num",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "original_protein_num = adata_prot.X.shape[1]\nassert adata_prot.obs.index.is_unique\nx_coor = adata_prot.obsm[\"spatial\"][:, 0]\ny_coor = adata_prot.obsm[\"spatial\"][:, 1]\ntemp = pd.DataFrame([x_coor, y_coor], index=[\"x\", \"y\"]).T\ntemp.index = adata_prot.obs.index\nadata_prot.obsm[\"spatial_location\"] = temp\nadata_prot.obs[\"X\"] = x_coor\nadata_prot.obs[\"Y\"] = y_coor\npp_plots.plot_spatial_locations(adata_prot, plot_flag)",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "x_coor",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "x_coor = adata_prot.obsm[\"spatial\"][:, 0]\ny_coor = adata_prot.obsm[\"spatial\"][:, 1]\ntemp = pd.DataFrame([x_coor, y_coor], index=[\"x\", \"y\"]).T\ntemp.index = adata_prot.obs.index\nadata_prot.obsm[\"spatial_location\"] = temp\nadata_prot.obs[\"X\"] = x_coor\nadata_prot.obs[\"Y\"] = y_coor\npp_plots.plot_spatial_locations(adata_prot, plot_flag)\nadata_prot = adata_prot[adata_prot.obs.sort_values(by=[\"cell_types\"]).index]\npp_plots.plot_expression_heatmaps(adata_rna, adata_prot, plot_flag)",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "y_coor",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "y_coor = adata_prot.obsm[\"spatial\"][:, 1]\ntemp = pd.DataFrame([x_coor, y_coor], index=[\"x\", \"y\"]).T\ntemp.index = adata_prot.obs.index\nadata_prot.obsm[\"spatial_location\"] = temp\nadata_prot.obs[\"X\"] = x_coor\nadata_prot.obs[\"Y\"] = y_coor\npp_plots.plot_spatial_locations(adata_prot, plot_flag)\nadata_prot = adata_prot[adata_prot.obs.sort_values(by=[\"cell_types\"]).index]\npp_plots.plot_expression_heatmaps(adata_rna, adata_prot, plot_flag)\npipeline_metadata_utils.finalize_align_datasets_metadata(adata_rna, adata_prot, kneedle.knee)",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "temp",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "temp = pd.DataFrame([x_coor, y_coor], index=[\"x\", \"y\"]).T\ntemp.index = adata_prot.obs.index\nadata_prot.obsm[\"spatial_location\"] = temp\nadata_prot.obs[\"X\"] = x_coor\nadata_prot.obs[\"Y\"] = y_coor\npp_plots.plot_spatial_locations(adata_prot, plot_flag)\nadata_prot = adata_prot[adata_prot.obs.sort_values(by=[\"cell_types\"]).index]\npp_plots.plot_expression_heatmaps(adata_rna, adata_prot, plot_flag)\npipeline_metadata_utils.finalize_align_datasets_metadata(adata_rna, adata_prot, kneedle.knee)\nsave_processed_data(",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "temp.index",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "temp.index = adata_prot.obs.index\nadata_prot.obsm[\"spatial_location\"] = temp\nadata_prot.obs[\"X\"] = x_coor\nadata_prot.obs[\"Y\"] = y_coor\npp_plots.plot_spatial_locations(adata_prot, plot_flag)\nadata_prot = adata_prot[adata_prot.obs.sort_values(by=[\"cell_types\"]).index]\npp_plots.plot_expression_heatmaps(adata_rna, adata_prot, plot_flag)\npipeline_metadata_utils.finalize_align_datasets_metadata(adata_rna, adata_prot, kneedle.knee)\nsave_processed_data(\n    adata_rna,",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_prot.obsm[\"spatial_location\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_prot.obsm[\"spatial_location\"] = temp\nadata_prot.obs[\"X\"] = x_coor\nadata_prot.obs[\"Y\"] = y_coor\npp_plots.plot_spatial_locations(adata_prot, plot_flag)\nadata_prot = adata_prot[adata_prot.obs.sort_values(by=[\"cell_types\"]).index]\npp_plots.plot_expression_heatmaps(adata_rna, adata_prot, plot_flag)\npipeline_metadata_utils.finalize_align_datasets_metadata(adata_rna, adata_prot, kneedle.knee)\nsave_processed_data(\n    adata_rna,\n    adata_prot,",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"X\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_prot.obs[\"X\"] = x_coor\nadata_prot.obs[\"Y\"] = y_coor\npp_plots.plot_spatial_locations(adata_prot, plot_flag)\nadata_prot = adata_prot[adata_prot.obs.sort_values(by=[\"cell_types\"]).index]\npp_plots.plot_expression_heatmaps(adata_rna, adata_prot, plot_flag)\npipeline_metadata_utils.finalize_align_datasets_metadata(adata_rna, adata_prot, kneedle.knee)\nsave_processed_data(\n    adata_rna,\n    adata_prot,\n    \"processed_data\",",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"Y\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_prot.obs[\"Y\"] = y_coor\npp_plots.plot_spatial_locations(adata_prot, plot_flag)\nadata_prot = adata_prot[adata_prot.obs.sort_values(by=[\"cell_types\"]).index]\npp_plots.plot_expression_heatmaps(adata_rna, adata_prot, plot_flag)\npipeline_metadata_utils.finalize_align_datasets_metadata(adata_rna, adata_prot, kneedle.knee)\nsave_processed_data(\n    adata_rna,\n    adata_prot,\n    \"processed_data\",\n    caller_filename=FILENAME,",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._1_align_datasets",
        "description": "ARCADIA.scripts._1_align_datasets",
        "peekOfCode": "adata_prot = adata_prot[adata_prot.obs.sort_values(by=[\"cell_types\"]).index]\npp_plots.plot_expression_heatmaps(adata_rna, adata_prot, plot_flag)\npipeline_metadata_utils.finalize_align_datasets_metadata(adata_rna, adata_prot, kneedle.knee)\nsave_processed_data(\n    adata_rna,\n    adata_prot,\n    \"processed_data\",\n    caller_filename=FILENAME,\n)\npp_plots.plot_final_alignment_results(adata_rna, adata_prot, plot_flag)",
        "detail": "ARCADIA.scripts._1_align_datasets",
        "documentation": {}
    },
    {
        "label": "residualize_spatial_features_by_cell_type",
        "kind": 2,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "def residualize_spatial_features_by_cell_type(\n    spatial_adata: AnnData, cell_type_column: str, batch_column: str | None = None\n):\n    if cell_type_column not in spatial_adata.obs.columns:\n        raise KeyError(\n            f\"{cell_type_column} missing from spatial AnnData. Provide major cell-type labels \"\n            \"derived from intrinsic markers before residualizing spatial features.\"\n        )\n    if batch_column is not None and batch_column not in spatial_adata.obs.columns:\n        batch_column = None",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "FILENAME = \"_2_spatial_integrate.py\"\n# %% tags=[\"parameters\"]\n# Default parameters - can be overridden by papermill\ndataset_name = None\nimport anndata as ad\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport seaborn as sns\nfrom anndata import AnnData",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "dataset_name = None\nimport anndata as ad\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport seaborn as sns\nfrom anndata import AnnData\nfrom matplotlib import pyplot as plt\nfrom scipy.sparse import csr_matrix, issparse\nfrom sklearn.cluster import KMeans",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "config_path = Path(\"configs/config.json\")\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\n    use_spatial_injection = config_.get(\"use_spatial_injection\", False)\n    residualize_spatial_features_flag = config_.get(\"residualize_spatial_features\", True)\n    print(f\"use_spatial_injection: {use_spatial_injection}\")",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_rna.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_rna.X = adata_rna.X.todense() if issparse(adata_rna.X) else adata_rna.X\nadata_prot.X = adata_prot.X.todense() if issparse(adata_prot.X) else adata_prot.X\n# %% Subsample data\nsubsample_n_obs_rna = min(adata_rna.shape[0], num_rna_cells)\nsubsample_n_obs_protein = min(adata_prot.shape[0], num_protein_cells)\nsc.pp.subsample(adata_rna, n_obs=subsample_n_obs_rna)\nsc.pp.subsample(adata_prot, n_obs=subsample_n_obs_protein)\n# Find archetypes using PCHA on UMAP coordinates\n# %% Processing\nshowcase_archetype_generation = False",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_prot.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_prot.X = adata_prot.X.todense() if issparse(adata_prot.X) else adata_prot.X\n# %% Subsample data\nsubsample_n_obs_rna = min(adata_rna.shape[0], num_rna_cells)\nsubsample_n_obs_protein = min(adata_prot.shape[0], num_protein_cells)\nsc.pp.subsample(adata_rna, n_obs=subsample_n_obs_rna)\nsc.pp.subsample(adata_prot, n_obs=subsample_n_obs_protein)\n# Find archetypes using PCHA on UMAP coordinates\n# %% Processing\nshowcase_archetype_generation = False\nif showcase_archetype_generation:",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "subsample_n_obs_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "subsample_n_obs_rna = min(adata_rna.shape[0], num_rna_cells)\nsubsample_n_obs_protein = min(adata_prot.shape[0], num_protein_cells)\nsc.pp.subsample(adata_rna, n_obs=subsample_n_obs_rna)\nsc.pp.subsample(adata_prot, n_obs=subsample_n_obs_protein)\n# Find archetypes using PCHA on UMAP coordinates\n# %% Processing\nshowcase_archetype_generation = False\nif showcase_archetype_generation:\n    pp_plots.showcase_archetype_generation(adata_rna, adata_prot, plot_flag)\n# %% Processing",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "subsample_n_obs_protein",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "subsample_n_obs_protein = min(adata_prot.shape[0], num_protein_cells)\nsc.pp.subsample(adata_rna, n_obs=subsample_n_obs_rna)\nsc.pp.subsample(adata_prot, n_obs=subsample_n_obs_protein)\n# Find archetypes using PCHA on UMAP coordinates\n# %% Processing\nshowcase_archetype_generation = False\nif showcase_archetype_generation:\n    pp_plots.showcase_archetype_generation(adata_rna, adata_prot, plot_flag)\n# %% Processing\noriginal_protein_num = adata_prot.X.shape[1]",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "showcase_archetype_generation",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "showcase_archetype_generation = False\nif showcase_archetype_generation:\n    pp_plots.showcase_archetype_generation(adata_rna, adata_prot, plot_flag)\n# %% Processing\noriginal_protein_num = adata_prot.X.shape[1]\nprint(f\"data shape: {adata_rna.shape}, {adata_prot.shape}\")\n# Determine which embedding to use for RNA archetype analysis\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# Note: This will be determined after batch correction is applied",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "original_protein_num",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "original_protein_num = adata_prot.X.shape[1]\nprint(f\"data shape: {adata_rna.shape}, {adata_prot.shape}\")\n# Determine which embedding to use for RNA archetype analysis\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# Note: This will be determined after batch correction is applied\nprotein_archetype_embedding_name = \"X_pca\"  # Default, will be updated later\n# Compute PCA and UMAP for both modalities\nsc.pp.pca(adata_rna)\nsc.pp.neighbors(adata_rna, key_added=\"original_neighbors\", use_rep=rna_archetype_embedding_name)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "rna_archetype_embedding_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "rna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# Note: This will be determined after batch correction is applied\nprotein_archetype_embedding_name = \"X_pca\"  # Default, will be updated later\n# Compute PCA and UMAP for both modalities\nsc.pp.pca(adata_rna)\nsc.pp.neighbors(adata_rna, key_added=\"original_neighbors\", use_rep=rna_archetype_embedding_name)\nsc.tl.umap(adata_rna, neighbors_key=\"original_neighbors\")\nadata_rna.obsm[\"X_original_pca\"] = adata_rna.obsm[\"X_pca\"]\nadata_rna.obsm[\"X_original_umap\"] = adata_rna.obsm[\"X_umap\"]",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "protein_archetype_embedding_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "protein_archetype_embedding_name = \"X_pca\"  # Default, will be updated later\n# Compute PCA and UMAP for both modalities\nsc.pp.pca(adata_rna)\nsc.pp.neighbors(adata_rna, key_added=\"original_neighbors\", use_rep=rna_archetype_embedding_name)\nsc.tl.umap(adata_rna, neighbors_key=\"original_neighbors\")\nadata_rna.obsm[\"X_original_pca\"] = adata_rna.obsm[\"X_pca\"]\nadata_rna.obsm[\"X_original_umap\"] = adata_rna.obsm[\"X_umap\"]\nsc.pp.pca(adata_prot)\nsc.pp.neighbors(\n    adata_prot, key_added=\"original_neighbors\", use_rep=protein_archetype_embedding_name",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_rna.obsm[\"X_original_pca\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_rna.obsm[\"X_original_pca\"] = adata_rna.obsm[\"X_pca\"]\nadata_rna.obsm[\"X_original_umap\"] = adata_rna.obsm[\"X_umap\"]\nsc.pp.pca(adata_prot)\nsc.pp.neighbors(\n    adata_prot, key_added=\"original_neighbors\", use_rep=protein_archetype_embedding_name\n)\nsc.tl.umap(adata_prot, neighbors_key=\"original_neighbors\")\nadata_prot.obsm[\"X_original_pca\"] = adata_prot.obsm[\"X_pca\"]\nadata_prot.obsm[\"X_original_umap\"] = adata_prot.obsm[\"X_umap\"]\n# %% Compute Spatial Neighbors and Means",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_rna.obsm[\"X_original_umap\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_rna.obsm[\"X_original_umap\"] = adata_rna.obsm[\"X_umap\"]\nsc.pp.pca(adata_prot)\nsc.pp.neighbors(\n    adata_prot, key_added=\"original_neighbors\", use_rep=protein_archetype_embedding_name\n)\nsc.tl.umap(adata_prot, neighbors_key=\"original_neighbors\")\nadata_prot.obsm[\"X_original_pca\"] = adata_prot.obsm[\"X_pca\"]\nadata_prot.obsm[\"X_original_umap\"] = adata_prot.obsm[\"X_umap\"]\n# %% Compute Spatial Neighbors and Means\n# remove far away neighbors before setting up the neighbors means",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_prot.obsm[\"X_original_pca\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_prot.obsm[\"X_original_pca\"] = adata_prot.obsm[\"X_pca\"]\nadata_prot.obsm[\"X_original_umap\"] = adata_prot.obsm[\"X_umap\"]\n# %% Compute Spatial Neighbors and Means\n# remove far away neighbors before setting up the neighbors means\n# Calculate neighbors separately within each batch if multiple batches exist\nn_neighbors = 20 if adata_prot.n_obs > 5000 else 10\n# Check if batch column exists and has multiple batches\nif \"batch\" in adata_prot.obs.columns:\n    unique_batches = adata_prot.obs[\"batch\"].unique()\n    n_batches = len(unique_batches)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_prot.obsm[\"X_original_umap\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_prot.obsm[\"X_original_umap\"] = adata_prot.obsm[\"X_umap\"]\n# %% Compute Spatial Neighbors and Means\n# remove far away neighbors before setting up the neighbors means\n# Calculate neighbors separately within each batch if multiple batches exist\nn_neighbors = 20 if adata_prot.n_obs > 5000 else 10\n# Check if batch column exists and has multiple batches\nif \"batch\" in adata_prot.obs.columns:\n    unique_batches = adata_prot.obs[\"batch\"].unique()\n    n_batches = len(unique_batches)\n    print(f\"Found {n_batches} batches: {unique_batches}\")",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "n_neighbors",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "n_neighbors = 20 if adata_prot.n_obs > 5000 else 10\n# Check if batch column exists and has multiple batches\nif \"batch\" in adata_prot.obs.columns:\n    unique_batches = adata_prot.obs[\"batch\"].unique()\n    n_batches = len(unique_batches)\n    print(f\"Found {n_batches} batches: {unique_batches}\")\n    if n_batches > 1:\n        # Calculate neighbors separately for each batch\n        print(\"Calculating spatial neighbors separately within each batch...\")\n        n_cells = adata_prot.n_obs",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_prot = create_smart_neighbors(adata_prot)\npp_plots.plot_spatial_distance_hist(\n    adata_prot,\n    key=\"spatial_neighbors_distances\",\n    title=\"Distribution of spatial distances between protein neighbors after cutoff\",\n    plot_flag=plot_flag,\n)\n# %% Processing\nuse_empirical_cn = False\nuse_annotated_cn = True",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "use_empirical_cn",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "use_empirical_cn = False\nuse_annotated_cn = True\n# CN assignment will be done after COVET features are generated (after line 424)\nif use_annotated_cn and \"lab_CN\" in adata_prot.obs.columns:\n    adata_prot.obs[\"CN\"] = adata_prot.obs[\"lab_CN\"]\n    num_clusters = len(adata_prot.obs[\"CN\"].unique())\n    # Add CN type info to existing archetype_generation metadata\nif issparse(adata_prot.X):\n    adata_prot.X = adata_prot.X.toarray()\n# Find most variable genes",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "use_annotated_cn",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "use_annotated_cn = True\n# CN assignment will be done after COVET features are generated (after line 424)\nif use_annotated_cn and \"lab_CN\" in adata_prot.obs.columns:\n    adata_prot.obs[\"CN\"] = adata_prot.obs[\"lab_CN\"]\n    num_clusters = len(adata_prot.obs[\"CN\"].unique())\n    # Add CN type info to existing archetype_generation metadata\nif issparse(adata_prot.X):\n    adata_prot.X = adata_prot.X.toarray()\n# Find most variable genes\nif adata_prot.X.dtype == np.int32:",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "orginal_num_features",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "orginal_num_features = adata_prot.X.shape[1]  # Capture original protein feature count before COVET\n# 1. Create protein + means + COVET features (X is not yet row-zscored here)\n# Assuming prepare_data might modify adata_2_prot or its .var, so pass a copy or handle its return carefully.\n# If prepare_data returns a new AnnData:\n# %% Verify that var_names do not contain dashes todo remove this and just fix the names in the prepare_data function\ndash_vars = [var for var in adata_prot.var_names if \"-\" in var]\nif dash_vars:\n    print(f\"Warning: Found {len(dash_vars)} variable names containing dashes:\")\n    print(dash_vars[:10])  # Show first 10 examples\n    # Replace dashes with underscores",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "dash_vars",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "dash_vars = [var for var in adata_prot.var_names if \"-\" in var]\nif dash_vars:\n    print(f\"Warning: Found {len(dash_vars)} variable names containing dashes:\")\n    print(dash_vars[:10])  # Show first 10 examples\n    # Replace dashes with underscores\n    adata_prot.var_names = [var.replace(\"-\", \"_\") for var in adata_prot.var_names]\n    # raise ValueError(\"Replaced dashes with underscores in variable names to avoid issues with COVET features names\")\nif adata_prot.X.min() < 0:\n    adata_prot.X = adata_prot.X - adata_prot.X.min() + 1e-6\n# %% filter out CN features",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "use_covet",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "use_covet = False\nuse_means = True\nuse_variances = False\nvalid_feature_types = [\"protein\"]\nconnectivities = adata_prot.obsp[\"spatial_neighbors_connectivities\"].copy()\nconnectivities[connectivities > 0] = 1  # binarize\nX_protein = adata_prot.X.copy()\nif issparse(X_protein):\n    X_protein = X_protein.toarray()\nneighbor_sums = connectivities.dot(X_protein)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "use_means",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "use_means = True\nuse_variances = False\nvalid_feature_types = [\"protein\"]\nconnectivities = adata_prot.obsp[\"spatial_neighbors_connectivities\"].copy()\nconnectivities[connectivities > 0] = 1  # binarize\nX_protein = adata_prot.X.copy()\nif issparse(X_protein):\n    X_protein = X_protein.toarray()\nneighbor_sums = connectivities.dot(X_protein)\nneighbor_means = np.asarray(",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "use_variances",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "use_variances = False\nvalid_feature_types = [\"protein\"]\nconnectivities = adata_prot.obsp[\"spatial_neighbors_connectivities\"].copy()\nconnectivities[connectivities > 0] = 1  # binarize\nX_protein = adata_prot.X.copy()\nif issparse(X_protein):\n    X_protein = X_protein.toarray()\nneighbor_sums = connectivities.dot(X_protein)\nneighbor_means = np.asarray(\n    neighbor_sums / connectivities.sum(1)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "valid_feature_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "valid_feature_types = [\"protein\"]\nconnectivities = adata_prot.obsp[\"spatial_neighbors_connectivities\"].copy()\nconnectivities[connectivities > 0] = 1  # binarize\nX_protein = adata_prot.X.copy()\nif issparse(X_protein):\n    X_protein = X_protein.toarray()\nneighbor_sums = connectivities.dot(X_protein)\nneighbor_means = np.asarray(\n    neighbor_sums / connectivities.sum(1)\n)  # divide by number of neighbors (k)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "connectivities",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "connectivities = adata_prot.obsp[\"spatial_neighbors_connectivities\"].copy()\nconnectivities[connectivities > 0] = 1  # binarize\nX_protein = adata_prot.X.copy()\nif issparse(X_protein):\n    X_protein = X_protein.toarray()\nneighbor_sums = connectivities.dot(X_protein)\nneighbor_means = np.asarray(\n    neighbor_sums / connectivities.sum(1)\n)  # divide by number of neighbors (k)\nneighbor_means = np.nan_to_num(neighbor_means)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "X_protein",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "X_protein = adata_prot.X.copy()\nif issparse(X_protein):\n    X_protein = X_protein.toarray()\nneighbor_sums = connectivities.dot(X_protein)\nneighbor_means = np.asarray(\n    neighbor_sums / connectivities.sum(1)\n)  # divide by number of neighbors (k)\nneighbor_means = np.nan_to_num(neighbor_means)\n# Calculate neighbor variance\nneighbor_squared_sums = connectivities.dot(X_protein**2)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "neighbor_sums",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "neighbor_sums = connectivities.dot(X_protein)\nneighbor_means = np.asarray(\n    neighbor_sums / connectivities.sum(1)\n)  # divide by number of neighbors (k)\nneighbor_means = np.nan_to_num(neighbor_means)\n# Calculate neighbor variance\nneighbor_squared_sums = connectivities.dot(X_protein**2)\nneighbor_variances = np.asarray(neighbor_squared_sums / connectivities.sum(1) - neighbor_means**2)\nneighbor_variances = np.nan_to_num(neighbor_variances)\n# Add neighbor means and variances as features",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "neighbor_means",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "neighbor_means = np.asarray(\n    neighbor_sums / connectivities.sum(1)\n)  # divide by number of neighbors (k)\nneighbor_means = np.nan_to_num(neighbor_means)\n# Calculate neighbor variance\nneighbor_squared_sums = connectivities.dot(X_protein**2)\nneighbor_variances = np.asarray(neighbor_squared_sums / connectivities.sum(1) - neighbor_means**2)\nneighbor_variances = np.nan_to_num(neighbor_variances)\n# Add neighbor means and variances as features\nif use_covet:",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "neighbor_means",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "neighbor_means = np.nan_to_num(neighbor_means)\n# Calculate neighbor variance\nneighbor_squared_sums = connectivities.dot(X_protein**2)\nneighbor_variances = np.asarray(neighbor_squared_sums / connectivities.sum(1) - neighbor_means**2)\nneighbor_variances = np.nan_to_num(neighbor_variances)\n# Add neighbor means and variances as features\nif use_covet:\n    raise ValueError(\"COVET is not supported yet\")\n    # adata_protein_neigh_means_and_covet = prepare_data(\n    #     adata_prot.copy(), covet_k=10, covet_g=64, covet_selection_method=\"high_variability\"",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "neighbor_squared_sums",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "neighbor_squared_sums = connectivities.dot(X_protein**2)\nneighbor_variances = np.asarray(neighbor_squared_sums / connectivities.sum(1) - neighbor_means**2)\nneighbor_variances = np.nan_to_num(neighbor_variances)\n# Add neighbor means and variances as features\nif use_covet:\n    raise ValueError(\"COVET is not supported yet\")\n    # adata_protein_neigh_means_and_covet = prepare_data(\n    #     adata_prot.copy(), covet_k=10, covet_g=64, covet_selection_method=\"high_variability\"\n    # )\n    # adata_protein_neigh_means_and_covet = adata_protein_neigh_means_and_covet[",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "neighbor_variances",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "neighbor_variances = np.asarray(neighbor_squared_sums / connectivities.sum(1) - neighbor_means**2)\nneighbor_variances = np.nan_to_num(neighbor_variances)\n# Add neighbor means and variances as features\nif use_covet:\n    raise ValueError(\"COVET is not supported yet\")\n    # adata_protein_neigh_means_and_covet = prepare_data(\n    #     adata_prot.copy(), covet_k=10, covet_g=64, covet_selection_method=\"high_variability\"\n    # )\n    # adata_protein_neigh_means_and_covet = adata_protein_neigh_means_and_covet[\n    #     :, adata_protein_neigh_means_and_covet.var[\"feature_type\"].isin([\"CN\", \"protein\"])",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "neighbor_variances",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "neighbor_variances = np.nan_to_num(neighbor_variances)\n# Add neighbor means and variances as features\nif use_covet:\n    raise ValueError(\"COVET is not supported yet\")\n    # adata_protein_neigh_means_and_covet = prepare_data(\n    #     adata_prot.copy(), covet_k=10, covet_g=64, covet_selection_method=\"high_variability\"\n    # )\n    # adata_protein_neigh_means_and_covet = adata_protein_neigh_means_and_covet[\n    #     :, adata_protein_neigh_means_and_covet.var[\"feature_type\"].isin([\"CN\", \"protein\"])\n    # ]",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "X_list",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "X_list = [adata_protein_neigh_means_and_covet.X]\nvar_names_list = list(adata_protein_neigh_means_and_covet.var_names)\nif \"feature_type\" in adata_protein_neigh_means_and_covet.var.columns:\n    feature_types_list = adata_protein_neigh_means_and_covet.var[\"feature_type\"].tolist()\nelse:\n    feature_types_list = [\"protein\"] * adata_protein_neigh_means_and_covet.n_vars\nif use_means:\n    X_list.append(neighbor_means)\n    var_names_list.extend([f\"{col}_neighbor_mean\" for col in adata_prot.var_names])\n    feature_types_list.extend([\"neighbor_mean\"] * adata_prot.n_vars)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "var_names_list",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "var_names_list = list(adata_protein_neigh_means_and_covet.var_names)\nif \"feature_type\" in adata_protein_neigh_means_and_covet.var.columns:\n    feature_types_list = adata_protein_neigh_means_and_covet.var[\"feature_type\"].tolist()\nelse:\n    feature_types_list = [\"protein\"] * adata_protein_neigh_means_and_covet.n_vars\nif use_means:\n    X_list.append(neighbor_means)\n    var_names_list.extend([f\"{col}_neighbor_mean\" for col in adata_prot.var_names])\n    feature_types_list.extend([\"neighbor_mean\"] * adata_prot.n_vars)\n    valid_feature_types.append(\"neighbor_mean\")",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "X_combined",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "X_combined = np.hstack(X_list)\n# Create new var dataframe\nvar_df = pd.DataFrame({\"feature_type\": feature_types_list}, index=var_names_list)\n# Create new adata with combined features, preserving obs and other fields\nadata_protein_neigh_means_and_covet = ad.AnnData(\n    X=X_combined,\n    obs=adata_protein_neigh_means_and_covet.obs,\n    var=var_df,\n    obsm=adata_protein_neigh_means_and_covet.obsm,\n    obsp=adata_protein_neigh_means_and_covet.obsp,",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "var_df",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "var_df = pd.DataFrame({\"feature_type\": feature_types_list}, index=var_names_list)\n# Create new adata with combined features, preserving obs and other fields\nadata_protein_neigh_means_and_covet = ad.AnnData(\n    X=X_combined,\n    obs=adata_protein_neigh_means_and_covet.obs,\n    var=var_df,\n    obsm=adata_protein_neigh_means_and_covet.obsm,\n    obsp=adata_protein_neigh_means_and_covet.obsp,\n    uns=adata_protein_neigh_means_and_covet.uns,\n)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_protein_neigh_means_and_covet",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_protein_neigh_means_and_covet = ad.AnnData(\n    X=X_combined,\n    obs=adata_protein_neigh_means_and_covet.obs,\n    var=var_df,\n    obsm=adata_protein_neigh_means_and_covet.obsm,\n    obsp=adata_protein_neigh_means_and_covet.obsp,\n    uns=adata_protein_neigh_means_and_covet.uns,\n)\n# Filter by valid feature types\nadata_protein_neigh_means_and_covet = adata_protein_neigh_means_and_covet[",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_protein_neigh_means_and_covet",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_protein_neigh_means_and_covet = adata_protein_neigh_means_and_covet[\n    :, adata_protein_neigh_means_and_covet.var[\"feature_type\"].isin(valid_feature_types)\n].copy()\nif \"highly_variable\" not in adata_protein_neigh_means_and_covet.var.columns:\n    adata_protein_neigh_means_and_covet.var[\"highly_variable\"] = True\n# adata_protein_neigh_means_and_covet.X = scaler.fit_transform(adata_protein_neigh_means_and_covet.X)\n# %% If prepare_data modifies inplace and returns None (less ideal):\nnon_protein_mask = adata_protein_neigh_means_and_covet.var[\"feature_type\"] != \"protein\"\nspatial_adata = adata_protein_neigh_means_and_covet[:, non_protein_mask].copy()\nif spatial_adata.X.min() < 0:",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "non_protein_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "non_protein_mask = adata_protein_neigh_means_and_covet.var[\"feature_type\"] != \"protein\"\nspatial_adata = adata_protein_neigh_means_and_covet[:, non_protein_mask].copy()\nif spatial_adata.X.min() < 0:\n    spatial_adata.X = spatial_adata.X - spatial_adata.X.min() + 1e-6\nspatial_adata.X = np.nan_to_num(spatial_adata.X)\nspatial_adata_raw = spatial_adata.copy()\ncell_type_column = \"cell_types\"\nspatial_residualization_metadata = {\n    \"method\": \"none\",\n    \"cell_type_column\": cell_type_column,",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "spatial_adata",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "spatial_adata = adata_protein_neigh_means_and_covet[:, non_protein_mask].copy()\nif spatial_adata.X.min() < 0:\n    spatial_adata.X = spatial_adata.X - spatial_adata.X.min() + 1e-6\nspatial_adata.X = np.nan_to_num(spatial_adata.X)\nspatial_adata_raw = spatial_adata.copy()\ncell_type_column = \"cell_types\"\nspatial_residualization_metadata = {\n    \"method\": \"none\",\n    \"cell_type_column\": cell_type_column,\n    \"n_cell_types\": None,",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "spatial_adata.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "spatial_adata.X = np.nan_to_num(spatial_adata.X)\nspatial_adata_raw = spatial_adata.copy()\ncell_type_column = \"cell_types\"\nspatial_residualization_metadata = {\n    \"method\": \"none\",\n    \"cell_type_column\": cell_type_column,\n    \"n_cell_types\": None,\n    \"batch_column\": None,\n    \"n_batches\": None,\n    \"applied\": False,",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "spatial_adata_raw",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "spatial_adata_raw = spatial_adata.copy()\ncell_type_column = \"cell_types\"\nspatial_residualization_metadata = {\n    \"method\": \"none\",\n    \"cell_type_column\": cell_type_column,\n    \"n_cell_types\": None,\n    \"batch_column\": None,\n    \"n_batches\": None,\n    \"applied\": False,\n}",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "cell_type_column",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "cell_type_column = \"cell_types\"\nspatial_residualization_metadata = {\n    \"method\": \"none\",\n    \"cell_type_column\": cell_type_column,\n    \"n_cell_types\": None,\n    \"batch_column\": None,\n    \"n_batches\": None,\n    \"applied\": False,\n}\nif residualize_spatial_features_flag:",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "spatial_residualization_metadata",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "spatial_residualization_metadata = {\n    \"method\": \"none\",\n    \"cell_type_column\": cell_type_column,\n    \"n_cell_types\": None,\n    \"batch_column\": None,\n    \"n_batches\": None,\n    \"applied\": False,\n}\nif residualize_spatial_features_flag:\n    batch_column = \"batch\" if \"batch\" in spatial_adata.obs.columns else None",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "] = spatial_residualization_metadata\nadata_protein_neigh_means_and_covet.X[:, non_protein_mask] = spatial_adata.X\nif residualize_spatial_features_flag and plot_flag:\n    spatial_adata_raw_plot = (\n        spatial_adata_raw[:2000].copy()\n        if spatial_adata_raw.n_obs > 2000\n        else spatial_adata_raw.copy()\n    )\n    spatial_adata_resid_plot = (\n        spatial_adata[:2000].copy() if spatial_adata.n_obs > 2000 else spatial_adata.copy()",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "feature_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "feature_types = spatial_adata.var[\"feature_type\"]\nmean_features = spatial_adata.X.mean(axis=0)\n# Create DataFrame for easier plotting\ndf = pd.DataFrame({\"mean_value\": mean_features, \"feature_type\": feature_types})\n# Plot feature mean distributions before scaling\nfrom arcadia.plotting.spatial import plot_feature_mean_distributions\nplot_feature_mean_distributions(spatial_adata, plot_flag=plot_flag)\n# Subsample for plotting\nspatial_adata_plot = (\n    spatial_adata[:2000].copy() if spatial_adata.n_obs > 2000 else spatial_adata.copy()",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "mean_features",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "mean_features = spatial_adata.X.mean(axis=0)\n# Create DataFrame for easier plotting\ndf = pd.DataFrame({\"mean_value\": mean_features, \"feature_type\": feature_types})\n# Plot feature mean distributions before scaling\nfrom arcadia.plotting.spatial import plot_feature_mean_distributions\nplot_feature_mean_distributions(spatial_adata, plot_flag=plot_flag)\n# Subsample for plotting\nspatial_adata_plot = (\n    spatial_adata[:2000].copy() if spatial_adata.n_obs > 2000 else spatial_adata.copy()\n)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "df = pd.DataFrame({\"mean_value\": mean_features, \"feature_type\": feature_types})\n# Plot feature mean distributions before scaling\nfrom arcadia.plotting.spatial import plot_feature_mean_distributions\nplot_feature_mean_distributions(spatial_adata, plot_flag=plot_flag)\n# Subsample for plotting\nspatial_adata_plot = (\n    spatial_adata[:2000].copy() if spatial_adata.n_obs > 2000 else spatial_adata.copy()\n)\nsns.heatmap(spatial_adata_plot.X[:1000])\nplt.show()",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "spatial_adata_plot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "spatial_adata_plot = (\n    spatial_adata[:2000].copy() if spatial_adata.n_obs > 2000 else spatial_adata.copy()\n)\nsns.heatmap(spatial_adata_plot.X[:1000])\nplt.show()\nsc.pp.pca(spatial_adata_plot)\nsc.pp.neighbors(spatial_adata_plot)\nsc.tl.umap(spatial_adata_plot)\nsc.pl.pca(spatial_adata_plot, color=\"cell_types\")\nsc.pl.umap(spatial_adata_plot, color=\"cell_types\")",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "means_only_adata",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "means_only_adata = spatial_adata[:, spatial_adata.var[\"feature_type\"] == \"neighbor_mean\"].copy()\n# Subsample for plotting\nmeans_only_adata_plot = (\n    means_only_adata[:2000].copy() if means_only_adata.n_obs > 2000 else means_only_adata.copy()\n)\nsc.pp.pca(means_only_adata_plot)\nsc.pp.neighbors(means_only_adata_plot)\nsc.tl.umap(means_only_adata_plot)\nsc.pl.pca(means_only_adata_plot, color=\"cell_types\")\nsc.pl.umap(means_only_adata_plot, color=\"cell_types\")",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "means_only_adata_plot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "means_only_adata_plot = (\n    means_only_adata[:2000].copy() if means_only_adata.n_obs > 2000 else means_only_adata.copy()\n)\nsc.pp.pca(means_only_adata_plot)\nsc.pp.neighbors(means_only_adata_plot)\nsc.tl.umap(means_only_adata_plot)\nsc.pl.pca(means_only_adata_plot, color=\"cell_types\")\nsc.pl.umap(means_only_adata_plot, color=\"cell_types\")\nfrom arcadia.plotting.spatial import plot_feature_means_line\nplot_feature_means_line(adata_protein_neigh_means_and_covet, plot_flag=plot_flag)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "scale_factor",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "scale_factor = 0.5\nif scale_factor != 1.0:\n    adata_protein_neigh_means_and_covet.X[:, non_protein_mask] = (\n        adata_protein_neigh_means_and_covet.X[:, non_protein_mask] * scale_factor\n    )\nadata_protein_neigh_means_and_covet.uns[\"pipeline_metadata\"][\"scale_factor\"] = scale_factor\nplot_feature_means_line(adata_protein_neigh_means_and_covet, plot_flag=plot_flag)\nresolution = None\nsc.pp.pca(adata_protein_neigh_means_and_covet)\nneighbors_key = f\"neighbors_{protein_archetype_embedding_name}\"",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_protein_neigh_means_and_covet.uns[\"pipeline_metadata\"][\"scale_factor\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_protein_neigh_means_and_covet.uns[\"pipeline_metadata\"][\"scale_factor\"] = scale_factor\nplot_feature_means_line(adata_protein_neigh_means_and_covet, plot_flag=plot_flag)\nresolution = None\nsc.pp.pca(adata_protein_neigh_means_and_covet)\nneighbors_key = f\"neighbors_{protein_archetype_embedding_name}\"\nsc.pp.neighbors(\n    adata_protein_neigh_means_and_covet,\n    use_rep=protein_archetype_embedding_name,\n    key_added=neighbors_key,\n)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "resolution",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "resolution = None\nsc.pp.pca(adata_protein_neigh_means_and_covet)\nneighbors_key = f\"neighbors_{protein_archetype_embedding_name}\"\nsc.pp.neighbors(\n    adata_protein_neigh_means_and_covet,\n    use_rep=protein_archetype_embedding_name,\n    key_added=neighbors_key,\n)\numap_key = f\"X_umap_{protein_archetype_embedding_name}\"\nsc.tl.umap(",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "neighbors_key",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "neighbors_key = f\"neighbors_{protein_archetype_embedding_name}\"\nsc.pp.neighbors(\n    adata_protein_neigh_means_and_covet,\n    use_rep=protein_archetype_embedding_name,\n    key_added=neighbors_key,\n)\numap_key = f\"X_umap_{protein_archetype_embedding_name}\"\nsc.tl.umap(\n    adata_protein_neigh_means_and_covet,\n    neighbors_key=neighbors_key,",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "umap_key",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "umap_key = f\"X_umap_{protein_archetype_embedding_name}\"\nsc.tl.umap(\n    adata_protein_neigh_means_and_covet,\n    neighbors_key=neighbors_key,\n)\nif umap_key != \"X_umap\":\n    adata_protein_neigh_means_and_covet.obsm[umap_key] = adata_protein_neigh_means_and_covet.obsm[\n        \"X_umap\"\n    ].copy()\npp_plots.plot_original_vs_new_protein_umap(",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "temp_cn",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "temp_cn = AnnData(\n    non_protein_data,\n    obs=adata_protein_neigh_means_and_covet.obs.copy(),\n    var=adata_protein_neigh_means_and_covet.var.loc[non_protein_mask].copy(),\n)\nsc.pp.pca(temp_cn)\nsc.pp.neighbors(temp_cn)\nclustering_method = \"kmeans\"  # \"leiden\" or \"kmeans\"\nif clustering_method == \"leiden\":\n    # Run Leiden clustering with silhouette score optimization",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "clustering_method",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "clustering_method = \"kmeans\"  # \"leiden\" or \"kmeans\"\nif clustering_method == \"leiden\":\n    # Run Leiden clustering with silhouette score optimization\n    best_silhouette = -1\n    best_resolution = None\n    best_clustering = None\n    resolution_range = np.arange(0.005, 2, 0.03)  # Test resolutions from 0.1 to 2\n    sli_list = []\n    for resolution in resolution_range:\n        sc.tl.leiden(temp_cn, resolution=resolution, key_added=\"leiden_temp\")",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "adata_prot = adata_protein_neigh_means_and_covet.copy()\nprotein_feature_mask = adata_prot.var[\"feature_type\"] == \"protein\"\nprint(f\"Current highly_variable distribution by feature type:\")\nfor feat_type in adata_prot.var[\"feature_type\"].unique():\n    mask = adata_prot.var[\"feature_type\"] == feat_type\n    if \"highly_variable\" in adata_prot.var.columns:\n        n_hv = np.sum(adata_prot.var.loc[mask, \"highly_variable\"])\n        n_total = np.sum(mask)\n        print(f\"{feat_type}: {n_hv}/{n_total} highly_variable\")\n    else:",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "protein_feature_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "protein_feature_mask = adata_prot.var[\"feature_type\"] == \"protein\"\nprint(f\"Current highly_variable distribution by feature type:\")\nfor feat_type in adata_prot.var[\"feature_type\"].unique():\n    mask = adata_prot.var[\"feature_type\"] == feat_type\n    if \"highly_variable\" in adata_prot.var.columns:\n        n_hv = np.sum(adata_prot.var.loc[mask, \"highly_variable\"])\n        n_total = np.sum(mask)\n        print(f\"{feat_type}: {n_hv}/{n_total} highly_variable\")\n    else:\n        print(f\"{feat_type}: no highly_variable column\")",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "most_common_cell_type",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "most_common_cell_type = adata_prot.obs[\"cell_types\"].value_counts().idxmax()\nmost_common_cell_type_mask = adata_prot.obs[\"cell_types\"] == most_common_cell_type\nplot_protein_cn_subset_umaps(adata_prot, most_common_cell_type, plot_flag)\n# %% make sure prot data and cn data features are similar same scale and variance\n# Compare statistical properties between protein features and cell neighborhood features\nprotein_mask = adata_prot.var[\"feature_type\"] == \"protein\"\nspatial_mask = adata_prot.var[\"feature_type\"] != \"protein\"\n# Extract data for each feature type\nif issparse(adata_prot.X):\n    protein_data = adata_prot.X[:, protein_mask].toarray()",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "most_common_cell_type_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "most_common_cell_type_mask = adata_prot.obs[\"cell_types\"] == most_common_cell_type\nplot_protein_cn_subset_umaps(adata_prot, most_common_cell_type, plot_flag)\n# %% make sure prot data and cn data features are similar same scale and variance\n# Compare statistical properties between protein features and cell neighborhood features\nprotein_mask = adata_prot.var[\"feature_type\"] == \"protein\"\nspatial_mask = adata_prot.var[\"feature_type\"] != \"protein\"\n# Extract data for each feature type\nif issparse(adata_prot.X):\n    protein_data = adata_prot.X[:, protein_mask].toarray()\n    spatial_data = adata_prot.X[:, spatial_mask].toarray()",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "protein_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "protein_mask = adata_prot.var[\"feature_type\"] == \"protein\"\nspatial_mask = adata_prot.var[\"feature_type\"] != \"protein\"\n# Extract data for each feature type\nif issparse(adata_prot.X):\n    protein_data = adata_prot.X[:, protein_mask].toarray()\n    spatial_data = adata_prot.X[:, spatial_mask].toarray()\nelse:\n    protein_data = adata_prot.X[:, protein_mask]\n    spatial_data = adata_prot.X[:, spatial_mask]\n# Calculate basic statistics",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "spatial_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "spatial_mask = adata_prot.var[\"feature_type\"] != \"protein\"\n# Extract data for each feature type\nif issparse(adata_prot.X):\n    protein_data = adata_prot.X[:, protein_mask].toarray()\n    spatial_data = adata_prot.X[:, spatial_mask].toarray()\nelse:\n    protein_data = adata_prot.X[:, protein_mask]\n    spatial_data = adata_prot.X[:, spatial_mask]\n# Calculate basic statistics\nprotein_stats = {",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "protein_stats",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "protein_stats = {\n    \"mean\": np.mean(protein_data),\n    \"std\": np.std(protein_data),\n    \"min\": np.min(protein_data),\n    \"max\": np.max(protein_data),\n    \"median\": np.median(protein_data),\n}\nspatial_stats = {\n    \"mean\": np.mean(spatial_data),\n    \"std\": np.std(spatial_data),",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "spatial_stats",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "spatial_stats = {\n    \"mean\": np.mean(spatial_data),\n    \"std\": np.std(spatial_data),\n    \"min\": np.min(spatial_data),\n    \"max\": np.max(spatial_data),\n    \"median\": np.median(spatial_data),\n}\nprint(\"\\nComparing statistical properties of protein vs CN features:\")\nprint(f\"{'Statistic':10} {'Protein':15} {'CN':15} {'Ratio (Protein/CN)':20}\")\nprint(\"-\" * 60)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "scale_threshold",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "scale_threshold = 10  # Define threshold for when scaling is needed\nif (\n    protein_stats[\"std\"] / spatial_stats[\"std\"] > scale_threshold\n    or spatial_stats[\"std\"] / protein_stats[\"std\"] > scale_threshold\n):\n    print(\"\\nWARNING: Large difference in variance between protein and CN features!\")\n    print(\"Consider scaling features before PCA to prevent bias.\")\n# Plot a sample of values from both feature sets\n# First split features by type\nplot_feature_value_distributions(adata_prot, num_points=1000, plot_flag=plot_flag)",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "n_protein_features",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "n_protein_features = adata_prot.shape[1]\nprint(f\"Number of protein features: {n_protein_features}\")\nif n_protein_features > 200:\n    adata_original_for_vae_plots = adata_prot.copy()\n    # Generate target cluster structure from protein features\n    use_unsupervised_clustering = False\n    if use_unsupervised_clustering:\n        target_cluster_structure, cluster_labels, target_silhouette_score = (\n            generate_target_cluster_structure_unsuprvised(\n                adata_original_for_vae_plots, orginal_num_features, clustering_resolution=None",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "vae_hyperparams_for_metadata",
        "kind": 5,
        "importPath": "ARCADIA.scripts._2_spatial_integrate",
        "description": "ARCADIA.scripts._2_spatial_integrate",
        "peekOfCode": "vae_hyperparams_for_metadata = None\nif \"vae_hyperparams\" in locals() and vae_hyperparams is not None:\n    vae_hyperparams_for_metadata = {\n        \"latent_dim\": vae_hyperparams[\"latent_dim\"],\n        \"n_hidden\": vae_hyperparams[\"n_hidden\"],\n        \"learning_rate\": vae_hyperparams[\"learning_rate\"],\n        \"kl_weight\": vae_hyperparams[\"kl_weight\"],\n        \"n_layers\": vae_hyperparams[\"n_layers\"],\n    }\npipeline_metadata_utils.finalize_spatial_info_integrate_metadata(",
        "detail": "ARCADIA.scripts._2_spatial_integrate",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "FILENAME = \"_3_generate_archetypes.py\"\n# %% tags=[\"parameters\"]\n# Default parameters - can be overridden by papermill\ndataset_name = None\n# %% Archetype Generation with Neighbors Means and MaxFuse\n# This notebook generates archetypes for RNA and protein data using neighbor means and MaxFuse alignment.\n# Suppress pkg_resources deprecation warnings from louvain - must be before any imports that use louvain\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\nwarnings.filterwarnings(",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "dataset_name = None\n# %% Archetype Generation with Neighbors Means and MaxFuse\n# This notebook generates archetypes for RNA and protein data using neighbor means and MaxFuse alignment.\n# Suppress pkg_resources deprecation warnings from louvain - must be before any imports that use louvain\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\nwarnings.filterwarnings(\n    \"ignore\", message=\"pkg_resources is deprecated as an API.*\", category=UserWarning\n)\nimport numpy as np",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "config_path = Path(\"configs/config.json\")\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna_viz",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna_viz = adata_rna.copy()\n# todo: try to make the log1p before and make sure it is set as la\nsc.pp.pca(adata_rna_viz)\nsc.pp.neighbors(adata_rna_viz)\nsc.tl.umap(adata_rna_viz)\nsc.pl.umap(adata_rna_viz, color=\"cell_types\")\nsc.pl.pca(adata_rna_viz, color=\"cell_types\")\nadata_rna.X = adata_rna_viz.X.copy()\n# Copy embedding back to original adata\nadata_rna.obsm[\"X_pca\"] = adata_rna_viz.obsm[\"X_pca\"]",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.X = adata_rna_viz.X.copy()\n# Copy embedding back to original adata\nadata_rna.obsm[\"X_pca\"] = adata_rna_viz.obsm[\"X_pca\"]\nadata_rna.obsm[\"X_umap\"] = adata_rna_viz.obsm[\"X_umap\"]\nadata_rna.uns[\"pca\"] = adata_rna_viz.uns[\"pca\"]\nadata_rna.uns[\"neighbors\"] = adata_rna_viz.uns[\"neighbors\"]\nadata_rna.uns[\"umap\"] = adata_rna_viz.uns[\"umap\"]\nadata_rna.obsp[\"distances\"] = adata_rna_viz.obsp[\"distances\"]\nadata_rna.obsp[\"connectivities\"] = adata_rna_viz.obsp[\"connectivities\"]\nrna_archetype_embedding_name = \"X_pca\"",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.obsm[\"X_pca\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.obsm[\"X_pca\"] = adata_rna_viz.obsm[\"X_pca\"]\nadata_rna.obsm[\"X_umap\"] = adata_rna_viz.obsm[\"X_umap\"]\nadata_rna.uns[\"pca\"] = adata_rna_viz.uns[\"pca\"]\nadata_rna.uns[\"neighbors\"] = adata_rna_viz.uns[\"neighbors\"]\nadata_rna.uns[\"umap\"] = adata_rna_viz.uns[\"umap\"]\nadata_rna.obsp[\"distances\"] = adata_rna_viz.obsp[\"distances\"]\nadata_rna.obsp[\"connectivities\"] = adata_rna_viz.obsp[\"connectivities\"]\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# %% Data processing",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.obsm[\"X_umap\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.obsm[\"X_umap\"] = adata_rna_viz.obsm[\"X_umap\"]\nadata_rna.uns[\"pca\"] = adata_rna_viz.uns[\"pca\"]\nadata_rna.uns[\"neighbors\"] = adata_rna_viz.uns[\"neighbors\"]\nadata_rna.uns[\"umap\"] = adata_rna_viz.uns[\"umap\"]\nadata_rna.obsp[\"distances\"] = adata_rna_viz.obsp[\"distances\"]\nadata_rna.obsp[\"connectivities\"] = adata_rna_viz.obsp[\"connectivities\"]\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# %% Data processing\nsns.heatmap(adata_prot.X[:100, :100], linewidths=0)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"pca\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.uns[\"pca\"] = adata_rna_viz.uns[\"pca\"]\nadata_rna.uns[\"neighbors\"] = adata_rna_viz.uns[\"neighbors\"]\nadata_rna.uns[\"umap\"] = adata_rna_viz.uns[\"umap\"]\nadata_rna.obsp[\"distances\"] = adata_rna_viz.obsp[\"distances\"]\nadata_rna.obsp[\"connectivities\"] = adata_rna_viz.obsp[\"connectivities\"]\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# %% Data processing\nsns.heatmap(adata_prot.X[:100, :100], linewidths=0)\n# %% %% Apply Batch Correction to Protein Data AFTER VAE/HV Filtering",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"neighbors\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.uns[\"neighbors\"] = adata_rna_viz.uns[\"neighbors\"]\nadata_rna.uns[\"umap\"] = adata_rna_viz.uns[\"umap\"]\nadata_rna.obsp[\"distances\"] = adata_rna_viz.obsp[\"distances\"]\nadata_rna.obsp[\"connectivities\"] = adata_rna_viz.obsp[\"connectivities\"]\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# %% Data processing\nsns.heatmap(adata_prot.X[:100, :100], linewidths=0)\n# %% %% Apply Batch Correction to Protein Data AFTER VAE/HV Filtering\n# Now that spatial features (neighbor means and COVET) have been added AND VAE/HV filtering applied",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"umap\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.uns[\"umap\"] = adata_rna_viz.uns[\"umap\"]\nadata_rna.obsp[\"distances\"] = adata_rna_viz.obsp[\"distances\"]\nadata_rna.obsp[\"connectivities\"] = adata_rna_viz.obsp[\"connectivities\"]\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# %% Data processing\nsns.heatmap(adata_prot.X[:100, :100], linewidths=0)\n# %% %% Apply Batch Correction to Protein Data AFTER VAE/HV Filtering\n# Now that spatial features (neighbor means and COVET) have been added AND VAE/HV filtering applied\nprint(\"\\\\n=== Applying batch correction to protein data (after VAE/HV filtering) ===\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.obsp[\"distances\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.obsp[\"distances\"] = adata_rna_viz.obsp[\"distances\"]\nadata_rna.obsp[\"connectivities\"] = adata_rna_viz.obsp[\"connectivities\"]\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# %% Data processing\nsns.heatmap(adata_prot.X[:100, :100], linewidths=0)\n# %% %% Apply Batch Correction to Protein Data AFTER VAE/HV Filtering\n# Now that spatial features (neighbor means and COVET) have been added AND VAE/HV filtering applied\nprint(\"\\\\n=== Applying batch correction to protein data (after VAE/HV filtering) ===\")\n# Update the main adata_2_prot to include the highly variable filtered version with spatial features",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.obsp[\"connectivities\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.obsp[\"connectivities\"] = adata_rna_viz.obsp[\"connectivities\"]\nrna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# %% Data processing\nsns.heatmap(adata_prot.X[:100, :100], linewidths=0)\n# %% %% Apply Batch Correction to Protein Data AFTER VAE/HV Filtering\n# Now that spatial features (neighbor means and COVET) have been added AND VAE/HV filtering applied\nprint(\"\\\\n=== Applying batch correction to protein data (after VAE/HV filtering) ===\")\n# Update the main adata_2_prot to include the highly variable filtered version with spatial features\n# Ensure batch column exists",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "rna_archetype_embedding_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "rna_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for RNA archetype analysis\")\n# %% Data processing\nsns.heatmap(adata_prot.X[:100, :100], linewidths=0)\n# %% %% Apply Batch Correction to Protein Data AFTER VAE/HV Filtering\n# Now that spatial features (neighbor means and COVET) have been added AND VAE/HV filtering applied\nprint(\"\\\\n=== Applying batch correction to protein data (after VAE/HV filtering) ===\")\n# Update the main adata_2_prot to include the highly variable filtered version with spatial features\n# Ensure batch column exists\nif \"batch\" not in adata_prot.obs.columns:",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_2_prot_before_batch_correction",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_2_prot_before_batch_correction = adata_prot.copy()\n# # plot adata_2_prot_before_batch_correction\n# sc.pl.umap(\n#     adata_2_prot_before_batch_correction[\n#         adata_2_prot_before_batch_correction.obs[\"batch\"] == \"CONTROL\"\n#     ],\n#     color=\"cell_types\",\n# )\n# Clean data for batch correction compatibility\nprint(\"Cleaning data for batch correction compatibility...\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "nan_count",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "nan_count = np.isnan(adata_prot.X).sum()\ninf_count = np.isinf(adata_prot.X).sum()\nprint(f\"Found {nan_count} NaN values and {inf_count} infinite values\")\n# Replace NaN and infinite values with median (more robust than 0)\nif nan_count > 0 or inf_count > 0:\n    # Use median of finite values for replacement\n    finite_mask = np.isfinite(adata_prot.X)\n    if finite_mask.any():\n        median_val = np.median(adata_prot.X[finite_mask])\n    else:",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "inf_count",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "inf_count = np.isinf(adata_prot.X).sum()\nprint(f\"Found {nan_count} NaN values and {inf_count} infinite values\")\n# Replace NaN and infinite values with median (more robust than 0)\nif nan_count > 0 or inf_count > 0:\n    # Use median of finite values for replacement\n    finite_mask = np.isfinite(adata_prot.X)\n    if finite_mask.any():\n        median_val = np.median(adata_prot.X[finite_mask])\n    else:\n        median_val = 1.0  # fallback to 1 if no finite values",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "min_val",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "min_val = adata_prot.X.min()\nmax_val = adata_prot.X.max()\nprint(f\"Data range before outlier handling: [{min_val:.4f}, {max_val:.4f}]\")\n# Use percentile-based clipping for gentle outlier removal\nq01 = np.percentile(adata_prot.X, 0.1)\nq99 = np.percentile(adata_prot.X, 99.9)\nn_outliers = np.sum((adata_prot.X < q01) | (adata_prot.X > q99))\nif n_outliers > 0:\n    print(f\"Clipping {n_outliers} outliers to [{q01:.4f}, {q99:.4f}] range\")\n    adata_prot.X = np.clip(adata_prot.X, q01, q99)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "max_val",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "max_val = adata_prot.X.max()\nprint(f\"Data range before outlier handling: [{min_val:.4f}, {max_val:.4f}]\")\n# Use percentile-based clipping for gentle outlier removal\nq01 = np.percentile(adata_prot.X, 0.1)\nq99 = np.percentile(adata_prot.X, 99.9)\nn_outliers = np.sum((adata_prot.X < q01) | (adata_prot.X > q99))\nif n_outliers > 0:\n    print(f\"Clipping {n_outliers} outliers to [{q01:.4f}, {q99:.4f}] range\")\n    adata_prot.X = np.clip(adata_prot.X, q01, q99)\n# Ensure all values are positive for batch correction compatibility",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "q01",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "q01 = np.percentile(adata_prot.X, 0.1)\nq99 = np.percentile(adata_prot.X, 99.9)\nn_outliers = np.sum((adata_prot.X < q01) | (adata_prot.X > q99))\nif n_outliers > 0:\n    print(f\"Clipping {n_outliers} outliers to [{q01:.4f}, {q99:.4f}] range\")\n    adata_prot.X = np.clip(adata_prot.X, q01, q99)\n# Ensure all values are positive for batch correction compatibility\nmin_val = adata_prot.X.min()\nif min_val <= 0:\n    shift_val = abs(min_val) + 0.1  # Small positive shift",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "q99",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "q99 = np.percentile(adata_prot.X, 99.9)\nn_outliers = np.sum((adata_prot.X < q01) | (adata_prot.X > q99))\nif n_outliers > 0:\n    print(f\"Clipping {n_outliers} outliers to [{q01:.4f}, {q99:.4f}] range\")\n    adata_prot.X = np.clip(adata_prot.X, q01, q99)\n# Ensure all values are positive for batch correction compatibility\nmin_val = adata_prot.X.min()\nif min_val <= 0:\n    shift_val = abs(min_val) + 0.1  # Small positive shift\n    print(f\"Shifting data by {shift_val:.4f} to ensure positive values\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "n_outliers",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "n_outliers = np.sum((adata_prot.X < q01) | (adata_prot.X > q99))\nif n_outliers > 0:\n    print(f\"Clipping {n_outliers} outliers to [{q01:.4f}, {q99:.4f}] range\")\n    adata_prot.X = np.clip(adata_prot.X, q01, q99)\n# Ensure all values are positive for batch correction compatibility\nmin_val = adata_prot.X.min()\nif min_val <= 0:\n    shift_val = abs(min_val) + 0.1  # Small positive shift\n    print(f\"Shifting data by {shift_val:.4f} to ensure positive values\")\n    adata_prot.X = adata_prot.X + shift_val",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "min_val",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "min_val = adata_prot.X.min()\nif min_val <= 0:\n    shift_val = abs(min_val) + 0.1  # Small positive shift\n    print(f\"Shifting data by {shift_val:.4f} to ensure positive values\")\n    adata_prot.X = adata_prot.X + shift_val\n# Conservative scaling to avoid numerical issues\n# Scale to a more modest range [1, 10] instead of [0, 1000]\nmin_val = adata_prot.X.min()\nmax_val = adata_prot.X.max()\nprint(f\"Data range before scaling: [{min_val:.4f}, {max_val:.4f}]\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "min_val",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "min_val = adata_prot.X.min()\nmax_val = adata_prot.X.max()\nprint(f\"Data range before scaling: [{min_val:.4f}, {max_val:.4f}]\")\nif max_val > min_val:\n    # Conservative scaling to [1, 10] range\n    target_min, target_max = 1.0, 10.0\n    scale_factor = (target_max - target_min) / (max_val - min_val)\n    adata_prot.X = (adata_prot.X - min_val) * scale_factor + target_min\n    print(f\"Scaled data to range [{target_min}, {target_max}]\")\n    # Re-apply scaling to non-protein features after rescaling to maintain relative weights",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "max_val",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "max_val = adata_prot.X.max()\nprint(f\"Data range before scaling: [{min_val:.4f}, {max_val:.4f}]\")\nif max_val > min_val:\n    # Conservative scaling to [1, 10] range\n    target_min, target_max = 1.0, 10.0\n    scale_factor = (target_max - target_min) / (max_val - min_val)\n    adata_prot.X = (adata_prot.X - min_val) * scale_factor + target_min\n    print(f\"Scaled data to range [{target_min}, {target_max}]\")\n    # Re-apply scaling to non-protein features after rescaling to maintain relative weights\n    num_total_features = adata_prot.X.shape[1]",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "protein_archetype_embedding_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "protein_archetype_embedding_name = \"X_pca\"\nprint(\"Using X_pca embedding for protein archetype analysis\")\n# %% Plotting\npp_plots.plot_feature_type_heatmap(adata_prot, plot_flag)\n# %% Extract protein data\nif issparse(adata_prot.X):\n    protein_data = adata_prot.X.toarray()\nelse:\n    protein_data = adata_prot.X.copy()\n# Get neighborhood statistics",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "minor_cell_types_list_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "minor_cell_types_list_prot = sorted(list(set(adata_prot.obs[\"cell_types\"])))\nmajor_cell_types_list_prot = sorted(list(set(adata_prot.obs[\"major_cell_types\"])))\nmajor_cell_types_list_rna = sorted(list(set(adata_rna.obs[\"major_cell_types\"])))\nminor_cell_types_list_rna = sorted(list(set(adata_rna.obs[\"cell_types\"])))\n# Compute PCA and UMAP for both modalities\nsc.pp.pca(adata_rna)\nsc.pp.neighbors(adata_rna, use_rep=rna_archetype_embedding_name)\nsc.tl.umap(adata_rna)\nsc.pp.pca(adata_prot)\nsc.pp.neighbors(adata_prot, use_rep=protein_archetype_embedding_name)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "major_cell_types_list_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "major_cell_types_list_prot = sorted(list(set(adata_prot.obs[\"major_cell_types\"])))\nmajor_cell_types_list_rna = sorted(list(set(adata_rna.obs[\"major_cell_types\"])))\nminor_cell_types_list_rna = sorted(list(set(adata_rna.obs[\"cell_types\"])))\n# Compute PCA and UMAP for both modalities\nsc.pp.pca(adata_rna)\nsc.pp.neighbors(adata_rna, use_rep=rna_archetype_embedding_name)\nsc.tl.umap(adata_rna)\nsc.pp.pca(adata_prot)\nsc.pp.neighbors(adata_prot, use_rep=protein_archetype_embedding_name)\nsc.tl.umap(adata_prot)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "major_cell_types_list_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "major_cell_types_list_rna = sorted(list(set(adata_rna.obs[\"major_cell_types\"])))\nminor_cell_types_list_rna = sorted(list(set(adata_rna.obs[\"cell_types\"])))\n# Compute PCA and UMAP for both modalities\nsc.pp.pca(adata_rna)\nsc.pp.neighbors(adata_rna, use_rep=rna_archetype_embedding_name)\nsc.tl.umap(adata_rna)\nsc.pp.pca(adata_prot)\nsc.pp.neighbors(adata_prot, use_rep=protein_archetype_embedding_name)\nsc.tl.umap(adata_prot)\n# pp_plots.plot_modality_embeddings(adata_1_rna, adata_2_prot)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "minor_cell_types_list_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "minor_cell_types_list_rna = sorted(list(set(adata_rna.obs[\"cell_types\"])))\n# Compute PCA and UMAP for both modalities\nsc.pp.pca(adata_rna)\nsc.pp.neighbors(adata_rna, use_rep=rna_archetype_embedding_name)\nsc.tl.umap(adata_rna)\nsc.pp.pca(adata_prot)\nsc.pp.neighbors(adata_prot, use_rep=protein_archetype_embedding_name)\nsc.tl.umap(adata_prot)\n# pp_plots.plot_modality_embeddings(adata_1_rna, adata_2_prot)\n# pp_plots.plot_original_embeddings(adata_1_rna, adata_2_prot)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "cell_type_colors",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "cell_type_colors = set_consistent_cell_type_colors(adata_rna, adata_prot)\n# %% Compute PCA Dimensions\nprint(\"\\nComputing PCA dimensions...\")\nmax_possible_pca_dim_rna = min(adata_rna.X.shape[1], adata_rna.X.shape[0])\nmax_possible_pca_dim_rna = min(max_possible_pca_dim_rna, 80)\nsc.pp.pca(adata_rna, n_comps=max_possible_pca_dim_rna - 1)\nmax_possible_pca_dim_prot = min(adata_prot.X.shape[1], adata_prot.X.shape[0])\nif \"highly_variable\" in adata_prot.var.keys():\n    max_possible_pca_dim_prot = min(\n        max_possible_pca_dim_prot, adata_prot.var[\"highly_variable\"].sum() - 1",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "max_possible_pca_dim_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "max_possible_pca_dim_rna = min(adata_rna.X.shape[1], adata_rna.X.shape[0])\nmax_possible_pca_dim_rna = min(max_possible_pca_dim_rna, 80)\nsc.pp.pca(adata_rna, n_comps=max_possible_pca_dim_rna - 1)\nmax_possible_pca_dim_prot = min(adata_prot.X.shape[1], adata_prot.X.shape[0])\nif \"highly_variable\" in adata_prot.var.keys():\n    max_possible_pca_dim_prot = min(\n        max_possible_pca_dim_prot, adata_prot.var[\"highly_variable\"].sum() - 1\n    )\n    max_possible_pca_dim_prot = min(max_possible_pca_dim_prot, 80)\nsc.pp.pca(adata_prot, n_comps=max_possible_pca_dim_prot - 1)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "max_possible_pca_dim_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "max_possible_pca_dim_rna = min(max_possible_pca_dim_rna, 80)\nsc.pp.pca(adata_rna, n_comps=max_possible_pca_dim_rna - 1)\nmax_possible_pca_dim_prot = min(adata_prot.X.shape[1], adata_prot.X.shape[0])\nif \"highly_variable\" in adata_prot.var.keys():\n    max_possible_pca_dim_prot = min(\n        max_possible_pca_dim_prot, adata_prot.var[\"highly_variable\"].sum() - 1\n    )\n    max_possible_pca_dim_prot = min(max_possible_pca_dim_prot, 80)\nsc.pp.pca(adata_prot, n_comps=max_possible_pca_dim_prot - 1)\n# %% Select PCA components based on variance explained",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "max_possible_pca_dim_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "max_possible_pca_dim_prot = min(adata_prot.X.shape[1], adata_prot.X.shape[0])\nif \"highly_variable\" in adata_prot.var.keys():\n    max_possible_pca_dim_prot = min(\n        max_possible_pca_dim_prot, adata_prot.var[\"highly_variable\"].sum() - 1\n    )\n    max_possible_pca_dim_prot = min(max_possible_pca_dim_prot, 80)\nsc.pp.pca(adata_prot, n_comps=max_possible_pca_dim_prot - 1)\n# %% Select PCA components based on variance explained\nprint(\"Selecting PCA components...\")\nmax_dim = 50",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "max_dim",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "max_dim = 50\nvariance_ratio_selected = 0.80\ncumulative_variance_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])\nvariance_ratio_selected = min(cumulative_variance_ratio[[-1]], variance_ratio_selected)\nn_comps_thresh_rna = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_rna = min(n_comps_thresh_rna, max_dim)\nif n_comps_thresh_rna == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "variance_ratio_selected",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "variance_ratio_selected = 0.80\ncumulative_variance_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])\nvariance_ratio_selected = min(cumulative_variance_ratio[[-1]], variance_ratio_selected)\nn_comps_thresh_rna = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_rna = min(n_comps_thresh_rna, max_dim)\nif n_comps_thresh_rna == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )\nreal_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_rna]",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "cumulative_variance_ratio",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "cumulative_variance_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])\nvariance_ratio_selected = min(cumulative_variance_ratio[[-1]], variance_ratio_selected)\nn_comps_thresh_rna = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_rna = min(n_comps_thresh_rna, max_dim)\nif n_comps_thresh_rna == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )\nreal_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_rna]\nsc.pp.pca(adata_rna, n_comps=n_comps_thresh_rna)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "variance_ratio_selected",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "variance_ratio_selected = min(cumulative_variance_ratio[[-1]], variance_ratio_selected)\nn_comps_thresh_rna = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_rna = min(n_comps_thresh_rna, max_dim)\nif n_comps_thresh_rna == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )\nreal_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_rna]\nsc.pp.pca(adata_rna, n_comps=n_comps_thresh_rna)\nprint(f\"\\nNumber of components explaining {real_ratio} of rna variance: {n_comps_thresh_rna}\\n\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "n_comps_thresh_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "n_comps_thresh_rna = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_rna = min(n_comps_thresh_rna, max_dim)\nif n_comps_thresh_rna == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )\nreal_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_rna]\nsc.pp.pca(adata_rna, n_comps=n_comps_thresh_rna)\nprint(f\"\\nNumber of components explaining {real_ratio} of rna variance: {n_comps_thresh_rna}\\n\")\ncumulative_variance_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "n_comps_thresh_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "n_comps_thresh_rna = min(n_comps_thresh_rna, max_dim)\nif n_comps_thresh_rna == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )\nreal_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_rna]\nsc.pp.pca(adata_rna, n_comps=n_comps_thresh_rna)\nprint(f\"\\nNumber of components explaining {real_ratio} of rna variance: {n_comps_thresh_rna}\\n\")\ncumulative_variance_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])\nvariance_ratio_selected = min(cumulative_variance_ratio[[-1]], variance_ratio_selected)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "real_ratio",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "real_ratio = np.cumsum(adata_rna.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_rna]\nsc.pp.pca(adata_rna, n_comps=n_comps_thresh_rna)\nprint(f\"\\nNumber of components explaining {real_ratio} of rna variance: {n_comps_thresh_rna}\\n\")\ncumulative_variance_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])\nvariance_ratio_selected = min(cumulative_variance_ratio[[-1]], variance_ratio_selected)\nn_comps_thresh_prot = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_prot = min(n_comps_thresh_prot, max_dim)\nreal_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_prot]\nsc.pp.pca(adata_prot, n_comps=n_comps_thresh_prot)\nprint(f\"\\nNumber of components explaining {real_ratio} of protein variance: {n_comps_thresh_prot}\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "cumulative_variance_ratio",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "cumulative_variance_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])\nvariance_ratio_selected = min(cumulative_variance_ratio[[-1]], variance_ratio_selected)\nn_comps_thresh_prot = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_prot = min(n_comps_thresh_prot, max_dim)\nreal_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_prot]\nsc.pp.pca(adata_prot, n_comps=n_comps_thresh_prot)\nprint(f\"\\nNumber of components explaining {real_ratio} of protein variance: {n_comps_thresh_prot}\")\nif n_comps_thresh_prot == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "variance_ratio_selected",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "variance_ratio_selected = min(cumulative_variance_ratio[[-1]], variance_ratio_selected)\nn_comps_thresh_prot = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_prot = min(n_comps_thresh_prot, max_dim)\nreal_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_prot]\nsc.pp.pca(adata_prot, n_comps=n_comps_thresh_prot)\nprint(f\"\\nNumber of components explaining {real_ratio} of protein variance: {n_comps_thresh_prot}\")\nif n_comps_thresh_prot == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "n_comps_thresh_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "n_comps_thresh_prot = np.argmax(cumulative_variance_ratio >= variance_ratio_selected) + 1\nn_comps_thresh_prot = min(n_comps_thresh_prot, max_dim)\nreal_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_prot]\nsc.pp.pca(adata_prot, n_comps=n_comps_thresh_prot)\nprint(f\"\\nNumber of components explaining {real_ratio} of protein variance: {n_comps_thresh_prot}\")\nif n_comps_thresh_prot == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )\n# %% plot umap of original protein data and the umap to new protein data",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "n_comps_thresh_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "n_comps_thresh_prot = min(n_comps_thresh_prot, max_dim)\nreal_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_prot]\nsc.pp.pca(adata_prot, n_comps=n_comps_thresh_prot)\nprint(f\"\\nNumber of components explaining {real_ratio} of protein variance: {n_comps_thresh_prot}\")\nif n_comps_thresh_prot == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )\n# %% plot umap of original protein data and the umap to new protein data\nsc.pp.neighbors(",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "real_ratio",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "real_ratio = np.cumsum(adata_prot.uns[\"pca\"][\"variance_ratio\"])[n_comps_thresh_prot]\nsc.pp.pca(adata_prot, n_comps=n_comps_thresh_prot)\nprint(f\"\\nNumber of components explaining {real_ratio} of protein variance: {n_comps_thresh_prot}\")\nif n_comps_thresh_prot == 1:\n    raise ValueError(\n        \"n_comps_thresh is 1, this is not good, try to lower the variance_ratio_selected\"\n    )\n# %% plot umap of original protein data and the umap to new protein data\nsc.pp.neighbors(\n    adata_prot,",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "min_k",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "min_k = 7\nmax_k = 13  # 17\nstep_size = 1\nconverge = 1e-5\nprint(\"\\n\" + \"=\" * 80)\nprint(\"BATCH-AWARE ARCHETYPE GENERATION\")\nprint(\"=\" * 80)\nprint(\"Using batch-aware archetype generation for consistent representation.\")\nprint(\"This approach:\")\nprint(\"1. Generates archetypes separately for each batch to account for batch differences\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "max_k",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "max_k = 13  # 17\nstep_size = 1\nconverge = 1e-5\nprint(\"\\n\" + \"=\" * 80)\nprint(\"BATCH-AWARE ARCHETYPE GENERATION\")\nprint(\"=\" * 80)\nprint(\"Using batch-aware archetype generation for consistent representation.\")\nprint(\"This approach:\")\nprint(\"1. Generates archetypes separately for each batch to account for batch differences\")\nprint(\"2. Matches archetypes within modalities using cell type proportions\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "step_size",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "step_size = 1\nconverge = 1e-5\nprint(\"\\n\" + \"=\" * 80)\nprint(\"BATCH-AWARE ARCHETYPE GENERATION\")\nprint(\"=\" * 80)\nprint(\"Using batch-aware archetype generation for consistent representation.\")\nprint(\"This approach:\")\nprint(\"1. Generates archetypes separately for each batch to account for batch differences\")\nprint(\"2. Matches archetypes within modalities using cell type proportions\")\nprint(\"3. Creates unified archetype coordinate system across batches\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "converge",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "converge = 1e-5\nprint(\"\\n\" + \"=\" * 80)\nprint(\"BATCH-AWARE ARCHETYPE GENERATION\")\nprint(\"=\" * 80)\nprint(\"Using batch-aware archetype generation for consistent representation.\")\nprint(\"This approach:\")\nprint(\"1. Generates archetypes separately for each batch to account for batch differences\")\nprint(\"2. Matches archetypes within modalities using cell type proportions\")\nprint(\"3. Creates unified archetype coordinate system across batches\")\nprint(\"4. Finds optimal k that works across all modalities and batches\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "rna_archetypes",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "rna_archetypes = adata_rna.obsm[\"archetype_vec\"]\nprot_archetypes = adata_prot.obsm[\"archetype_vec\"]\nprint(f\"RNA archetype vectors shape: {rna_archetypes.shape}\")\nprint(f\"Protein archetype vectors shape: {prot_archetypes.shape}\")\n# Calculate cosine distance similarity matrix for cross-modal matching\nsimilarity_matrix = cosine_distances(rna_archetypes, prot_archetypes)\n# Find best matches in both directions\nrna_to_prot_matches = np.argmin(similarity_matrix, axis=1)\nprot_to_rna_matches = np.argmin(similarity_matrix, axis=0)\n# Add matches to observation dataframes",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "prot_archetypes",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "prot_archetypes = adata_prot.obsm[\"archetype_vec\"]\nprint(f\"RNA archetype vectors shape: {rna_archetypes.shape}\")\nprint(f\"Protein archetype vectors shape: {prot_archetypes.shape}\")\n# Calculate cosine distance similarity matrix for cross-modal matching\nsimilarity_matrix = cosine_distances(rna_archetypes, prot_archetypes)\n# Find best matches in both directions\nrna_to_prot_matches = np.argmin(similarity_matrix, axis=1)\nprot_to_rna_matches = np.argmin(similarity_matrix, axis=0)\n# Add matches to observation dataframes\nadata_rna.obs[\"matching_prot_index\"] = adata_prot.obs.index[rna_to_prot_matches]",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "similarity_matrix",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "similarity_matrix = cosine_distances(rna_archetypes, prot_archetypes)\n# Find best matches in both directions\nrna_to_prot_matches = np.argmin(similarity_matrix, axis=1)\nprot_to_rna_matches = np.argmin(similarity_matrix, axis=0)\n# Add matches to observation dataframes\nadata_rna.obs[\"matching_prot_index\"] = adata_prot.obs.index[rna_to_prot_matches]\nadata_prot.obs[\"matching_rna_index\"] = adata_rna.obs.index[prot_to_rna_matches]\n# Update cross-modal matching metadata - handled by finalize function\nprint(f\"Cross-modal matching completed.\")\nprint(f\"Average cross-modal distance: {similarity_matrix.min(axis=1).mean():.4f}\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "rna_to_prot_matches",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "rna_to_prot_matches = np.argmin(similarity_matrix, axis=1)\nprot_to_rna_matches = np.argmin(similarity_matrix, axis=0)\n# Add matches to observation dataframes\nadata_rna.obs[\"matching_prot_index\"] = adata_prot.obs.index[rna_to_prot_matches]\nadata_prot.obs[\"matching_rna_index\"] = adata_rna.obs.index[prot_to_rna_matches]\n# Update cross-modal matching metadata - handled by finalize function\nprint(f\"Cross-modal matching completed.\")\nprint(f\"Average cross-modal distance: {similarity_matrix.min(axis=1).mean():.4f}\")\n# Check if we have the same cell types between modalities\ncommon_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "prot_to_rna_matches",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "prot_to_rna_matches = np.argmin(similarity_matrix, axis=0)\n# Add matches to observation dataframes\nadata_rna.obs[\"matching_prot_index\"] = adata_prot.obs.index[rna_to_prot_matches]\nadata_prot.obs[\"matching_rna_index\"] = adata_rna.obs.index[prot_to_rna_matches]\n# Update cross-modal matching metadata - handled by finalize function\nprint(f\"Cross-modal matching completed.\")\nprint(f\"Average cross-modal distance: {similarity_matrix.min(axis=1).mean():.4f}\")\n# Check if we have the same cell types between modalities\ncommon_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types between modalities: {len(common_cell_types)}\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"matching_prot_index\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_rna.obs[\"matching_prot_index\"] = adata_prot.obs.index[rna_to_prot_matches]\nadata_prot.obs[\"matching_rna_index\"] = adata_rna.obs.index[prot_to_rna_matches]\n# Update cross-modal matching metadata - handled by finalize function\nprint(f\"Cross-modal matching completed.\")\nprint(f\"Average cross-modal distance: {similarity_matrix.min(axis=1).mean():.4f}\")\n# Check if we have the same cell types between modalities\ncommon_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types between modalities: {len(common_cell_types)}\")\nif len(common_cell_types) < len(set(adata_rna.obs[\"cell_types\"])):\n    print(\"Warning: Not all cell types are common between modalities\")",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"matching_rna_index\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "adata_prot.obs[\"matching_rna_index\"] = adata_rna.obs.index[prot_to_rna_matches]\n# Update cross-modal matching metadata - handled by finalize function\nprint(f\"Cross-modal matching completed.\")\nprint(f\"Average cross-modal distance: {similarity_matrix.min(axis=1).mean():.4f}\")\n# Check if we have the same cell types between modalities\ncommon_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types between modalities: {len(common_cell_types)}\")\nif len(common_cell_types) < len(set(adata_rna.obs[\"cell_types\"])):\n    print(\"Warning: Not all cell types are common between modalities\")\n# %% Extreme Archetype Identification",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "common_cell_types",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "common_cell_types = set(adata_rna.obs[\"cell_types\"]) & set(adata_prot.obs[\"cell_types\"])\nprint(f\"Common cell types between modalities: {len(common_cell_types)}\")\nif len(common_cell_types) < len(set(adata_rna.obs[\"cell_types\"])):\n    print(\"Warning: Not all cell types are common between modalities\")\n# %% Extreme Archetype Identification\n# Note: Extreme archetypes are already identified in the batch-specific analysis\n# This section provides additional validation and cross-modal comparison\nrna_extreme_mask = adata_rna.obs[\"is_extreme_archetype\"].values\nprot_extreme_mask = adata_prot.obs[\"is_extreme_archetype\"].values\nprint(",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "rna_extreme_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "rna_extreme_mask = adata_rna.obs[\"is_extreme_archetype\"].values\nprot_extreme_mask = adata_prot.obs[\"is_extreme_archetype\"].values\nprint(\n    f\"RNA extreme archetypes: {rna_extreme_mask.sum()} ({rna_extreme_mask.sum()/len(adata_rna)*100:.1f}%)\"\n)\nprint(\n    f\"Protein extreme archetypes: {prot_extreme_mask.sum()} ({prot_extreme_mask.sum()/len(adata_prot)*100:.1f}%)\"\n)\n# Validate extreme archetypes matching across modalities\nvalidate_extreme_archetypes_matching(adata_rna, adata_prot)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "prot_extreme_mask",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "prot_extreme_mask = adata_prot.obs[\"is_extreme_archetype\"].values\nprint(\n    f\"RNA extreme archetypes: {rna_extreme_mask.sum()} ({rna_extreme_mask.sum()/len(adata_rna)*100:.1f}%)\"\n)\nprint(\n    f\"Protein extreme archetypes: {prot_extreme_mask.sum()} ({prot_extreme_mask.sum()/len(adata_prot)*100:.1f}%)\"\n)\n# Validate extreme archetypes matching across modalities\nvalidate_extreme_archetypes_matching(adata_rna, adata_prot)\nif plot_flag:",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "cells_archetype_vec_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "cells_archetype_vec_rna = adata_rna.obsm[\"archetype_vec\"].values\ncells_archetype_vec_prot = adata_prot.obsm[\"archetype_vec\"].values\n# Evaluate distance metrics\nmetrics = [\"euclidean\", \"cityblock\", \"cosine\", \"correlation\", \"chebyshev\"]\nevaluate_distance_metrics(cells_archetype_vec_rna, cells_archetype_vec_prot, metrics)\n# %% Cross-Modal Archetype Matching Visualizations\nif plot_flag:\n    print(\"\\n\" + \"=\" * 60)\n    print(\"CROSS-MODAL ARCHETYPE MATCHING VISUALIZATIONS\")\n    print(\"=\" * 60)",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "cells_archetype_vec_prot",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "cells_archetype_vec_prot = adata_prot.obsm[\"archetype_vec\"].values\n# Evaluate distance metrics\nmetrics = [\"euclidean\", \"cityblock\", \"cosine\", \"correlation\", \"chebyshev\"]\nevaluate_distance_metrics(cells_archetype_vec_rna, cells_archetype_vec_prot, metrics)\n# %% Cross-Modal Archetype Matching Visualizations\nif plot_flag:\n    print(\"\\n\" + \"=\" * 60)\n    print(\"CROSS-MODAL ARCHETYPE MATCHING VISUALIZATIONS\")\n    print(\"=\" * 60)\n    # Note: Individual batch visualizations were shown earlier",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "metrics",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "metrics = [\"euclidean\", \"cityblock\", \"cosine\", \"correlation\", \"chebyshev\"]\nevaluate_distance_metrics(cells_archetype_vec_rna, cells_archetype_vec_prot, metrics)\n# %% Cross-Modal Archetype Matching Visualizations\nif plot_flag:\n    print(\"\\n\" + \"=\" * 60)\n    print(\"CROSS-MODAL ARCHETYPE MATCHING VISUALIZATIONS\")\n    print(\"=\" * 60)\n    # Note: Individual batch visualizations were shown earlier\n    # Here we focus on cross-modal matching and overall validation\n    # Plot cross-modal archetype similarity matrix",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "pca_params",
        "kind": 5,
        "importPath": "ARCADIA.scripts._3_generate_archetypes",
        "description": "ARCADIA.scripts._3_generate_archetypes",
        "peekOfCode": "pca_params = {\n    \"variance_ratio_selected\": 0.80,  # Update this with actual value from script\n    \"n_comps_rna\": adata_rna.obsm[\"X_pca\"].shape[1] if \"X_pca\" in adata_rna.obsm else None,\n}\npipeline_metadata_utils.finalize_archetype_generation_metadata(\n    adata_rna, adata_prot, similarity_matrix, rna_to_prot_matches, prot_to_rna_matches, pca_params\n)\nsave_processed_data(\n    adata_rna,\n    adata_prot,",
        "detail": "ARCADIA.scripts._3_generate_archetypes",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "dataset_name = None\n# %% Set the filename for this script\nFILENAME = \"_4_prepare_training.py\"\nimport numpy as np\nimport pandas as pd\nimport scipy.sparse as sp\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\nfrom arcadia.utils.paths import here",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "FILENAME = \"_4_prepare_training.py\"\nimport numpy as np\nimport pandas as pd\nimport scipy.sparse as sp\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\nfrom arcadia.utils.paths import here\nif here().parent.name == \"notebooks\":\n    os.chdir(\"../../\")",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "config_path = Path(\"configs/config.json\")\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "device = setup_environment()\n# %% Parse command line arguments\ntry:\n    args = parse_pipeline_arguments()\n    if args.dataset_name is not None:\n        dataset_name = args.dataset_name\nexcept SystemExit:\n    pass\nprint(f\"Selected dataset: {dataset_name if dataset_name else 'default (latest)'}\")\n# %% Load data",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "spatial_only",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "spatial_only = adata_prot[:, adata_prot.var[\"feature_type\"] != \"protein\"]\nif spatial_only.n_vars > 0 and spatial_only.n_obs > 0:\n    # Subsample FIRST before any processing to prevent memory issues\n    if spatial_only.n_obs > 5000:\n        sc.pp.subsample(spatial_only, n_obs=5000)\n    sc.pp.pca(spatial_only)\n    sc.pp.neighbors(spatial_only)\n    sc.tl.umap(spatial_only)\n    if \"CN\" in spatial_only.obs.columns:\n        sc.pl.umap(spatial_only, color=\"CN\")",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "archetype_distances",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "archetype_distances = compute_archetype_distances(adata_rna, adata_prot)\nmatching_distance_before = np.diag(archetype_distances).mean()\n# %% Plot archetype heatmaps\nif plot_flag:\n    plot_archetype_heatmaps(adata_rna, adata_prot)\n# %% Find closest protein cells for each RNA cell\nbatch_size = 1000\nn_rna = adata_rna.shape[0]\nclosest_prot_indices = np.zeros(n_rna, dtype=int)\nfor i in range(0, n_rna, batch_size):",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "matching_distance_before",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "matching_distance_before = np.diag(archetype_distances).mean()\n# %% Plot archetype heatmaps\nif plot_flag:\n    plot_archetype_heatmaps(adata_rna, adata_prot)\n# %% Find closest protein cells for each RNA cell\nbatch_size = 1000\nn_rna = adata_rna.shape[0]\nclosest_prot_indices = np.zeros(n_rna, dtype=int)\nfor i in range(0, n_rna, batch_size):\n    end_idx = min(i + batch_size, n_rna)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "batch_size",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "batch_size = 1000\nn_rna = adata_rna.shape[0]\nclosest_prot_indices = np.zeros(n_rna, dtype=int)\nfor i in range(0, n_rna, batch_size):\n    end_idx = min(i + batch_size, n_rna)\n    batch_dist = scipy.spatial.distance.cdist(\n        adata_rna.obsm[\"archetype_vec\"][i:end_idx],\n        adata_prot.obsm[\"archetype_vec\"],\n        metric=\"cosine\",\n    )",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "n_rna",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "n_rna = adata_rna.shape[0]\nclosest_prot_indices = np.zeros(n_rna, dtype=int)\nfor i in range(0, n_rna, batch_size):\n    end_idx = min(i + batch_size, n_rna)\n    batch_dist = scipy.spatial.distance.cdist(\n        adata_rna.obsm[\"archetype_vec\"][i:end_idx],\n        adata_prot.obsm[\"archetype_vec\"],\n        metric=\"cosine\",\n    )\n    closest_prot_indices[i:end_idx] = np.argmin(batch_dist, axis=1)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "closest_prot_indices",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "closest_prot_indices = np.zeros(n_rna, dtype=int)\nfor i in range(0, n_rna, batch_size):\n    end_idx = min(i + batch_size, n_rna)\n    batch_dist = scipy.spatial.distance.cdist(\n        adata_rna.obsm[\"archetype_vec\"][i:end_idx],\n        adata_prot.obsm[\"archetype_vec\"],\n        metric=\"cosine\",\n    )\n    closest_prot_indices[i:end_idx] = np.argmin(batch_dist, axis=1)\n    print(f\"Processed batch {i//batch_size + 1}/{(n_rna-1)//batch_size + 1}\", end=\"\\r\")",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"CN\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_rna.obs[\"CN\"] = adata_prot.obs[\"CN\"].values[closest_prot_indices]\nadata_rna.obs[\"CN\"] = adata_rna.obs[\"CN\"].cat.set_categories(adata_prot.obs[\"CN\"].cat.categories)\nprint(f\"Number of CN in RNA data: {len(adata_rna.obs['CN'].unique())}\")\nprint(f\"Number of CN in protein data: {len(adata_prot.obs['CN'].unique())}\")\n# Compute PCA and UMAP\nadata_rna, adata_prot = compute_pca_and_umap(adata_rna, adata_prot)\n# Additional visualizations\nif plot_flag:\n    plot_umap_visualizations_original_data(adata_rna, adata_prot)\n    plot_pca_and_umap(adata_rna, adata_prot)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"CN\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_rna.obs[\"CN\"] = adata_rna.obs[\"CN\"].cat.set_categories(adata_prot.obs[\"CN\"].cat.categories)\nprint(f\"Number of CN in RNA data: {len(adata_rna.obs['CN'].unique())}\")\nprint(f\"Number of CN in protein data: {len(adata_prot.obs['CN'].unique())}\")\n# Compute PCA and UMAP\nadata_rna, adata_prot = compute_pca_and_umap(adata_rna, adata_prot)\n# Additional visualizations\nif plot_flag:\n    plot_umap_visualizations_original_data(adata_rna, adata_prot)\n    plot_pca_and_umap(adata_rna, adata_prot)\n    plot_b_cells_analysis(adata_rna)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "rna_layer",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "rna_layer = \"counts\" if \"counts\" in adata_rna.layers else None\nprot_layer = \"counts\" if \"counts\" in adata_prot.layers else None\nadata_rna.uns[\"gene_likelihood\"] = select_gene_likelihood(\n    adata_rna, modality=\"RNA\", n_sample_genes=300, use_autozi=False, layer=rna_layer\n)\nadata_prot.uns[\"gene_likelihood\"] = select_gene_likelihood(\n    adata_prot, modality=\"Protein\", n_sample_genes=300, use_autozi=False, layer=prot_layer\n)\nlikelihood_to_function = {\n    \"zinb\": simulate_counts_zero_inflated,",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "prot_layer",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "prot_layer = \"counts\" if \"counts\" in adata_prot.layers else None\nadata_rna.uns[\"gene_likelihood\"] = select_gene_likelihood(\n    adata_rna, modality=\"RNA\", n_sample_genes=300, use_autozi=False, layer=rna_layer\n)\nadata_prot.uns[\"gene_likelihood\"] = select_gene_likelihood(\n    adata_prot, modality=\"Protein\", n_sample_genes=300, use_autozi=False, layer=prot_layer\n)\nlikelihood_to_function = {\n    \"zinb\": simulate_counts_zero_inflated,\n    \"normal\": transfer_to_integer_range_normal,",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"gene_likelihood\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_rna.uns[\"gene_likelihood\"] = select_gene_likelihood(\n    adata_rna, modality=\"RNA\", n_sample_genes=300, use_autozi=False, layer=rna_layer\n)\nadata_prot.uns[\"gene_likelihood\"] = select_gene_likelihood(\n    adata_prot, modality=\"Protein\", n_sample_genes=300, use_autozi=False, layer=prot_layer\n)\nlikelihood_to_function = {\n    \"zinb\": simulate_counts_zero_inflated,\n    \"normal\": transfer_to_integer_range_normal,\n    \"nb\": partial(transfer_to_integer_range_nb, plot_flag=plot_flag),",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"gene_likelihood\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_prot.uns[\"gene_likelihood\"] = select_gene_likelihood(\n    adata_prot, modality=\"Protein\", n_sample_genes=300, use_autozi=False, layer=prot_layer\n)\nlikelihood_to_function = {\n    \"zinb\": simulate_counts_zero_inflated,\n    \"normal\": transfer_to_integer_range_normal,\n    \"nb\": partial(transfer_to_integer_range_nb, plot_flag=plot_flag),\n}\nif adata_rna.uns[\"gene_likelihood\"] not in [\"zinb\", \"nb\", \"normal\"]:\n    raise ValueError(",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "likelihood_to_function",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "likelihood_to_function = {\n    \"zinb\": simulate_counts_zero_inflated,\n    \"normal\": transfer_to_integer_range_normal,\n    \"nb\": partial(transfer_to_integer_range_nb, plot_flag=plot_flag),\n}\nif adata_rna.uns[\"gene_likelihood\"] not in [\"zinb\", \"nb\", \"normal\"]:\n    raise ValueError(\n        f\"Gene likelihood {adata_rna.uns['gene_likelihood']} make sure there is no error in preprocessing\"\n    )\nif adata_prot.uns[\"gene_likelihood\"] not in [\"normal\", \"nb\"]:",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "temp_indices",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "temp_indices = np.random.choice(adata_prot.n_obs, min(2000, adata_prot.n_obs), replace=False)\ntemp_indices.sort()\nadata_prot_temp = adata_prot[temp_indices, :].copy()\nspatial_only = adata_prot_temp[:, adata_prot_temp.var[\"feature_type\"] != \"protein\"].copy()\nprint(f\"Number of cells in spatial_only: {spatial_only.n_obs}\")\ndel adata_prot_temp\ngc.collect()\nfrom arcadia.plotting.preprocessing import plot_spatial_only_umap\nplot_spatial_only_umap(spatial_only, color_key=\"CN\", plot_flag=plot_flag)\nadata_rna_subset_copy = adata_rna.copy()",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_prot_temp",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_prot_temp = adata_prot[temp_indices, :].copy()\nspatial_only = adata_prot_temp[:, adata_prot_temp.var[\"feature_type\"] != \"protein\"].copy()\nprint(f\"Number of cells in spatial_only: {spatial_only.n_obs}\")\ndel adata_prot_temp\ngc.collect()\nfrom arcadia.plotting.preprocessing import plot_spatial_only_umap\nplot_spatial_only_umap(spatial_only, color_key=\"CN\", plot_flag=plot_flag)\nadata_rna_subset_copy = adata_rna.copy()\nadata_prot_subset_copy = adata_prot.copy()\n# %% Create spatial-only subset (2nd time)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "spatial_only",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "spatial_only = adata_prot_temp[:, adata_prot_temp.var[\"feature_type\"] != \"protein\"].copy()\nprint(f\"Number of cells in spatial_only: {spatial_only.n_obs}\")\ndel adata_prot_temp\ngc.collect()\nfrom arcadia.plotting.preprocessing import plot_spatial_only_umap\nplot_spatial_only_umap(spatial_only, color_key=\"CN\", plot_flag=plot_flag)\nadata_rna_subset_copy = adata_rna.copy()\nadata_prot_subset_copy = adata_prot.copy()\n# %% Create spatial-only subset (2nd time)\nprint(\"DEBUG: About to create spatial_only (2nd time)\")",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_rna_subset_copy",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_rna_subset_copy = adata_rna.copy()\nadata_prot_subset_copy = adata_prot.copy()\n# %% Create spatial-only subset (2nd time)\nprint(\"DEBUG: About to create spatial_only (2nd time)\")\n# First create a t Creating temp subsampled adata_prot from {adata_prot.n_obs} to 2000 cells\")\ntemp_indices = np.random.choice(adata_prot.n_obs, min(2000, adata_prot.n_obs), replace=False)\ntemp_indices.sort()\nadata_prot_temp = adata_prot[temp_indices, :].copy()\nspatial_only = adata_prot_temp[:, adata_prot_temp.var[\"feature_type\"] != \"protein\"].copy()\nprint(f\"Number of cells in spatial_only: {spatial_only.n_obs}\")",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_prot_subset_copy",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_prot_subset_copy = adata_prot.copy()\n# %% Create spatial-only subset (2nd time)\nprint(\"DEBUG: About to create spatial_only (2nd time)\")\n# First create a t Creating temp subsampled adata_prot from {adata_prot.n_obs} to 2000 cells\")\ntemp_indices = np.random.choice(adata_prot.n_obs, min(2000, adata_prot.n_obs), replace=False)\ntemp_indices.sort()\nadata_prot_temp = adata_prot[temp_indices, :].copy()\nspatial_only = adata_prot_temp[:, adata_prot_temp.var[\"feature_type\"] != \"protein\"].copy()\nprint(f\"Number of cells in spatial_only: {spatial_only.n_obs}\")\ndel adata_prot_temp",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "temp_indices",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "temp_indices = np.random.choice(adata_prot.n_obs, min(2000, adata_prot.n_obs), replace=False)\ntemp_indices.sort()\nadata_prot_temp = adata_prot[temp_indices, :].copy()\nspatial_only = adata_prot_temp[:, adata_prot_temp.var[\"feature_type\"] != \"protein\"].copy()\nprint(f\"Number of cells in spatial_only: {spatial_only.n_obs}\")\ndel adata_prot_temp\ngc.collect()\n# %% Plot post-conversion histograms\nif plot_flag:\n    training.pre_train_adata_histograms_heatmap(",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_prot_temp",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_prot_temp = adata_prot[temp_indices, :].copy()\nspatial_only = adata_prot_temp[:, adata_prot_temp.var[\"feature_type\"] != \"protein\"].copy()\nprint(f\"Number of cells in spatial_only: {spatial_only.n_obs}\")\ndel adata_prot_temp\ngc.collect()\n# %% Plot post-conversion histograms\nif plot_flag:\n    training.pre_train_adata_histograms_heatmap(\n        adata_rna, \"rna_subset_after_convet_to_integer\", \"RNA\"\n    )",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "spatial_only",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "spatial_only = adata_prot_temp[:, adata_prot_temp.var[\"feature_type\"] != \"protein\"].copy()\nprint(f\"Number of cells in spatial_only: {spatial_only.n_obs}\")\ndel adata_prot_temp\ngc.collect()\n# %% Plot post-conversion histograms\nif plot_flag:\n    training.pre_train_adata_histograms_heatmap(\n        adata_rna, \"rna_subset_after_convet_to_integer\", \"RNA\"\n    )\n    training.pre_train_adata_histograms_heatmap(",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_rna.obs[\"index_col\"] = range(len(adata_rna.obs.index))\nadata_prot.obs[\"index_col\"] = range(len(adata_prot.obs.index))\n# Ensure both datasets have proper batch columns for scVI\n# Check if batch column exists, if not create a default one\nif \"batch\" not in adata_rna.obs.columns:\n    print(\"Creating batch column for RNA data...\")\n    adata_rna.obs[\"batch\"] = pd.Categorical([\"batch_0\"] * len(adata_rna))\nelse:\n    print(\n        f\"RNA data already has batch column with {len(adata_rna.obs['batch'].unique())} unique batches\"",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_prot.obs[\"index_col\"] = range(len(adata_prot.obs.index))\n# Ensure both datasets have proper batch columns for scVI\n# Check if batch column exists, if not create a default one\nif \"batch\" not in adata_rna.obs.columns:\n    print(\"Creating batch column for RNA data...\")\n    adata_rna.obs[\"batch\"] = pd.Categorical([\"batch_0\"] * len(adata_rna))\nelse:\n    print(\n        f\"RNA data already has batch column with {len(adata_rna.obs['batch'].unique())} unique batches\"\n    )",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "prot_lib_sizes",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "prot_lib_sizes = 40000\nsc.pp.normalize_total(adata_prot, target_sum=prot_lib_sizes)\nadata_rna.X = adata_rna.layers[\"counts\"].copy()\nsc.pp.normalize_total(adata_rna, target_sum=prot_lib_sizes)\nadata_prot.uns[\"normalize_total_value\"] = prot_lib_sizes\nadata_rna.uns[\"normalize_total_value\"] = prot_lib_sizes  # Store for RNA too\nprotein_lib_sizes = np.full(len(adata_prot), adata_prot.uns[\"normalize_total_value\"])\nadata_prot.obs[\"_scvi_library_size\"] = np.log(protein_lib_sizes)\n# Verify library sizes after normalization\nprint(",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_rna.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_rna.X = adata_rna.layers[\"counts\"].copy()\nsc.pp.normalize_total(adata_rna, target_sum=prot_lib_sizes)\nadata_prot.uns[\"normalize_total_value\"] = prot_lib_sizes\nadata_rna.uns[\"normalize_total_value\"] = prot_lib_sizes  # Store for RNA too\nprotein_lib_sizes = np.full(len(adata_prot), adata_prot.uns[\"normalize_total_value\"])\nadata_prot.obs[\"_scvi_library_size\"] = np.log(protein_lib_sizes)\n# Verify library sizes after normalization\nprint(\n    f\"DEBUG: RNA library sizes after normalization - mean: {np.array(adata_rna.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"\n)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"normalize_total_value\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_prot.uns[\"normalize_total_value\"] = prot_lib_sizes\nadata_rna.uns[\"normalize_total_value\"] = prot_lib_sizes  # Store for RNA too\nprotein_lib_sizes = np.full(len(adata_prot), adata_prot.uns[\"normalize_total_value\"])\nadata_prot.obs[\"_scvi_library_size\"] = np.log(protein_lib_sizes)\n# Verify library sizes after normalization\nprint(\n    f\"DEBUG: RNA library sizes after normalization - mean: {np.array(adata_rna.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"\n)\nprint(\n    f\"DEBUG: Protein library sizes after normalization - mean: {np.array(adata_prot.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"normalize_total_value\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_rna.uns[\"normalize_total_value\"] = prot_lib_sizes  # Store for RNA too\nprotein_lib_sizes = np.full(len(adata_prot), adata_prot.uns[\"normalize_total_value\"])\nadata_prot.obs[\"_scvi_library_size\"] = np.log(protein_lib_sizes)\n# Verify library sizes after normalization\nprint(\n    f\"DEBUG: RNA library sizes after normalization - mean: {np.array(adata_rna.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"\n)\nprint(\n    f\"DEBUG: Protein library sizes after normalization - mean: {np.array(adata_prot.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"\n)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "protein_lib_sizes",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "protein_lib_sizes = np.full(len(adata_prot), adata_prot.uns[\"normalize_total_value\"])\nadata_prot.obs[\"_scvi_library_size\"] = np.log(protein_lib_sizes)\n# Verify library sizes after normalization\nprint(\n    f\"DEBUG: RNA library sizes after normalization - mean: {np.array(adata_rna.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"\n)\nprint(\n    f\"DEBUG: Protein library sizes after normalization - mean: {np.array(adata_prot.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"\n)\n# %% Finalize metadata and prepare for saving",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"_scvi_library_size\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_prot.obs[\"_scvi_library_size\"] = np.log(protein_lib_sizes)\n# Verify library sizes after normalization\nprint(\n    f\"DEBUG: RNA library sizes after normalization - mean: {np.array(adata_rna.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"\n)\nprint(\n    f\"DEBUG: Protein library sizes after normalization - mean: {np.array(adata_prot.X.sum(axis=1)).flatten().mean():.2f}, expected: {prot_lib_sizes}\"\n)\n# %% Finalize metadata and prepare for saving\npipeline_metadata_utils.finalize_prepare_data_metadata(adata_rna, adata_prot, archetype_distances)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_rna.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_rna.X = sp.csr_matrix(adata_rna.X.astype(np.float32))\nadata_prot.X = sp.csr_matrix(adata_prot.X.astype(np.float32))\n# Final verification before saving\nprint(\n    f\"DEBUG: Final RNA library sizes before save - mean: {np.array(adata_rna.X.sum(axis=1)).flatten().mean():.2f}\"\n)\nprint(\n    f\"DEBUG: Final Protein library sizes before save - mean: {np.array(adata_prot.X.sum(axis=1)).flatten().mean():.2f}\"\n)\nsave_processed_data(adata_rna, adata_prot, \"processed_data\", caller_filename=FILENAME)",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "adata_prot.X",
        "kind": 5,
        "importPath": "ARCADIA.scripts._4_prepare_training",
        "description": "ARCADIA.scripts._4_prepare_training",
        "peekOfCode": "adata_prot.X = sp.csr_matrix(adata_prot.X.astype(np.float32))\n# Final verification before saving\nprint(\n    f\"DEBUG: Final RNA library sizes before save - mean: {np.array(adata_rna.X.sum(axis=1)).flatten().mean():.2f}\"\n)\nprint(\n    f\"DEBUG: Final Protein library sizes before save - mean: {np.array(adata_prot.X.sum(axis=1)).flatten().mean():.2f}\"\n)\nsave_processed_data(adata_rna, adata_prot, \"processed_data\", caller_filename=FILENAME)\n# %% Final plotting",
        "detail": "ARCADIA.scripts._4_prepare_training",
        "documentation": {}
    },
    {
        "label": "train_vae",
        "kind": 2,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "def train_vae(\n    adata_rna_subset,\n    adata_prot_subset,\n    model_checkpoints_folder=None,\n    max_epochs=10,\n    batch_size=128,\n    lr=1e-3,\n    contrastive_weight=1.0,\n    similarity_weight=0.5,\n    similarity_dynamic=True,",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "FILENAME = \"_5_train_vae.py\"\n# %% Processing\n\"\"\" DO NOT REMOVE THIS COMMENT!!!\nTO use this script, you need to add the training plan to use the DualVAETrainingPlan (version 1.2.2.post2) class in scVI library.\nin _training_mixin.py, line 131, you need to change the line:\ntraining_plan = self._training_plan_cls(self.module, **plan_kwargs) # existing line\nself._training_plan = training_plan # add this line\n\"\"\"\nimport hashlib\nimport json",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "training_plan",
        "kind": 5,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "training_plan = self._training_plan_cls(self.module, **plan_kwargs) # existing line\nself._training_plan = training_plan # add this line\n\"\"\"\nimport hashlib\nimport json\nimport os\nimport sys\nimport time\nimport warnings\nfrom datetime import datetime",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "self._training_plan",
        "kind": 5,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "self._training_plan = training_plan # add this line\n\"\"\"\nimport hashlib\nimport json\nimport os\nimport sys\nimport time\nimport warnings\nfrom datetime import datetime\nfrom pathlib import Path",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "log_timestamp",
        "kind": 5,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "log_timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nfrom arcadia.plotting.training import plot_umap_with_extremes\n# Validate scVI training mixin before proceeding\n# Import training utilities\nfrom arcadia.training import (\n    calculate_post_training_metrics,\n    clear_memory,\n    generate_post_training_visualizations,\n    log_memory_usage,\n    log_parameters,",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "project_root = str(ROOT)\n# Paths already set above, no need to add again\nimport matplotlib as mpl\nimport mlflow\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport scvi\nimport torch\nfrom scvi.model import SCVI",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "pd.options.display.max_rows",
        "kind": 5,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "pd.options.display.max_rows = 10\npd.options.display.max_columns = 10\nnp.set_printoptions(threshold=100)\n# %% Load configuration\nconfig_path = str(ROOT / \"configs\" / \"config.json\")\nif os.path.exists(config_path):\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "pd.options.display.max_columns",
        "kind": 5,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "pd.options.display.max_columns = 10\nnp.set_printoptions(threshold=100)\n# %% Load configuration\nconfig_path = str(ROOT / \"configs\" / \"config.json\")\nif os.path.exists(config_path):\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts._5_train_vae",
        "description": "ARCADIA.scripts._5_train_vae",
        "peekOfCode": "config_path = str(ROOT / \"configs\" / \"config.json\")\nif os.path.exists(config_path):\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.scripts._5_train_vae",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "dataset_name = None\n# Import train_vae from train_vae script\nimport importlib.util\n# %% Setup and imports\nimport json\nimport os\nimport time\nimport traceback\nimport warnings\nfrom datetime import datetime, timedelta",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "train_vae_spec",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "train_vae_spec = importlib.util.spec_from_file_location(\n    \"train_vae_module\", ROOT / \"scripts\" / \"_5_train_vae.py\"\n)\ntrain_vae_module = importlib.util.module_from_spec(train_vae_spec)\ntrain_vae_spec.loader.exec_module(train_vae_module)\ntrain_vae = train_vae_module.train_vae\n# Set the filename for this script\nFILENAME = \"hyperparameter_search.py\"\n# %% Load configuration\nconfig_path = ROOT / \"configs\" / \"config.json\"",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "train_vae_module",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "train_vae_module = importlib.util.module_from_spec(train_vae_spec)\ntrain_vae_spec.loader.exec_module(train_vae_module)\ntrain_vae = train_vae_module.train_vae\n# Set the filename for this script\nFILENAME = \"hyperparameter_search.py\"\n# %% Load configuration\nconfig_path = ROOT / \"configs\" / \"config.json\"\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "train_vae",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "train_vae = train_vae_module.train_vae\n# Set the filename for this script\nFILENAME = \"hyperparameter_search.py\"\n# %% Load configuration\nconfig_path = ROOT / \"configs\" / \"config.json\"\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "FILENAME = \"hyperparameter_search.py\"\n# %% Load configuration\nconfig_path = ROOT / \"configs\" / \"config.json\"\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "config_path = ROOT / \"configs\" / \"config.json\"\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\npd.set_option(\"display.max_columns\", 10)\npd.set_option(\"display.max_rows\", 10)\nwarnings.filterwarnings(\"ignore\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", message=\".*pkg_resources.*\")\npd.options.display.max_rows = 10\npd.options.display.max_columns = 10\nnp.set_printoptions(threshold=100)",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "pd.options.display.max_rows",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "pd.options.display.max_rows = 10\npd.options.display.max_columns = 10\nnp.set_printoptions(threshold=100)\n# %% Parse command line arguments\nargs = parse_arguments()\n# Override dataset_name from command line if provided\nif args.dataset_name:\n    dataset_name = args.dataset_name\n# %% Setup logging\nos.makedirs(\"logs\", exist_ok=True)",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "pd.options.display.max_columns",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "pd.options.display.max_columns = 10\nnp.set_printoptions(threshold=100)\n# %% Parse command line arguments\nargs = parse_arguments()\n# Override dataset_name from command line if provided\nif args.dataset_name:\n    dataset_name = args.dataset_name\n# %% Setup logging\nos.makedirs(\"logs\", exist_ok=True)\nlog_timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "args = parse_arguments()\n# Override dataset_name from command line if provided\nif args.dataset_name:\n    dataset_name = args.dataset_name\n# %% Setup logging\nos.makedirs(\"logs\", exist_ok=True)\nlog_timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\ntimestamped_log_file = f\"logs/hyperparameter_search_{log_timestamp}.log\"\nlogger = setup_logger(level=\"INFO\")\nlogger.add(",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "log_timestamp",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "log_timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\ntimestamped_log_file = f\"logs/hyperparameter_search_{log_timestamp}.log\"\nlogger = setup_logger(level=\"INFO\")\nlogger.add(\n    timestamped_log_file,\n    format=\"<level>{level: <8}</level> | <cyan>{extra[module_name]}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>\",\n    level=\"INFO\",\n    rotation=\"500 MB\",\n    compression=\"zip\",\n    enqueue=True,",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "timestamped_log_file",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "timestamped_log_file = f\"logs/hyperparameter_search_{log_timestamp}.log\"\nlogger = setup_logger(level=\"INFO\")\nlogger.add(\n    timestamped_log_file,\n    format=\"<level>{level: <8}</level> | <cyan>{extra[module_name]}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>\",\n    level=\"INFO\",\n    rotation=\"500 MB\",\n    compression=\"zip\",\n    enqueue=True,\n    filter=filter_and_transform,",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "logger = setup_logger(level=\"INFO\")\nlogger.add(\n    timestamped_log_file,\n    format=\"<level>{level: <8}</level> | <cyan>{extra[module_name]}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>\",\n    level=\"INFO\",\n    rotation=\"500 MB\",\n    compression=\"zip\",\n    enqueue=True,\n    filter=filter_and_transform,\n)",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "base_param_grid",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "base_param_grid = {\n    \"plot_x_times\": [10],\n    \"check_val_every_n_epoch\": [100],\n    \"max_epochs\": [400],\n    \"save_checkpoint_every_n_epochs\": [280],\n    \"batch_size\": [1024],\n    \"print_every_n_epoch\": [50],\n    \"plot_first_step\": [False],\n    \"outlier_detection_enabled\": [True],\n    \"contrastive_weight\": [0],",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "param_grid",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "param_grid = base_param_grid.copy()\nparam_grid = apply_command_line_overrides(param_grid, args, logger)\nparam_grid = apply_baseline_settings(param_grid, args, logger)\ncombinations_to_skip = []\n# %% Load data\nadata_rna_subset, adata_prot_subset = load_adata_latest(\n    \"processed_data\",\n    [\"rna\", \"protein\"],\n    exact_step=4,\n    index_from_end=0,",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "param_grid",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "param_grid = apply_command_line_overrides(param_grid, args, logger)\nparam_grid = apply_baseline_settings(param_grid, args, logger)\ncombinations_to_skip = []\n# %% Load data\nadata_rna_subset, adata_prot_subset = load_adata_latest(\n    \"processed_data\",\n    [\"rna\", \"protein\"],\n    exact_step=4,\n    index_from_end=0,\n    dataset_name=dataset_name,",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "param_grid",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "param_grid = apply_baseline_settings(param_grid, args, logger)\ncombinations_to_skip = []\n# %% Load data\nadata_rna_subset, adata_prot_subset = load_adata_latest(\n    \"processed_data\",\n    [\"rna\", \"protein\"],\n    exact_step=4,\n    index_from_end=0,\n    dataset_name=dataset_name,\n)",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "combinations_to_skip",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "combinations_to_skip = []\n# %% Load data\nadata_rna_subset, adata_prot_subset = load_adata_latest(\n    \"processed_data\",\n    [\"rna\", \"protein\"],\n    exact_step=4,\n    index_from_end=0,\n    dataset_name=dataset_name,\n)\n# %% Convert data to sparse format",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "dataset_name_mlflow",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "dataset_name_mlflow = adata_rna_subset.uns.get(\"dataset_name\", \"unknown\")\nexperiment_name = dataset_name_mlflow\nexperiment = mlflow.get_experiment_by_name(experiment_name)\nif experiment is None:\n    experiment_id = mlflow.create_experiment(experiment_name)\n    logger.info(f\"Created new MLflow experiment: {experiment_name} with ID: {experiment_id}\")\nelse:\n    experiment_id = experiment.experiment_id\nmlflow.set_experiment(experiment_name)\n# %% Filter out already tried parameter combinations",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "experiment_name",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "experiment_name = dataset_name_mlflow\nexperiment = mlflow.get_experiment_by_name(experiment_name)\nif experiment is None:\n    experiment_id = mlflow.create_experiment(experiment_name)\n    logger.info(f\"Created new MLflow experiment: {experiment_name} with ID: {experiment_id}\")\nelse:\n    experiment_id = experiment.experiment_id\nmlflow.set_experiment(experiment_name)\n# %% Filter out already tried parameter combinations\nexisting_runs = mlflow.search_runs(experiment_ids=[experiment_id])",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "experiment",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "experiment = mlflow.get_experiment_by_name(experiment_name)\nif experiment is None:\n    experiment_id = mlflow.create_experiment(experiment_name)\n    logger.info(f\"Created new MLflow experiment: {experiment_name} with ID: {experiment_id}\")\nelse:\n    experiment_id = experiment.experiment_id\nmlflow.set_experiment(experiment_name)\n# %% Filter out already tried parameter combinations\nexisting_runs = mlflow.search_runs(experiment_ids=[experiment_id])\nexisting_params = []",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "existing_runs",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "existing_runs = mlflow.search_runs(experiment_ids=[experiment_id])\nexisting_params = []\nfor _, run in existing_runs.iterrows():\n    run_params = {}\n    for param in param_grid.keys():\n        param_key = f\"params.{param}\"\n        if (\n            run.status == \"FINISHED\"\n            and param_key in run.index\n            and param not in [\"plot_x_times\", \"check_val_every_n_epoch\", \"max_epochs\"]",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "existing_params",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "existing_params = []\nfor _, run in existing_runs.iterrows():\n    run_params = {}\n    for param in param_grid.keys():\n        param_key = f\"params.{param}\"\n        if (\n            run.status == \"FINISHED\"\n            and param_key in run.index\n            and param not in [\"plot_x_times\", \"check_val_every_n_epoch\", \"max_epochs\"]\n        ):",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "all_combinations",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "all_combinations = list(ParameterGrid(param_grid))\nnew_combinations = []\nfor combo in all_combinations:\n    combo_to_check = {\n        k: v\n        for k, v in combo.items()\n        if k\n        not in [\n            \"plot_x_times\",\n            \"check_val_every_n_epoch\",",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "new_combinations",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "new_combinations = []\nfor combo in all_combinations:\n    combo_to_check = {\n        k: v\n        for k, v in combo.items()\n        if k\n        not in [\n            \"plot_x_times\",\n            \"check_val_every_n_epoch\",\n            \"max_epochs\",",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "skipped_combinations",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "skipped_combinations = len(all_combinations) - len(new_combinations) - len(existing_params)\ntotal_combinations = len(new_combinations)\nlogger.info(f\"Total combinations: {len(all_combinations)}\")\nlogger.info(f\"Already tried: {len(existing_params)}\")\nlogger.info(f\"Manually skipped: {skipped_combinations}\")\nlogger.info(f\"New combinations to try: {total_combinations}\")\n# %% Subsample data\nsc.pp.subsample(adata_rna_subset, n_obs=min(num_rna_cells, adata_rna_subset.shape[0]))\nsc.pp.subsample(adata_prot_subset, n_obs=min(num_protein_cells, adata_prot_subset.shape[0]))\nlogger.info(f\"RNA data shape: {adata_rna_subset.shape}\")",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "total_combinations",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "total_combinations = len(new_combinations)\nlogger.info(f\"Total combinations: {len(all_combinations)}\")\nlogger.info(f\"Already tried: {len(existing_params)}\")\nlogger.info(f\"Manually skipped: {skipped_combinations}\")\nlogger.info(f\"New combinations to try: {total_combinations}\")\n# %% Subsample data\nsc.pp.subsample(adata_rna_subset, n_obs=min(num_rna_cells, adata_rna_subset.shape[0]))\nsc.pp.subsample(adata_prot_subset, n_obs=min(num_protein_cells, adata_prot_subset.shape[0]))\nlogger.info(f\"RNA data shape: {adata_rna_subset.shape}\")\nlogger.info(f\"Protein data shape: {adata_prot_subset.shape}\")",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "adata_rna_subset.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "adata_rna_subset.obs[\"cell_types\"] = adata_rna_subset.obs[\"major_cell_types\"]\nadata_prot_subset.obs[\"cell_types\"] = adata_prot_subset.obs[\"major_cell_types\"]\nlog_memory_usage(\"After loading protein data: \")\nlogger.info(f\"RNA dataset shape: {adata_rna_subset.shape}\")\nlogger.info(f\"Protein dataset shape: {adata_prot_subset.shape}\")\n# %% Handle checkpoint folder selection\nif args.resume_from_latest_checkpoint:\n    logger.info(\"Searching for latest checkpoint folder...\")\n    model_checkpoints_folder = find_latest_checkpoint_folder(logger, dataset_name)\n    if model_checkpoints_folder is None:",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "adata_prot_subset.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "adata_prot_subset.obs[\"cell_types\"] = adata_prot_subset.obs[\"major_cell_types\"]\nlog_memory_usage(\"After loading protein data: \")\nlogger.info(f\"RNA dataset shape: {adata_rna_subset.shape}\")\nlogger.info(f\"Protein dataset shape: {adata_prot_subset.shape}\")\n# %% Handle checkpoint folder selection\nif args.resume_from_latest_checkpoint:\n    logger.info(\"Searching for latest checkpoint folder...\")\n    model_checkpoints_folder = find_latest_checkpoint_folder(logger, dataset_name)\n    if model_checkpoints_folder is None:\n        logger.error(\"Failed to find latest checkpoint folder. Training will start from scratch.\")",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "results",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "results = []\nlogger.info(f\"Number of new combinations to try: {total_combinations}\")\nstart_time = datetime.now()\nelapsed_times = []\nfor i, params in enumerate(new_combinations):\n    if os.path.exists(ROOT / \"scales_cache.json\"):\n        os.remove(ROOT / \"scales_cache.json\")\n    run_name = f\"vae_training_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n    mlflow_run_status = \"FINISHED\"\n    iter_start_time = datetime.now()",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "start_time",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "start_time = datetime.now()\nelapsed_times = []\nfor i, params in enumerate(new_combinations):\n    if os.path.exists(ROOT / \"scales_cache.json\"):\n        os.remove(ROOT / \"scales_cache.json\")\n    run_name = f\"vae_training_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n    mlflow_run_status = \"FINISHED\"\n    iter_start_time = datetime.now()\n    log_memory_usage(f\"Start of iteration {i+1}: \")\n    # %% Start MLflow run",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "elapsed_times",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "elapsed_times = []\nfor i, params in enumerate(new_combinations):\n    if os.path.exists(ROOT / \"scales_cache.json\"):\n        os.remove(ROOT / \"scales_cache.json\")\n    run_name = f\"vae_training_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n    mlflow_run_status = \"FINISHED\"\n    iter_start_time = datetime.now()\n    log_memory_usage(f\"Start of iteration {i+1}: \")\n    # %% Start MLflow run\n    with mlflow.start_run(run_name=run_name):",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "results_df",
        "kind": 5,
        "importPath": "ARCADIA.scripts.hyperparameter_search",
        "description": "ARCADIA.scripts.hyperparameter_search",
        "peekOfCode": "results_df = pd.DataFrame(results)\nresults_df.to_csv(\n    f\"hyperparameter_search_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\", index=False\n)\nlogger.success(\n    f\"\\nHyperparameter search completed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\"\n)",
        "detail": "ARCADIA.scripts.hyperparameter_search",
        "documentation": {}
    },
    {
        "label": "timeit",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def timeit(func):\n    \"\"\"\n    Decorator to measure execution time of functions.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"Function {func.__name__} took {end_time - start_time:.4f} seconds to execute\")",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "nnls_omp",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def nnls_omp(basis_matrix, target_vector, tol=1e-4):\n    \"\"\"\n    Non-negative least squares using Orthogonal Matching Pursuit.\n    Parameters:\n    -----------\n    basis_matrix : np.ndarray\n        Basis matrix of shape (n_archetypes, n_features)\n    target_vector : np.ndarray\n        Target vector of shape (n_features,)\n    tol : float",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "compute_weight_for_cell",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def compute_weight_for_cell(x, A_T, n_archetypes, solver):\n    \"\"\"\n    Compute archetype weights for a single cell using constrained optimization.\n    Parameters:\n    -----------\n    x : np.ndarray\n        Cell vector of shape (n_features,)\n    A_T : np.ndarray\n        Transposed archetype matrix of shape (n_features, n_archetypes)\n    n_archetypes : int",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "identify_extreme_archetypes_percentile",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def identify_extreme_archetypes_percentile(\n    archetype_vectors, logger_=None, percentile=95, to_print=False\n):\n    \"\"\"\n    Identify the top percentile of cells with highest weight concentration in a single dimension.\n    Parameters:\n    -----------\n    archetype_vectors : numpy array\n        The archetype vectors for cells\n    percentile : float",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "get_cell_representations_as_archetypes_scipy",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def get_cell_representations_as_archetypes_scipy(count_matrix, archetype_matrix):\n    n_cells = count_matrix.shape[0]\n    n_archetypes = archetype_matrix.shape[0]\n    weights = np.zeros((n_cells, n_archetypes))\n    A_T = archetype_matrix.T\n    bounds = [(0, None)] * n_archetypes\n    cons = {\"type\": \"eq\", \"fun\": lambda w: np.sum(w) - 1}\n    def objective(w, x):\n        return np.sum((A_T @ w - x) ** 2)\n    for i in tqdm(range(n_cells), desc=\"Computing archetype weights\", total=n_cells):",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "get_cell_representations_as_archetypes_ols",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def get_cell_representations_as_archetypes_ols(count_matrix, archetype_matrix):\n    \"\"\"\n    Compute archetype weights for each cell using Ordinary Least Squares (OLS).\n    Parameters:\n    -----------\n    count_matrix : np.ndarray\n        Matrix of cells in reduced-dimensional space (e.g., PCA),\n        shape (n_cells, n_features).\n    archetype_matrix : np.ndarray\n        Matrix of archetypes,",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "get_cell_representations_as_archetypes_omp",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def get_cell_representations_as_archetypes_omp(count_matrix, archetype_matrix, tol=1e-4):\n    # Preprocess archetype matrix\n    n_cells = count_matrix.shape[0]\n    n_archetypes = archetype_matrix.shape[0]\n    weights = np.zeros((n_cells, n_archetypes))\n    for i in range(n_cells):\n        weights[i] = nnls_omp(archetype_matrix, count_matrix[i], tol=tol)\n    row_sums = weights.sum(axis=1, keepdims=True)\n    weights[row_sums == 0] = 1.0 / n_archetypes  # Assign uniform weights to zero rows\n    weights /= weights.sum(axis=1, keepdims=True)",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "get_cell_representations_as_archetypes_cvxpy",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def get_cell_representations_as_archetypes_cvxpy(\n    count_matrix, archetype_matrix, solver=\"cp.ECOS\", n_jobs=-1\n):\n    import cvxpy as cp\n    if solver == \"cp.ECOS\":\n        solver = cp.ECOS\n    elif solver == \"cp.SCS\":\n        solver = cp.SCS\n    else:\n        raise ValueError(f\"Invalid solver: {solver}\")",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "get_cell_representations_as_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "description": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "peekOfCode": "def get_cell_representations_as_archetypes(count_matrix, archetype_matrix):\n    \"\"\"\n    Compute archetype weights for each cell using cvxpy.\n    \"\"\"\n    n_cells = count_matrix.shape[0]\n    n_archetypes = archetype_matrix.shape[0]\n    weights = np.zeros((n_cells, n_archetypes))\n    for i in range(n_cells):\n        weights[i], _ = nnls(archetype_matrix.T, count_matrix[i])\n    weights /= weights.sum(axis=1, keepdims=True)  # Normalize rows",
        "detail": "ARCADIA.src.arcadia.archetypes.cell_representations",
        "documentation": {}
    },
    {
        "label": "compute_archetype_distances",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.distances",
        "description": "ARCADIA.src.arcadia.archetypes.distances",
        "peekOfCode": "def compute_archetype_distances(adata_rna: AnnData, adata_prot: AnnData, batch_size=1000):\n    \"\"\"Compute archetype distances between RNA and protein data using batched processing to handle large datasets\"\"\"\n    print(\"Computing archetype distances with batched processing...\")\n    rna_vecs = adata_rna.obsm[\"archetype_vec\"].values\n    prot_vecs = adata_prot.obsm[\"archetype_vec\"].values\n    n_rna = rna_vecs.shape[0]\n    n_prot = prot_vecs.shape[0]\n    # For very large datasets, compute only diagonal elements (matching pairs)\n    if n_rna > 100000 and n_prot > 100000 and n_rna == n_prot:\n        print(f\"Large dataset detected ({n_rna} samples), computing only diagonal distances...\")",
        "detail": "ARCADIA.src.arcadia.archetypes.distances",
        "documentation": {}
    },
    {
        "label": "update_archetype_labels",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def update_archetype_labels(adata: AnnData, archetype_vectors_key: str = \"archetype_vec\") -> None:\n    \"\"\"\n    Update archetype labels based on current archetype vectors.\n    This utility ensures that archetype labels are always in sync with archetype vectors\n    by finding the dominant archetype for each cell.\n    Args:\n        adata: AnnData object to update\n        archetype_vectors_key: Key in adata.obsm containing archetype vectors\n    \"\"\"\n    if archetype_vectors_key not in adata.obsm:",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "get_cell_type_colors",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def get_cell_type_colors(cell_types: List[str], palette_name: str = \"tab20\") -> Dict[str, str]:\n    \"\"\"\n    Generate consistent cell type colors.\n    Args:\n        cell_types: List of unique cell types\n        palette_name: Name of matplotlib colormap to use\n    Returns:\n        Dictionary mapping cell types to hex colors\n    \"\"\"\n    n_colors = len(cell_types)",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "filter_extreme_archetypes_by_cross_modal_quality",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def filter_extreme_archetypes_by_cross_modal_quality(\n    adata_1: AnnData,\n    adata_2: AnnData,\n    cell_type_key: str = \"cell_types\",\n    proportion_threshold: float = 0.5,\n    verbose: bool = True,\n) -> None:\n    \"\"\"\n    Filter extreme archetypes to keep only those with good cross-modal matching quality.\n    This function compares the cell type proportions of each archetype between modalities",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "generate_archetypes_per_batch",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def generate_archetypes_per_batch(\n    adata: AnnData,\n    batch_key: str = \"batch\",\n    embedding_name: str = \"X_pca\",\n    min_k: int = 8,\n    max_k: int = 9,\n    step_size: int = 1,\n    converge: float = 1e-5,\n    modality_name: str = \"RNA\",\n    plot_flag: bool = True,",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "compute_batch_archetype_proportions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def compute_batch_archetype_proportions(\n    batch_archetypes: Dict[str, Dict],\n    adata: AnnData,\n    batch_key: str = \"batch\",\n    modality_name: str = \"RNA\",\n    plot_flag: bool = True,\n) -> Dict[str, List[pd.DataFrame]]:\n    \"\"\"\n    Compute cell type proportions for archetypes in each batch.\n    Args:",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "create_unified_archetype_representation",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def create_unified_archetype_representation(\n    adata: AnnData,\n    matched_archetypes: Dict[str, Dict],\n    batch_archetypes: Dict[str, Dict],\n    batch_key: str = \"batch\",\n    modality_name: str = \"RNA\",\n    optimal_k: int = None,\n) -> AnnData:\n    \"\"\"\n    Create unified archetype vectors for all cells using matched archetypes.",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "match_archetypes_across_batches_for_all_k",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def match_archetypes_across_batches_for_all_k(\n    batch_archetypes: Dict[str, Dict],\n    batch_proportions: Dict[str, List[pd.DataFrame]],\n    modality_name: str = \"RNA\",\n    metric: str = \"cosine\",\n    plot_flag: bool = True,\n) -> Dict[int, Dict]:\n    \"\"\"\n    Match archetypes across batches for all available k values within a modality.\n    This creates batch-matched archetype sets for each k value, keeping all options",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "compute_global_modality_proportions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def compute_global_modality_proportions(\n    batch_proportions: Dict[str, List[pd.DataFrame]],\n    modality_name: str = \"RNA\",\n    batch_archetypes: Dict[str, Dict] = None,\n) -> Dict[int, pd.DataFrame]:\n    \"\"\"\n    Compute global (aggregated across batches) cell type proportions for each k value.\n    Args:\n        batch_proportions: Dictionary containing proportion DataFrames for each batch\n        modality_name: Name of modality for logging",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "compute_global_modality_proportions_from_matched",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def compute_global_modality_proportions_from_matched(\n    k_matched_results: Dict[int, Dict],\n    modality_name: str = \"RNA\",\n) -> Dict[int, pd.DataFrame]:\n    \"\"\"\n    Compute global (aggregated across batches) cell type proportions using ALIGNED batch proportions.\n    This function uses the proportions from within-modality matching results, where each batch's\n    archetypes have been reordered to match the reference batch. This ensures the global proportions\n    reflect the aligned archetype ordering for cross-modal comparison.\n    Args:",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "find_optimal_k_across_modalities",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def find_optimal_k_across_modalities(\n    adata_list: list,\n    batch_key: str = \"batch\",\n    embedding_names: list = None,\n    min_k: int = 8,\n    max_k: int = 12,\n    step_size: int = 1,\n    converge: float = 1e-5,\n    modality_names: list = None,\n    metric: str = \"cosine\",",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "validate_batch_archetype_consistency",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def validate_batch_archetype_consistency(\n    adata_rna: AnnData,\n    adata_prot: AnnData,\n    batch_key: str = \"batch\",\n) -> None:\n    \"\"\"\n    Validate that batch-specific archetype generation produces consistent results.\n    Args:\n        adata_rna: RNA AnnData object with archetype vectors\n        adata_prot: Protein AnnData object with archetype vectors",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "add_matched_archetype_weight",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def add_matched_archetype_weight(adata: sc.AnnData) -> sc.AnnData:\n    \"\"\"\n    Adds the archetype significance to the adata object\n    which is the weight of the most significant archetype for each cell, how much a cell is \"extreme\"\n    in regards of how much of the weight of its most significant archetype\n    Input:\n    adata: sc.AnnData\n        AnnData object with archetype_label in obs and archetype_vec in obsm\n    Output:\n    adata: sc.AnnData",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "finalize_archetype_generation_with_visualizations",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.generation",
        "description": "ARCADIA.src.arcadia.archetypes.generation",
        "peekOfCode": "def finalize_archetype_generation_with_visualizations(\n    adata_rna: AnnData,\n    adata_prot: AnnData,\n    plot_flag: bool = True,\n) -> None:\n    \"\"\"\n    Finalize archetype generation process and create comprehensive visualizations.\n    This function should be called after find_optimal_k_across_modalities to add\n    the archetype proportion analysis and visualizations that were in the original code.\n    Args:",
        "detail": "ARCADIA.src.arcadia.archetypes.generation",
        "documentation": {}
    },
    {
        "label": "identify_extreme_archetypes_balanced",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.matching",
        "description": "ARCADIA.src.arcadia.archetypes.matching",
        "peekOfCode": "def identify_extreme_archetypes_balanced(\n    archetype_vectors, adata=None, logger_=None, percentile=95, to_print=False\n):\n    \"\"\"\n    Identify extreme archetypes using balanced selection with minimum constraints and quality filtering.\n    New method:\n    1. Calculate top 5% from each archetype\n    2. Apply minimum of 10 cells per archetype\n    3. Skip low quality archetypes\n    4. Use minimum calculated count as max for all archetypes (balanced selection)",
        "detail": "ARCADIA.src.arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "reorder_rows_to_maximize_diagonal",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.matching",
        "description": "ARCADIA.src.arcadia.archetypes.matching",
        "peekOfCode": "def reorder_rows_to_maximize_diagonal(matrix):\n    \"\"\"\n    Reorders rows of a matrix to maximize diagonal dominance by placing the highest values\n    in the closest positions to the diagonal.\n    Parameters:\n    -----------\n    matrix : np.ndarray\n        An m x n matrix.\n    Returns:\n    --------",
        "detail": "ARCADIA.src.arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "match_rows",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.matching",
        "description": "ARCADIA.src.arcadia.archetypes.matching",
        "peekOfCode": "def match_rows(matrix1, matrix2, metric=\"correlation\"):\n    \"\"\"Helper function to match rows between two matrices.\"\"\"\n    if metric == \"correlation\":\n        # Compute correlation matrix\n        corr_matrix = np.corrcoef(matrix1, matrix2)[: matrix1.shape[0], matrix1.shape[0] :]\n        # Convert correlation to distance (1 - correlation)\n        dist_matrix = 1 - corr_matrix\n    else:\n        # Use scipy's cdist for other metrics\n        dist_matrix = cdist(matrix1, matrix2, metric=metric)",
        "detail": "ARCADIA.src.arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "find_best_pair_by_row_matching",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.matching",
        "description": "ARCADIA.src.arcadia.archetypes.matching",
        "peekOfCode": "def find_best_pair_by_row_matching(\n    archetype_proportion_list_1,\n    archetype_proportion_list_2,\n    metric=\"correlation\",\n):\n    \"\"\"\n    Find the best index in the list by matching rows using linear assignment.\n    Parameters:\n    -----------\n    archetype_proportion_list : list of tuples",
        "detail": "ARCADIA.src.arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "validate_extreme_archetypes_matching",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.matching",
        "description": "ARCADIA.src.arcadia.archetypes.matching",
        "peekOfCode": "def validate_extreme_archetypes_matching(\n    adata_rna, adata_prot, plot_flag=False, logger_=None, to_print=True\n):\n    \"\"\"\n        Validate the extreme archetype matching between RNA and protein data.\n        making sure that the extreme archetypes are preferred for over non-extreme archetypes\n        as they are more likely to be correct matches of cell types across modalities.\n        Here we show that when focusing on extereme archetypes only we get better matching accuracy of cell types across modalities\n    this means that the extreme archetypes are more reliable and can be used as a general frame for cross modality matching\n    # Show case argument for selecting extreme archetype as s general frame for corss modality matching",
        "detail": "ARCADIA.src.arcadia.archetypes.matching",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": "ARCADIA.src.arcadia.archetypes.metrics",
        "description": "ARCADIA.src.arcadia.archetypes.metrics",
        "peekOfCode": "class Tee:\n    \"\"\"Tee class to redirect stdout to both console and log file.\"\"\"\n    def __init__(self, stdout, log_file):\n        self.log_file = log_file\n        self.stdout = stdout\n        self.closed = False\n    def write(self, data):\n        try:\n            if not self.closed and not self.log_file.closed:\n                self.log_file.write(data)",
        "detail": "ARCADIA.src.arcadia.archetypes.metrics",
        "documentation": {}
    },
    {
        "label": "batched_cosine_dist",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.metrics",
        "description": "ARCADIA.src.arcadia.archetypes.metrics",
        "peekOfCode": "def batched_cosine_dist(X, Y, batch_size=5000):\n    \"\"\"Calculate pairwise cosine distances in batches to prevent memory issues.\"\"\"\n    from scipy.spatial.distance import cdist\n    n_x = X.shape[0]\n    n_y = Y.shape[0]\n    distances = np.zeros((n_x, n_y))\n    for i in tqdm(range(0, n_x, batch_size), desc=\"Processing rows\", total=n_x // batch_size + 1):\n        end_i = min(i + batch_size, n_x)\n        batch_X = X[i:end_i]\n        for j in range(0, n_y, batch_size):",
        "detail": "ARCADIA.src.arcadia.archetypes.metrics",
        "documentation": {}
    },
    {
        "label": "match_cells_using_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.metrics",
        "description": "ARCADIA.src.arcadia.archetypes.metrics",
        "peekOfCode": "def match_cells_using_archetypes(adata_rna, adata_prot):\n    \"\"\"Match cells between modalities using archetype vectors with cosine distance.\"\"\"\n    # Since we already converted the objects to have archetype vectors as X,\n    # we can directly use their X matrices\n    # Calculate pairwise distances using cosine distance\n    print(\"Calculating pairwise cosine distances between archetype vectors...\")\n    latent_distances = batched_cosine_dist(adata_rna.X, adata_prot.X)\n    # Find matches\n    prot_matches_in_rna = np.argmin(latent_distances, axis=0)\n    matching_distances = np.min(latent_distances, axis=0)",
        "detail": "ARCADIA.src.arcadia.archetypes.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_post_training_metrics_on_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.metrics",
        "description": "ARCADIA.src.arcadia.archetypes.metrics",
        "peekOfCode": "def calculate_post_training_metrics_on_archetypes(adata_rna, adata_prot, prot_matches_in_rna):\n    \"\"\"Calculate various metrics for model evaluation using archetype vectors.\"\"\"\n    # Calculate NMI scores\n    nmi_cell_types_cn_rna = adjusted_mutual_info_score(\n        adata_rna.obs[\"cell_types\"], adata_rna.obs[\"CN\"]\n    )\n    nmi_cell_types_cn_prot = adjusted_mutual_info_score(\n        adata_prot.obs[\"cell_types\"], adata_prot.obs[\"CN\"]\n    )\n    nmi_cell_types_modalities = adjusted_mutual_info_score(",
        "detail": "ARCADIA.src.arcadia.archetypes.metrics",
        "documentation": {}
    },
    {
        "label": "process_archetype_spaces",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.metrics",
        "description": "ARCADIA.src.arcadia.archetypes.metrics",
        "peekOfCode": "def process_archetype_spaces(adata_rna, adata_prot):\n    \"\"\"Process archetype spaces from RNA and protein data.\"\"\"\n    print(\"Processing archetype spaces...\")\n    # Since we now have archetype vectors as X, we can use the objects directly\n    rna_archetype = adata_rna.copy()\n    prot_archetype = adata_prot.copy()\n    # Combine for visualization\n    combined_archetype = anndata.concat(\n        [rna_archetype, prot_archetype],\n        join=\"outer\",",
        "detail": "ARCADIA.src.arcadia.archetypes.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_metrics_for_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.metrics",
        "description": "ARCADIA.src.arcadia.archetypes.metrics",
        "peekOfCode": "def calculate_metrics_for_archetypes(adata_rna, adata_prot, prefix=\"\", subsample_size=None):\n    \"\"\"Calculate metrics using archetype vectors instead of latent space.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n        prefix: Prefix for metric names (e.g., \"train_\" or \"val_\")\n        subsample_size: If not None, subsample the data to this size\n    \"\"\"\n    print(f\"Calculating {prefix}metrics on archetype vectors...\")\n    # Subsample if requested",
        "detail": "ARCADIA.src.arcadia.archetypes.metrics",
        "documentation": {}
    },
    {
        "label": "evaluate_distance_metrics",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.metrics",
        "description": "ARCADIA.src.arcadia.archetypes.metrics",
        "peekOfCode": "def evaluate_distance_metrics(A: np.ndarray, B: np.ndarray, metrics: List[str]) -> Dict:\n    \"\"\"\n    Evaluates multiple distance metrics to determine which one best captures the similarity\n    between matching rows in matrices A and B.\n    Parameters:\n    - A: np.ndarray of shape (n_samples, n_features)\n    - B: np.ndarray of shape (n_samples, n_features)\n    - metrics: List of distance metrics to evaluate\n    Returns:\n    - results: Dictionary containing evaluation metrics for each distance metric",
        "detail": "ARCADIA.src.arcadia.archetypes.metrics",
        "documentation": {}
    },
    {
        "label": "get_archetype_colors",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def get_archetype_colors(n_archetypes):\n    \"\"\"Get consistent colors for archetypes across all visualization functions.\"\"\"\n    colors = plt.cm.tab10(np.linspace(0, 1, n_archetypes))\n    return {i: colors[i] for i in range(n_archetypes)}\ndef shift_data_for_origin_placement(umap_coords, archetypes, margin_factor=0.1):\n    \"\"\"\n    Shift UMAP coordinates and archetypes to position origin (0,0) down-left from data.\n    Parameters:\n    -----------\n    umap_coords : np.ndarray",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "shift_data_for_origin_placement",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def shift_data_for_origin_placement(umap_coords, archetypes, margin_factor=0.1):\n    \"\"\"\n    Shift UMAP coordinates and archetypes to position origin (0,0) down-left from data.\n    Parameters:\n    -----------\n    umap_coords : np.ndarray\n        UMAP coordinates of shape (n_cells, 2)\n    archetypes : np.ndarray\n        Archetype coordinates of shape (n_archetypes, 2)\n    margin_factor : float",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "get_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def get_archetypes(umap_coords, k=6):\n    \"\"\"Get archetypes from UMAP coordinates.\"\"\"\n    archetypes, archetype_activities, _, _, _ = PCHA(umap_coords.T, noc=k)\n    # Use precomputed cell weights from PCHA archetype_activities (transposed to match expected shape)\n    cell_weights = np.array(archetype_activities).T\n    return archetypes, cell_weights\ndef plot_umap_with_archetypes(\n    adata,\n    archetypes,\n    cell_weights,",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_umap_with_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_umap_with_archetypes(\n    adata,\n    archetypes,\n    cell_weights,\n    title=\"RNA UMAP with Archetypes\",\n    use_extreme_markers=False,\n    plot_flag=True,\n):\n    \"\"\"Plot UMAP with archetypes and cell assignments.\"\"\"\n    if not plot_flag:",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_umap_with_celltypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_umap_with_celltypes(\n    adata,\n    archetypes=None,\n    title=\"RNA UMAP with Cell Types\",\n    use_extreme_markers=False,\n    plot_flag=True,\n):\n    \"\"\"Plot UMAP with cell types and archetypes (optional).\"\"\"\n    if not plot_flag:\n        return",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_cell_archetype_combination",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_cell_archetype_combination(\n    umap_coords,\n    archetypes,\n    cell_weights,\n    n_cells=1,\n    seed=56,\n    use_extreme_markers=False,\n    plot_flag=True,\n):\n    \"\"\"Plot cells as combinations of archetypes.\"\"\"",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetype_vectors",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_archetype_vectors(\n    umap_coords, archetypes, cell_weights=None, use_extreme_markers=False, plot_flag=True\n):\n    \"\"\"Plot cells colored by archetype assignment with Archetypes.\"\"\"\n    if not plot_flag:\n        return\n    # Shift coordinates to position origin down-left from data\n    shifted_umap_coords, shifted_archetypes = shift_data_for_origin_placement(\n        umap_coords, archetypes\n    )",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetype_vectors_with_arrows",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_archetype_vectors_with_arrows(\n    umap_coords,\n    archetypes,\n    cell_weights,\n    n_cells=2,\n    seed=42,\n    threshold=0.05,\n    use_extreme_markers=False,\n    plot_flag=True,\n):",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetypes_with_cell_arch_label",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_archetypes_with_cell_arch_label(\n    umap_coords,\n    archetypes,\n    cell_weights,\n    n_cells=2,\n    seed=871,\n    threshold=0.5,\n    use_extreme_markers=False,\n    plot_flag=True,\n):",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_archetypes(\n    data_points,\n    archetype,\n    samples_cell_types: List[str],\n    data_point_archetype_indices: List[int],\n    modality=\"\",\n    cell_type_colors: Dict[str, Any] = None,\n    max_points=2000,\n    plot_flag=True,\n    plot_pca=True,",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "archetype_vs_latent_distances_plot",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def archetype_vs_latent_distances_plot(\n    archetype_dis_tensor, latent_distances, threshold, use_subsample=True\n):\n    if use_subsample:\n        subsample_indexes = torch.tensor(np.arange(min(300, archetype_dis_tensor.shape[0])))\n    else:\n        subsample_indexes = torch.tensor(np.arange(archetype_dis_tensor.shape[0]))\n    archetype_dis_tensor_ = archetype_dis_tensor.detach().cpu()\n    archetype_dis_tensor_ = torch.index_select(\n        archetype_dis_tensor_, 0, subsample_indexes",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetypes_matching",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_archetypes_matching(data1, data2, rows=5, max_cols=20, plot_flag=True):\n    \"\"\"Plot archetype matching between two modalities.\n    Parameters:\n    -----------\n    data1: DataFrame\n        First modality archetype data\n    data2: DataFrame\n        Second modality archetype data\n    rows: int\n        Number of rows to plot",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetype_umap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_archetype_umap(adata_combined, save_path=None):\n    \"\"\"Generate UMAP visualization of archetype vectors.\"\"\"\n    print(\"Generating UMAP visualization...\")\n    # Compute UMAP with cosine distance\n    sc.pp.neighbors(adata_combined, use_rep=\"X\", metric=\"cosine\", n_neighbors=15)\n    sc.tl.umap(adata_combined)\n    # Plot by modality\n    plt.figure(figsize=(12, 10))\n    ax1 = plt.subplot(2, 2, 1)\n    sc.pl.umap(adata_combined, color=\"modality\", ax=ax1, show=False, title=\"Modality\")",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetype_heatmap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_archetype_heatmap(adata_rna, adata_prot, n_samples=50, save_path=None):\n    \"\"\"Plot heatmap of archetype vectors for a sample of cells.\"\"\"\n    print(\"Generating archetype vector heatmaps...\")\n    # Subsample for visualization\n    if len(adata_rna) > n_samples:\n        rna_sample = sc.pp.subsample(adata_rna, n_obs=n_samples, copy=True)\n    else:\n        rna_sample = adata_rna.copy()\n    if len(adata_prot) > n_samples:\n        prot_sample = sc.pp.subsample(adata_prot, n_obs=n_samples, copy=True)",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_matching_accuracy_by_cell_type",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_matching_accuracy_by_cell_type(adata_rna, adata_prot, prot_matches_in_rna, save_path=None):\n    \"\"\"Plot matching accuracy by cell type.\"\"\"\n    print(\"Generating cell type matching accuracy plot...\")\n    # Calculate matching by cell type\n    matches = (\n        adata_rna.obs[\"cell_types\"].values[prot_matches_in_rna]\n        == adata_prot.obs[\"cell_types\"].values\n    )\n    # Group by cell type\n    prot_cell_types = adata_prot.obs[\"cell_types\"].values",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_distance_comparison",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_distance_comparison(matching_distances, rand_matching_distances, save_path=None):\n    \"\"\"Plot comparison of actual vs random matching distances.\"\"\"\n    print(\"Generating distance comparison plot...\")\n    plt.figure(figsize=(12, 6))\n    # Plot distance distributions\n    plt.subplot(1, 2, 1)\n    sns.histplot(matching_distances, kde=True, color=\"blue\", label=\"Actual matches\")\n    sns.histplot(rand_matching_distances, kde=True, color=\"red\", label=\"Random matches\")\n    plt.title(\"Distribution of Matching Distances\")\n    plt.xlabel(\"Distance\")",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "create_tsne_visualization",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def create_tsne_visualization(rna_archetype, prot_archetype, save_path=None):\n    \"\"\"Create t-SNE visualization of RNA and protein archetype vectors.\"\"\"\n    print(\"Generating t-SNE visualization...\")\n    # Subsample if very large\n    max_cells = 2000\n    if len(rna_archetype) > max_cells:\n        rna_sample = sc.pp.subsample(rna_archetype, n_obs=max_cells, copy=True)\n    else:\n        rna_sample = rna_archetype.copy()\n    if len(prot_archetype) > max_cells:",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "match_cells_using_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def match_cells_using_archetypes(adata_rna, adata_prot):\n    \"\"\"Match cells between modalities using archetype vectors with cosine distance.\"\"\"\n    # Since we already converted the objects to have archetype vectors as X,\n    # we can directly use their X matrices\n    # Calculate pairwise distances using cosine distance\n    print(\"Calculating pairwise cosine distances between archetype vectors...\")\n    latent_distances = batched_cosine_dist(adata_rna.X, adata_prot.X)\n    # Find matches\n    prot_matches_in_rna = np.argmin(latent_distances, axis=0)\n    matching_distances = np.min(latent_distances, axis=0)",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "calculate_post_training_metrics_on_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def calculate_post_training_metrics_on_archetypes(adata_rna, adata_prot, prot_matches_in_rna):\n    \"\"\"Calculate various metrics for model evaluation using archetype vectors.\"\"\"\n    # Calculate NMI scores\n    nmi_cell_types_cn_rna = adjusted_mutual_info_score(\n        adata_rna.obs[\"cell_types\"], adata_rna.obs[\"CN\"]\n    )\n    nmi_cell_types_cn_prot = adjusted_mutual_info_score(\n        adata_prot.obs[\"cell_types\"], adata_prot.obs[\"CN\"]\n    )\n    nmi_cell_types_modalities = adjusted_mutual_info_score(",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "process_archetype_spaces",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def process_archetype_spaces(adata_rna, adata_prot):\n    \"\"\"Process archetype spaces from RNA and protein data.\"\"\"\n    print(\"Processing archetype spaces...\")\n    # Since we now have archetype vectors as X, we can use the objects directly\n    rna_archetype = adata_rna.copy()\n    prot_archetype = adata_prot.copy()\n    # Combine for visualization\n    combined_archetype = anndata.concat(\n        [rna_archetype, prot_archetype],\n        join=\"outer\",",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "calculate_metrics_for_archetypes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def calculate_metrics_for_archetypes(adata_rna, adata_prot, prefix=\"\", subsample_size=None):\n    \"\"\"Calculate metrics using archetype vectors instead of latent space.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n        prefix: Prefix for metric names (e.g., \"train_\" or \"val_\")\n        subsample_size: If not None, subsample the data to this size\n    \"\"\"\n    print(f\"Calculating {prefix}metrics on archetype vectors...\")\n    # Subsample if requested",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_archetype_proportions_before_after_matching",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_archetype_proportions_before_after_matching(\n    batch_proportions_before: Dict[str, List[pd.DataFrame]],\n    batch_proportions_after: Dict[str, List[pd.DataFrame]] = None,\n    k_matched_results: Dict[int, Dict] = None,\n    batch_archetypes: Dict[str, Dict] = None,\n    optimal_k: int = None,\n    modality_names: List[str] = None,\n    cell_type_colors: Dict[str, str] = None,\n    plot_flag: bool = True,\n    save_plots: bool = False,",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "plot_cross_modal_archetype_comparison",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def plot_cross_modal_archetype_comparison(\n    global_proportions_mod1: Dict[int, pd.DataFrame],\n    global_proportions_mod2: Dict[int, pd.DataFrame],\n    optimal_k: int,\n    modality_names: List[str] = [\"RNA\", \"Protein\"],\n    cell_type_colors: Dict[str, str] = None,\n    cross_modal_orders: Dict[int, np.ndarray] = None,\n    archetype_quality_dict: Dict[int, bool] = None,\n    similarity_scores: np.ndarray = None,\n    quality_threshold: float = None,",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "visualize_archetype_proportions_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "def visualize_archetype_proportions_analysis(\n    adata_rna: AnnData,\n    adata_prot: AnnData,\n    plot_flag: bool = True,\n) -> None:\n    \"\"\"\n    Visualize archetype proportions analysis including the archetype matching plot.\n    This function creates the visualization that shows pairs of lines (one from each modality)\n    where each pair represents the proportion of cell types for a given archetype.\n    Args:",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_FIGURE_SIZE",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_FIGURE_SIZE = (12, 8)\nSTANDARD_CELL_SIZE = 30\nSTANDARD_EXTREME_CELL_SIZE = 100\nSTANDARD_ARCHETYPE_SIZE = 500\nSTANDARD_ORIGIN_SIZE = 300\nSTANDARD_TARGET_SIZE = 200\nSTANDARD_CELL_ALPHA = 0.6\nSTANDARD_EXTREME_ALPHA = 1.0\nSTANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_CELL_SIZE",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_CELL_SIZE = 30\nSTANDARD_EXTREME_CELL_SIZE = 100\nSTANDARD_ARCHETYPE_SIZE = 500\nSTANDARD_ORIGIN_SIZE = 300\nSTANDARD_TARGET_SIZE = 200\nSTANDARD_CELL_ALPHA = 0.6\nSTANDARD_EXTREME_ALPHA = 1.0\nSTANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_EXTREME_CELL_SIZE",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_EXTREME_CELL_SIZE = 100\nSTANDARD_ARCHETYPE_SIZE = 500\nSTANDARD_ORIGIN_SIZE = 300\nSTANDARD_TARGET_SIZE = 200\nSTANDARD_CELL_ALPHA = 0.6\nSTANDARD_EXTREME_ALPHA = 1.0\nSTANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_ARCHETYPE_SIZE",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_ARCHETYPE_SIZE = 500\nSTANDARD_ORIGIN_SIZE = 300\nSTANDARD_TARGET_SIZE = 200\nSTANDARD_CELL_ALPHA = 0.6\nSTANDARD_EXTREME_ALPHA = 1.0\nSTANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_ORIGIN_SIZE",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_ORIGIN_SIZE = 300\nSTANDARD_TARGET_SIZE = 200\nSTANDARD_CELL_ALPHA = 0.6\nSTANDARD_EXTREME_ALPHA = 1.0\nSTANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_TARGET_SIZE",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_TARGET_SIZE = 200\nSTANDARD_CELL_ALPHA = 0.6\nSTANDARD_EXTREME_ALPHA = 1.0\nSTANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_CELL_ALPHA",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_CELL_ALPHA = 0.6\nSTANDARD_EXTREME_ALPHA = 1.0\nSTANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions\ndef get_archetype_colors(n_archetypes):",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_EXTREME_ALPHA",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_EXTREME_ALPHA = 1.0\nSTANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions\ndef get_archetype_colors(n_archetypes):\n    \"\"\"Get consistent colors for archetypes across all visualization functions.\"\"\"",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_GRID_ALPHA",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_GRID_ALPHA = 0.3\nSTANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions\ndef get_archetype_colors(n_archetypes):\n    \"\"\"Get consistent colors for archetypes across all visualization functions.\"\"\"\n    colors = plt.cm.tab10(np.linspace(0, 1, n_archetypes))",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_TEXT_SIZE",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_TEXT_SIZE = 14\nSTANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions\ndef get_archetype_colors(n_archetypes):\n    \"\"\"Get consistent colors for archetypes across all visualization functions.\"\"\"\n    colors = plt.cm.tab10(np.linspace(0, 1, n_archetypes))\n    return {i: colors[i] for i in range(n_archetypes)}",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_LEGEND_SIZE",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_LEGEND_SIZE = 10\nSTANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions\ndef get_archetype_colors(n_archetypes):\n    \"\"\"Get consistent colors for archetypes across all visualization functions.\"\"\"\n    colors = plt.cm.tab10(np.linspace(0, 1, n_archetypes))\n    return {i: colors[i] for i in range(n_archetypes)}\ndef shift_data_for_origin_placement(umap_coords, archetypes, margin_factor=0.1):",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_ARROW_HEAD_WIDTH",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_ARROW_HEAD_WIDTH = 0.8\nSTANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions\ndef get_archetype_colors(n_archetypes):\n    \"\"\"Get consistent colors for archetypes across all visualization functions.\"\"\"\n    colors = plt.cm.tab10(np.linspace(0, 1, n_archetypes))\n    return {i: colors[i] for i in range(n_archetypes)}\ndef shift_data_for_origin_placement(umap_coords, archetypes, margin_factor=0.1):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_ARROW_HEAD_LENGTH",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_ARROW_HEAD_LENGTH = 1.0\nSTANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions\ndef get_archetype_colors(n_archetypes):\n    \"\"\"Get consistent colors for archetypes across all visualization functions.\"\"\"\n    colors = plt.cm.tab10(np.linspace(0, 1, n_archetypes))\n    return {i: colors[i] for i in range(n_archetypes)}\ndef shift_data_for_origin_placement(umap_coords, archetypes, margin_factor=0.1):\n    \"\"\"\n    Shift UMAP coordinates and archetypes to position origin (0,0) down-left from data.",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "STANDARD_ARROW_LINE_WIDTH",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.archetypes.visualization",
        "description": "ARCADIA.src.arcadia.archetypes.visualization",
        "peekOfCode": "STANDARD_ARROW_LINE_WIDTH = 3\n# Global color scheme for consistent archetype coloring across all functions\ndef get_archetype_colors(n_archetypes):\n    \"\"\"Get consistent colors for archetypes across all visualization functions.\"\"\"\n    colors = plt.cm.tab10(np.linspace(0, 1, n_archetypes))\n    return {i: colors[i] for i in range(n_archetypes)}\ndef shift_data_for_origin_placement(umap_coords, archetypes, margin_factor=0.1):\n    \"\"\"\n    Shift UMAP coordinates and archetypes to position origin (0,0) down-left from data.\n    Parameters:",
        "detail": "ARCADIA.src.arcadia.archetypes.visualization",
        "documentation": {}
    },
    {
        "label": "synthetic_palette",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.assets.color_palletes",
        "description": "ARCADIA.src.arcadia.assets.color_palletes",
        "peekOfCode": "synthetic_palette = {\n    \"B cells\": \"#2ecc71\",  # green\n    \"CD4 T\": \"#e67e22\",  # orange\n    \"CD8 T\": \"#3498db\",  # blue\n    \"GD/NK T\": \"#9b59b6\",  # purple # note that \"T cells\" was renamed to this category\n    \"cDCs\": \"#e74c3c\",  # red\n    # family color is green\n    \"Mature B\": \"#2ecc71\",  # bright green\n    \"Transitional B\": \"#1abc9c\",  # sea green\n    \"Ifit3-high B\": \"#66cc00\",  # lime green",
        "detail": "ARCADIA.src.arcadia.assets.color_palletes",
        "documentation": {}
    },
    {
        "label": "tonsil_palette",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.assets.color_palletes",
        "description": "ARCADIA.src.arcadia.assets.color_palletes",
        "peekOfCode": "tonsil_palette = {\n    # B cell family color is green\n    \"B-CD22-CD40\": \"#996633\",  # light brown\n    \"B-Ki67\": \"#8B0000\",  # dark red\n    \"Plasma\": \"#58d68d\",  # light green\n    \"CD4 T\": \"#e67e22\",  # orange\n    \"CD8 T\": \"#3498db\",  # blue\n    \"DC\": \"#9b59b6\",  # purple\n    \"CN_0\": \"#1f77b4\",  # tableau blue\n    \"CN_1\": \"#ff7f0e\",  # tableau orange",
        "detail": "ARCADIA.src.arcadia.assets.color_palletes",
        "documentation": {}
    },
    {
        "label": "MatSqrt",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.covet.core",
        "description": "ARCADIA.src.arcadia.covet.core",
        "peekOfCode": "def MatSqrt(Mats):\n    \"\"\"\n    Compute matrix square root for batch of matrices\n    :param Mats: 3D array of shape (n_cells, n_genes, n_genes)\n    :return: Matrix square roots\n    \"\"\"\n    e, v = np.linalg.eigh(Mats)\n    e = np.where(e < 0, 0, e)  # Ensure positive eigenvalues\n    e = np.sqrt(e)\n    m, n = e.shape",
        "detail": "ARCADIA.src.arcadia.covet.core",
        "documentation": {}
    },
    {
        "label": "BatchKNN",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.covet.core",
        "description": "ARCADIA.src.arcadia.covet.core",
        "peekOfCode": "def BatchKNN(data, batch, k):\n    \"\"\"\n    Compute k-nearest neighbors within batches\n    :param data: spatial coordinates\n    :param batch: batch labels\n    :param k: number of neighbors\n    :return: neighbor indices\n    \"\"\"\n    kNNGraphIndex = np.zeros(shape=(data.shape[0], k))\n    for val in np.unique(batch):",
        "detail": "ARCADIA.src.arcadia.covet.core",
        "documentation": {}
    },
    {
        "label": "CalcCovMats",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.covet.core",
        "description": "ARCADIA.src.arcadia.covet.core",
        "peekOfCode": "def CalcCovMats(spatial_data, kNN, genes, spatial_key=\"spatial\", batch_key=-1):\n    \"\"\"\n    Calculate COVET covariance matrices using shifted covariance\n    :param spatial_data: AnnData object with spatial transcriptomics data\n    :param kNN: number of nearest neighbors to define niche\n    :param genes: list of gene names to use for covariance calculation\n    :param spatial_key: key for spatial coordinates in obsm\n    :param batch_key: key for batch information, or -1 for no batch\n    :return: 3D array of covariance matrices (n_cells, n_genes, n_genes)\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.covet.core",
        "documentation": {}
    },
    {
        "label": "compute_covet",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.covet.core",
        "description": "ARCADIA.src.arcadia.covet.core",
        "peekOfCode": "def compute_covet(spatial_data, k=8, g=64, genes=[], spatial_key=\"spatial\", batch_key=\"batch\"):\n    \"\"\"\n    Compute COVET representation for spatial transcriptomics data\n    :param spatial_data: AnnData object with spatial coordinates in obsm\n    :param k: number of nearest neighbors to define cellular niche (default 8)\n    :param g: number of highly variable genes to use (default 64, -1 for all genes)\n    :param genes: additional genes to include in covariance calculation\n    :param spatial_key: obsm key with spatial coordinates (default 'spatial')\n    :param batch_key: obs key with batch information (default 'batch')\n    :return: (COVET, COVET_SQRT, CovGenes)",
        "detail": "ARCADIA.src.arcadia.covet.core",
        "documentation": {}
    },
    {
        "label": "prepare_data",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.covet.integration",
        "description": "ARCADIA.src.arcadia.covet.integration",
        "peekOfCode": "def prepare_data(\n    adata: AnnData,\n    covet_k: int = 8,\n    covet_g: int = 64,\n    layer: str = None,\n    covet_selection_method: Literal[\"high_variability\", \"low_redundancy\"] = \"high_variability\",\n    mutual_info_threshold: Optional[float] = None,\n    mi_sample_size: Optional[int] = None,\n    fast_mi: bool = True,\n    apply_pca: bool = False,",
        "detail": "ARCADIA.src.arcadia.covet.integration",
        "documentation": {}
    },
    {
        "label": "extract_lower_triangle",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.covet.utils",
        "description": "ARCADIA.src.arcadia.covet.utils",
        "peekOfCode": "def extract_lower_triangle(matrix):\n    \"\"\"\n    Extract lower triangle of matrix and flatten it.\n    Ensures numerical stability by handling potential NaN or Inf values.\n    \"\"\"\n    # Handle potential numerical issues\n    matrix = np.nan_to_num(matrix)\n    # Extract lower triangle\n    n = matrix.shape[0]\n    rows, cols = np.tril_indices(n, k=-1)",
        "detail": "ARCADIA.src.arcadia.covet.utils",
        "documentation": {}
    },
    {
        "label": "generate_covet_feature_names",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.covet.utils",
        "description": "ARCADIA.src.arcadia.covet.utils",
        "peekOfCode": "def generate_covet_feature_names(cov_genes):\n    \"\"\"\n    Generate COVET feature names based on protein pairs from the covariance matrix.\n    Args:\n        cov_genes: List or array of gene/protein names used for COVET computation\n    Returns:\n        List of feature names corresponding to lower triangle elements\n    \"\"\"\n    cov_genes = np.array(cov_genes)\n    n_genes = len(cov_genes)",
        "detail": "ARCADIA.src.arcadia.covet.utils",
        "documentation": {}
    },
    {
        "label": "compute_mi_batch",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.covet.utils",
        "description": "ARCADIA.src.arcadia.covet.utils",
        "peekOfCode": "def compute_mi_batch(covet_indices, X_covet_data, X_protein_data, use_fast_mi=True):\n    \"\"\"Compute max MI/correlation for a batch of COVET features\"\"\"\n    mi_scores_batch = []\n    for covet_idx in covet_indices:\n        covet_feature = X_covet_data[:, covet_idx]\n        if use_fast_mi:\n            # Ultra-fast correlation-based approximation\n            correlations = np.abs(np.corrcoef(covet_feature, X_protein_data.T)[0, 1:])\n            # Convert correlation to MI-like score: -0.5 * log(1 - r^2)\n            correlations = np.clip(correlations, 0, 0.9999)  # Avoid log(0)",
        "detail": "ARCADIA.src.arcadia.covet.utils",
        "documentation": {}
    },
    {
        "label": "sanitize_for_h5ad",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.cleaning",
        "description": "ARCADIA.src.arcadia.data_utils.cleaning",
        "peekOfCode": "def sanitize_for_h5ad(obj):\n    if isinstance(obj, dict):\n        # convert all keys to str and recurse on values\n        return {str(k): sanitize_for_h5ad(v) for k, v in obj.items()}\n    elif isinstance(obj, (list, tuple, set)):\n        return [sanitize_for_h5ad(v) for v in obj]  # HDF5 cant store sets/tuples; list is safer\n    elif isinstance(obj, pd.DataFrame):\n        return obj  # DataFrames are supported in AnnData containers\n    elif isinstance(obj, np.ndarray) and obj.dtype == object:\n        # try to convert object arrays to strings to avoid ambiguous types",
        "detail": "ARCADIA.src.arcadia.data_utils.cleaning",
        "documentation": {}
    },
    {
        "label": "clean_uns_for_h5ad",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.cleaning",
        "description": "ARCADIA.src.arcadia.data_utils.cleaning",
        "peekOfCode": "def clean_uns_for_h5ad(adata: AnnData):\n    # Sanitize uns recursively\n    adata.uns = sanitize_for_h5ad(dict(adata.uns))\n    # Ensure container keys are strings\n    adata.obsm = {str(k): v for k, v in dict(adata.obsm).items()}\n    adata.varm = {str(k): v for k, v in dict(adata.varm).items()}\n    adata.obsp = {str(k): v for k, v in dict(adata.obsp).items()}\n    adata.varp = {str(k): v for k, v in dict(adata.varp).items()}\n    # Ensure column names are strings\n    adata.obs.columns = adata.obs.columns.astype(str)",
        "detail": "ARCADIA.src.arcadia.data_utils.cleaning",
        "documentation": {}
    },
    {
        "label": "get_latest_file",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def get_latest_file(\n    folder, prefix, index_from_end=0, dataset_name=None, exact_step=None\n) -> Optional[str]:\n    \"\"\"\n    Get the latest file with given prefix from folder.\n    With new naming convention (e.g., 0_rna_2025-01-01-12-00-00.h5ad), finds files from exact step.\n    Args:\n        folder: Base folder to search in\n        prefix: File prefix to match (e.g., \"rna\", \"protein\")\n        index_from_end: Index from end of sorted files (0 = latest/highest number)",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "load_adata_latest",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def load_adata_latest(\n    folder, file_prefixes, dataset_name=None, exact_step=None, index_from_end=0, return_path=False\n):\n    \"\"\"\n    Load the latest AnnData files with dataset-specific support.\n    With new naming convention, looks for files like #_rna_timestamp.h5ad, #_protein_timestamp.h5ad.\n    Automatically adds source file information to pipeline metadata for the calling step.\n    Args:\n        folder: Base folder containing processed data\n        file_prefixes: Dict, list, or string of modality names to load (e.g., \"rna\", \"protein\")",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "save_processed_data",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def save_processed_data(adata_rna, adata_prot, save_dir, caller_filename=None):\n    for col in adata_rna.obs.columns:\n        if adata_rna.obs[col].dtype == \"object\":\n            adata_rna.obs[col] = adata_rna.obs[col].astype(str)\n    for col in adata_prot.obs.columns:\n        if adata_prot.obs[col].dtype == \"object\":\n            adata_prot.obs[col] = adata_prot.obs[col].astype(str)\n    # Use provided filename or fallback to detection\n    if caller_filename:\n        caller_file = caller_filename",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "validate_adata_requirements",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def validate_adata_requirements(adata_rna, adata_prot):\n    \"\"\"\n    Validate that both datasets have all required layers and metadata.\n    Args:\n        adata_rna: RNA-seq AnnData object\n        adata_prot: Protein (CODEX) AnnData object\n    Raises:\n        ValueError: If required data is missing\n    \"\"\"\n    print(\" Validating dataset requirements...\")",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "read_legacy_adata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def read_legacy_adata(file_path: str) -> ad.AnnData:\n    \"\"\"\n    Read legacy adata that cannot be loaded (mouse_ICB_scRNA_umap_labelled.h5ad)\n    Input: file_path\n    Output: adata\n    \"\"\"\n    def extract_table(group):\n        \"\"\"Extract DataFrame from group (skip _index)\"\"\"\n        data = {}\n        for key in group.keys():",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "load_cite_seq_data",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def load_cite_seq_data(batches):\n    \"\"\"Load and process CITE-seq spleen lymph node data from scVI.\n    Args:\n        batches: List of batch names to load (e.g., [\"SLN111-D1\", \"SLN208-D1\"])\n    Returns:\n        AnnData: Combined CITE-seq data with RNA and protein expression\n    \"\"\"\n    print(\"Loading CITE-seq spleen lymph node data...\")\n    adata = scvi.data.spleen_lymph_cite_seq(save_path=\"raw_datasets/cite_seq\")\n    adata = adata[adata.obs[\"batch\"].isin(batches)]",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "load_cite_seq_rna",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def load_cite_seq_rna(adata_cite_seq):\n    \"\"\"Load and process RNA data from CITE-seq dataset.\n    Args:\n        adata_cite_seq: AnnData object from load_cite_seq_data()\n    Returns:\n        AnnData: RNA data with proper layers and metadata\n    \"\"\"\n    print(\"Processing RNA data from CITE-seq...\")\n    print(\"Using all available batches for better cell type diversity\")\n    print(\"Available batches and their sizes:\")",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "load_cite_seq_protein",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def load_cite_seq_protein(adata_cite_seq, major_to_minor_dict):\n    \"\"\"Load and process protein data with synthetic spatial coordinates.\n    Args:\n        adata_cite_seq: AnnData object from load_cite_seq_data()\n        major_to_minor_dict: Dictionary mapping major cell types to minor subtypes\n    Returns:\n        AnnData: Protein data with synthetic spatial coordinates\n    \"\"\"\n    print(\"Processing protein data from CITE-seq...\")\n    adata_prot = ad.AnnData(adata_cite_seq.obsm[\"protein_expression\"], dtype=np.float32)",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "check_tonsil_data_exists",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def check_tonsil_data_exists(data_dir):\n    \"\"\"Check if required Tonsil data files exist.\n    Args:\n        data_dir: Path to data directory\n    Returns:\n        bool: True if all required files exist\n    \"\"\"\n    required_files = [\n        \"tonsil/tonsil_codex.csv\",\n        \"tonsil/tonsil_rna_counts.txt\",",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "download_tonsil_data",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def download_tonsil_data(data_dir):\n    \"\"\"Download and extract MaxFuse Tonsil data.\n    Args:\n        data_dir: Path to data directory\n    \"\"\"\n    if check_tonsil_data_exists(data_dir):\n        print(\"Data files already exist, skipping download.\")\n        return\n    print(\"Downloading MaxFuse data...\")\n    r = requests.get(\"http://stat.wharton.upenn.edu/~zongming/maxfuse/data.zip\")",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "load_tonsil_protein",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def load_tonsil_protein(data_dir):\n    \"\"\"Load and process Tonsil protein data.\n    Args:\n        data_dir: Path to data directory\n    Returns:\n        AnnData: Protein data with spatial coordinates\n    \"\"\"\n    print(\"Loading protein data...\")\n    protein = pd.read_csv(data_dir / \"tonsil/tonsil_codex.csv\")\n    protein_features = [",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "load_tonsil_rna",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.loading",
        "description": "ARCADIA.src.arcadia.data_utils.loading",
        "peekOfCode": "def load_tonsil_rna(data_dir):\n    \"\"\"Load and process Tonsil RNA data.\n    Args:\n        data_dir: Path to data directory\n    Returns:\n        AnnData: RNA data with metadata\n    \"\"\"\n    print(\"Loading RNA data...\")\n    rna = mmread(data_dir / \"tonsil/tonsil_rna_counts.txt\")\n    rna_names = pd.read_csv(data_dir / \"tonsil/tonsil_rna_names.csv\")[\"names\"].to_numpy()",
        "detail": "ARCADIA.src.arcadia.data_utils.loading",
        "documentation": {}
    },
    {
        "label": "balance_datasets",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def balance_datasets(\n    adata_rna: AnnData, adata_prot: AnnData, plot_flag: bool = False, flexibility: float = 0.1\n):\n    \"\"\"\n    Balance the datasets based on the cell type proportions per batch.\n    Each batch (regardless of modality) is treated independently.\n    Finds the smallest/limiting batch and balances all batches to match its proportions.\n    Args:\n        adata_prot (AnnData): Protein assay AnnData object containing cell type annotations\n            in .obs[\"cell_types\"] and batch information in .obs[\"batch\"].",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "create_smart_neighbors",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def create_smart_neighbors(adata_prot: sc.AnnData, percentile_threshold: int = 95) -> sc.AnnData:\n    \"\"\"\n    Creates smart neighbors for the protein data by protecting the 5 closest neighbors for each cell\n    and then filtering the neighbors based on the distance threshold\n    \"\"\"\n    spatial_distances = adata_prot.obsp[\"spatial_neighbors_distances\"]\n    connectivities = adata_prot.obsp[\"spatial_neighbors_connectivities\"]\n    percentile_threshold = 95\n    percentile_value = np.percentile(spatial_distances.data, percentile_threshold)\n    # here we want to protect the 5 closest neighbors for each cell, since we can't have cells without neighbors",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "filter_unwanted_cell_types",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def filter_unwanted_cell_types(adata: sc.AnnData, unwanted_types: list = None) -> sc.AnnData:\n    \"\"\"Filter out specified unwanted cell types from dataset\n    Parameters:\n    -----------\n    adata : sc.AnnData\n        AnnData object to filter\n    unwanted_types : list, optional\n        List of cell types to remove. Default is [\"tumor\", \"dead\", \"nk cells\"]\n    Returns:\n    --------",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "qc_metrics",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def qc_metrics(adata: sc.AnnData, plot_flag=True) -> None:\n    \"\"\"Compute and visualize QC metrics\"\"\"\n    # use a random subset of the data\n    adata = adata[np.random.choice(adata.n_obs, size=min(adata.n_obs, 2000), replace=False), :]\n    # Use 'counts' layer if available, otherwise use current X\n    layer_to_use = \"counts\" if \"counts\" in adata.layers.keys() else None\n    sc.pp.calculate_qc_metrics(adata, layer=layer_to_use, percent_top=(10, 20, 30), inplace=True)\n    if not plot_flag:\n        return\n    # Visualize initial QC",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "balanced_subsample_by_cell_type",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def balanced_subsample_by_cell_type(adata, n_obs, cell_type_col=\"cell_types\"):\n    \"\"\"\n    Subsample cells ensuring good representation of each cell type.\n    For each cell type:\n    - If cell type has less than half of expected proportion, take all available cells\n    - Otherwise, sample proportionally\n    - Ensure total selection equals target n_obs\n    Args:\n        adata: AnnData object\n        n_obs: Target number of cells to sample",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "mad_outlier_removal",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def mad_outlier_removal(adata: sc.AnnData) -> sc.AnnData:\n    \"\"\"Cell type-aware outlier detection\"\"\"\n    print(\"\\nIdentifying outliers...\")\n    adata.obs[\"outlier\"] = False\n    # Convert cell_types to categorical if it's not already\n    if not isinstance(adata.obs[\"cell_types\"].dtype, CategoricalDtype):\n        adata.obs[\"cell_types\"] = adata.obs[\"cell_types\"].astype(\"category\")\n    # Get unique cell types (works for both categorical and non-categorical)\n    cell_types = (\n        adata.obs[\"cell_types\"].cat.categories",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "log1p_rna",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def log1p_rna(adata):\n    \"\"\"\n    Apply log1p transformation to RNA data and track in metadata.\n    Parameters:\n    -----------\n    adata : AnnData\n        AnnData object containing RNA data\n    Returns:\n    --------\n    adata : AnnData",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "z_normalize_codex",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def z_normalize_codex(adata, apply_log1p=True):\n    \"\"\"\n    https://www.frontiersin.org/journals/immunology/articles/10.3389/fimmu.2021.727626/full\n    Apply Z normalization to CODEX protein data.\n    This implements the recommended Z normalization approach for CODEX data:\n    - Normalizes each marker intensity separately across all cells\n    - Most consistent performance across different noise types\n    - Handles both low signal intensity and high background effectively\n    - Best for both rare and common cell types\n    Based on comprehensive benchmarking, Z normalization is the most effective",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "analyze_and_visualize",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def analyze_and_visualize(adata: sc.AnnData, modality: str = \"\", plot_flag=True) -> None:\n    \"\"\"Dimensionality reduction and visualization\"\"\"\n    print(\"\\nRunning dimensionality reduction...\")\n    # take a random subset of the data\n    adata = adata[np.random.choice(adata.n_obs, size=min(adata.n_obs, 2000), replace=False), :]\n    sc.pp.pca(adata, n_comps=15)\n    sc.pp.neighbors(adata, n_neighbors=15, n_pcs=10)\n    sc.tl.umap(adata)\n    if not plot_flag:\n        return",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "spatial_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def spatial_analysis(adata: sc.AnnData) -> None:\n    \"\"\"Optional spatial analysis\"\"\"\n    try:\n        import squidpy as sq\n        print(\"\\nPerforming spatial analysis...\")\n        sq.gr.spatial_neighbors(adata, coord_type=\"generic\")\n        sq.pl.spatial_scatter(\n            sc.pp.subsample(adata.copy(), n_obs=min(3000, adata.n_obs), copy=True),\n            color=\"cell_types\",\n            shape=None,",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "preprocess_rna_initial_steps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def preprocess_rna_initial_steps(adata_rna, min_genes=200, min_cells=3, plot_flag=False):\n    \"\"\"\n    Preprocess RNA data initial steps: QC and filtering ONLY (NO normalization/log transform)\n    This function should be applied to each batch separately before merging.\n    Data remains as counts/pseudo-counts for proper batch correction.\n    \"\"\"\n    print(f\"Starting initial preprocessing for batch with {adata_rna.n_obs} cells...\")\n    # Step 1: Basic filtering (without QC metrics)\n    print(\"Step 1: Basic filtering...\")\n    sc.pp.filter_cells(adata_rna, min_genes=min_genes)",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "preprocess_rna_final_steps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def preprocess_rna_final_steps(\n    adata_rna,\n    n_top_genes=2000,\n    plot_flag=False,\n    batch_correction_method=\"scANVI\",\n    gene_likelihood_dist=None,\n):\n    \"\"\"\n    Complete RNA preprocessing after merging: HVG  batch_correction\n    NO normalization, NO log transformation, NO scaling - data kept as counts!",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "order_cells_by_type",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def order_cells_by_type(adata_rna, adata_prot):\n    \"\"\"Order cells by major and minor cell types\"\"\"\n    print(\"\\nOrdering cells by major and minor cell types...\")\n    if \"minor_cell_types\" in adata_rna.obs.columns:\n        cell_type_key = \"minor_cell_types\"\n        new_order_rna = adata_rna.obs.sort_values(by=[\"major_cell_types\", cell_type_key]).index\n        new_order_prot = adata_prot.obs.sort_values(by=[\"major_cell_types\", cell_type_key]).index\n    else:\n        cell_type_key = \"cell_types\"\n        new_order_rna = adata_rna.obs.sort_values(by=[cell_type_key]).index",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "compute_pca_and_umap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def compute_pca_and_umap(adata_rna, adata_prot):\n    \"\"\"Compute PCA and UMAP for visualization\"\"\"\n    sc.pp.pca(adata_rna)\n    sc.pp.pca(adata_prot)\n    sc.pp.neighbors(adata_rna, key_added=\"original_neighbors\")\n    sc.tl.umap(adata_rna, neighbors_key=\"original_neighbors\")\n    adata_rna.obsm[\"X_original_umap\"] = adata_rna.obsm[\"X_umap\"]\n    sc.pp.neighbors(adata_prot, key_added=\"original_neighbors\")\n    sc.tl.umap(adata_prot, neighbors_key=\"original_neighbors\")\n    adata_prot.obsm[\"X_original_umap\"] = adata_prot.obsm[\"X_umap\"]",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "apply_zero_mask",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def apply_zero_mask(adata_rna: AnnData) -> AnnData:\n    # if there is a mismatch between index of adata_rna.obs and adata_rna.var, we need to reindex the zero_mask\n    zero_mask = adata_rna.obsm[\"zero_mask\"]\n    # Calculate statistics before applying zero mask\n    currently_nonzero = adata_rna.X != 0\n    currently_zero = adata_rna.X == 0\n    zero_mask = adata_rna.obsm[\"zero_mask\"]\n    # make col names upper case\n    zero_mask.columns = zero_mask.columns.str.upper()\n    zero_mask = zero_mask.loc[:, ~zero_mask.columns.duplicated()]",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "store_raw_counts_and_qc_metrics",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def store_raw_counts_and_qc_metrics(adata_rna):\n    \"\"\"\n    Step 2-3: Store raw counts and calculate QC metrics\n    \"\"\"\n    print(\"Step 2: Storing raw counts...\")\n    if \"counts\" not in adata_rna.layers:\n        adata_rna.layers[\"counts\"] = adata_rna.X.copy()\n    print(\"Step 3: Calculating QC metrics...\")\n    # Auto-detect species for mitochondrial genes\n    if adata_rna.var_names.str.startswith(\"MT-\").any():  # Human",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_rna_during_preprocessing",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def plot_rna_during_preprocessing(adata_rna, plot_flag=False, title=\"\"):\n    \"\"\"Plot RNA data during preprocessing steps\"\"\"\n    if plot_flag:\n        # Use a subsample (max 2k cells) for visualization to avoid plotting the whole dataset\n        n_plot = min(2000, adata_rna.n_obs)\n        adata_plot = sc.pp.subsample(adata_rna.copy(), n_obs=n_plot, copy=True).copy()\n        sc.pp.log1p(adata_plot)\n        sc.pp.pca(adata_plot, copy=False)\n        sc.pp.neighbors(adata_plot, copy=False)\n        sc.tl.umap(adata_plot)",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "filter_low_quality_cells",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def filter_low_quality_cells(\n    adata_rna, max_pct_mt=20, min_genes=200, min_counts=1000, plot_flag=False\n):\n    \"\"\"\n    Filter low-quality cells based on QC metrics\n    \"\"\"\n    print(\"Filtering low-quality cells...\")\n    print(f\"Before filtering: {adata_rna.n_obs} cells\")\n    # Create boolean masks for filtering\n    cell_filter = (",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "feature_selection_counts_only",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def feature_selection_counts_only(adata_rna, n_top_genes=2000, plot_flag=False):\n    \"\"\"\n    Feature selection without any normalization, log transformation, or scaling.\n    Data remains as counts/pseudo-counts throughout.\n    \"\"\"\n    print(\"Step 5: Feature selection (counts only)...\")\n    batch_key = \"batch\" if \"batch\" in adata_rna.obs else None\n    adata_rna = adata_rna[adata_rna.X.sum(axis=1) > 0].copy()\n    # HVG selection on raw counts data\n    sc.pp.highly_variable_genes(",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "evaluate_batch_correction_methods",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def evaluate_batch_correction_methods(methods, batch_key, celltype_key=None):\n    \"\"\"\n    Evaluate batch correction methods quantitatively\n    Parameters:\n    methods: list of tuples [(adata, method_name, use_rep)]\n    batch_key: column name for batch information\n    celltype_key: column name for cell type information (optional)\n    Returns:\n    best_method_name, best_adata, evaluation_results\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "generate_batch_correction_plots",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def generate_batch_correction_plots(methods, best_method_name, batch_key, celltype_key):\n    \"\"\"\n    Generate comparison plots for batch correction methods\n    \"\"\"\n    print(\"\\nGenerating UMAP visualizations...\")\n    n_methods = len(methods)\n    n_cols = 2\n    n_rows = (n_methods + 1) // 2\n    fig, axes = plt.subplots(n_rows, n_cols, figsize=(12, 5 * n_rows))\n    if n_rows == 1:",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "apply_batch_correction_pipeline",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def apply_batch_correction_pipeline(\n    adata: AnnData,\n    plot_flag: bool = False,\n    batch_correction_method: str | list[str] = \"ComBat\",\n    gene_likelihood_dist=None,\n) -> AnnData:\n    \"\"\"\n    Step 7: Comprehensive batch correction pipeline\n    \"\"\"\n    import scvi",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "harmonize_cell_types_names",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "description": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "peekOfCode": "def harmonize_cell_types_names(\n    adata_rna: AnnData, adata_prot: AnnData, harmonization_mapping\n) -> tuple[AnnData, AnnData]:\n    \"\"\"harmonize_cell_types_names harmonizes the cell types names between rna and protein anndatas\n    Input: adata_rna, adata_prot\n    1. Initialize uns[\"pipeline_metadata\"]\n    2. Writes obs[\"cell_types\"]\n    3. Removes redundant gene cols\n    4. ZIB Thresholding for RNA\n    Output: cleaned rna_adta and adata_prot",
        "detail": "ARCADIA.src.arcadia.data_utils.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_cross_modal_archetype_similarity_matrix",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_cross_modal_archetype_similarity_matrix(similarity_matrix):\n    plt.figure(figsize=(10, 8))\n    sns.heatmap(\n        similarity_matrix[:1000, :1000],\n        annot=False,\n        cmap=\"viridis\",\n        cbar_kws={\"label\": \"Cosine Distance\"},\n    )\n    plt.title(\"Cross-Modal Archetype Similarity Matrix\")\n    plt.xlabel(\"Protein Archetypes\")",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_cn_features_correlation",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_cn_features_correlation(\n    adata_prot, features_to_plot=[\"CN\", \"neighbor_mean\", \"neighbor_variance\"], plot_flag=True\n):\n    \"\"\"\n    Plot the correlation between CN types and spatial features.\n    \"\"\"\n    if not plot_flag:\n        return\n    # Check if feature_type column exists\n    if \"feature_type\" not in adata_prot.var.columns:",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_archetype_vs_latent_distances",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_archetype_vs_latent_distances(archetype_dis_tensor, latent_distances, threshold):\n    \"\"\"Plot archetype vs latent distances\"\"\"\n    logger.info(\"Plotting archetype vs latent distances...\")\n    fig, axes = plt.subplots(1, 2, figsize=(10, 5))\n    # Plot archetype distances\n    axes[0].hist(archetype_dis_tensor.detach().cpu().numpy().flatten(), bins=50)\n    axes[0].axvline(x=threshold, color=\"r\", linestyle=\"--\", label=f\"Threshold: {threshold}\")\n    axes[0].set_title(\"Archetype Distances\")\n    axes[0].legend()\n    # Plot latent distances",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_archetype_embedding",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_archetype_embedding(adata_rna, adata_prot, use_subsample=True):\n    \"\"\"Plot archetype embedding\"\"\"\n    # Create AnnData objects from archetype vectors\n    rna_archtype = AnnData(adata_rna.obsm[\"archetype_vec\"])\n    rna_archtype.obs = adata_rna.obs.copy()\n    prot_archtype = AnnData(adata_prot.obsm[\"archetype_vec\"])\n    prot_archtype.obs = adata_prot.obs.copy()\n    # remove the pca from the obsm to allow for neighbor to run on the latent space directly\n    rna_archtype.obsm.pop(\"X_pca\", None)\n    prot_archtype.obsm.pop(\"X_pca\", None)",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_archetype_proportions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_archetype_proportions(\n    archetype_proportion_list_rna, archetype_proportion_list_protein, max_size=20, plot_flag=True\n):\n    \"\"\"Plot archetype proportions.\"\"\"\n    if not plot_flag:\n        return\n    # Ensure matrices aren't too large\n    rna_prop = archetype_proportion_list_rna[0]\n    prot_prop = archetype_proportion_list_protein[0]\n    # If either has too many rows/columns, print warning and subsample",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_archetype_weights",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_archetype_weights(\n    best_archetype_rna_prop, best_archetype_prot_prop, row_order, max_size=20, plot_flag=True\n):\n    \"\"\"Plot archetype weights.\"\"\"\n    if not plot_flag:\n        return\n    # Ensure matrices aren't too large\n    rna_prop = pd.DataFrame(best_archetype_rna_prop)\n    prot_prop = pd.DataFrame(best_archetype_prot_prop)\n    # If row_order is too large, limit it",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_archetype_visualizations",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_archetype_visualizations(\n    adata_archetype_rna,\n    adata_archetype_prot,\n    adata_1_rna,\n    adata_2_prot,\n    max_cells=2000,\n    plot_flag=True,\n):\n    \"\"\"Plot archetype visualizations.\"\"\"\n    if not plot_flag:",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_archetype_heatmaps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_archetype_heatmaps(adata_rna: AnnData, adata_prot: AnnData, subset_size=2000):\n    # compute_archetype_distances imported at top\n    \"\"\"Plot heatmaps of archetype coordinates\"\"\"\n    step_rna = max(1, int(np.ceil(adata_rna.n_obs / subset_size)))\n    step_prot = max(1, int(np.ceil(adata_prot.n_obs / subset_size)))\n    adata_rna_subset = adata_rna[::step_rna].copy()\n    adata_prot_subset = adata_prot[::step_prot].copy()\n    archetype_distances_subset = compute_archetype_distances(adata_rna_subset, adata_prot_subset)\n    plt.figure(figsize=(10, 5))\n    plt.subplot(1, 2, 1)",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_extreme_archetypes_alignment",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_extreme_archetypes_alignment(\n    rna_latent_mean,\n    protein_latent_mean,\n    rna_batch,\n    protein_batch,\n    adata_rna,\n    adata_prot,\n    rna_indices,\n    protein_indices,\n    global_step=None,",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "plot_batch_archetype_visualization",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.archetypes",
        "description": "ARCADIA.src.arcadia.plotting.archetypes",
        "peekOfCode": "def plot_batch_archetype_visualization(\n    adata,\n    batch_name,\n    modality_name,\n    archetype_embedding_name=\"X_pca\",\n    plot_flag=True,\n    max_points=2000,\n):\n    \"\"\"\n    Plot archetype visualization for a specific batch.",
        "detail": "ARCADIA.src.arcadia.plotting.archetypes",
        "documentation": {}
    },
    {
        "label": "safe_mlflow_log_figure",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.general",
        "description": "ARCADIA.src.arcadia.plotting.general",
        "peekOfCode": "def safe_mlflow_log_figure(fig, file_path):\n    \"\"\"Safely log a figure to MLflow if an experiment is active.\"\"\"\n    try:\n        # If file_path starts with step_, save to train folder in MLflow artifacts\n        if file_path.startswith(\"step_\"):\n            # Extract step number and pad with leading zeros\n            step_num = file_path.split(\"_\")[1].split(\".\")[0]\n            padded_step = f\"{int(step_num):05d}\"\n            new_filename = f\"step_{padded_step}_{'_'.join(file_path.split('_')[2:])}\"\n            # Log to MLflow in train folder with padded step number",
        "detail": "ARCADIA.src.arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "compute_opacity_per_cell_type",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.general",
        "description": "ARCADIA.src.arcadia.plotting.general",
        "peekOfCode": "def compute_opacity_per_cell_type(\n    adata,\n    weight_col=\"matched_archetype_weight\",\n    cell_type_col=\"cell_types\",\n    alpha_min=0.15,\n    gamma=4,\n):\n    \"\"\"\n    Compute opacity values (alphas) for each cell based on matched archetype weight,\n    normalized per cell type to ensure each cell type uses the full opacity range.",
        "detail": "ARCADIA.src.arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "set_consistent_cell_type_colors",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.general",
        "description": "ARCADIA.src.arcadia.plotting.general",
        "peekOfCode": "def set_consistent_cell_type_colors(adata_rna, adata_prot):\n    \"\"\"\n    Set consistent cell type colors across both RNA and protein modalities.\n    Uses custom palettes from color_palletes.py if dataset_name matches, otherwise falls back to matplotlib colormaps.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n    Returns:\n        dict: Dictionary mapping cell types to hex colors\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "plot_data_overview",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.general",
        "description": "ARCADIA.src.arcadia.plotting.general",
        "peekOfCode": "def plot_data_overview(adata_1, adata_2, max_cells=5000, plot_flag=True):\n    \"\"\"Plot overview of RNA and protein data\"\"\"\n    if not plot_flag:\n        return\n    logger.info(\"Plotting data overview...\")\n    fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n    # Subsample if needed\n    subsample_n_obs_1 = min(max_cells, len(adata_1))\n    adata_1_sub = adata_1[np.random.choice(len(adata_1), subsample_n_obs_1, replace=False)]\n    subsample_n_obs_2 = min(max_cells, len(adata_2))",
        "detail": "ARCADIA.src.arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "plot_cell_type_distribution",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.general",
        "description": "ARCADIA.src.arcadia.plotting.general",
        "peekOfCode": "def plot_cell_type_distribution(adata_1, adata_2, max_cells=5000, plot_flag=True):\n    \"\"\"Plot cell type distribution for both datasets\"\"\"\n    if not plot_flag:\n        return\n    logger.info(\"Plotting cell type distribution...\")\n    fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n    # RNA data\n    subsample_n_obs = min(max_cells, len(adata_1))\n    adata_1_sub = adata_1[np.random.choice(len(adata_1), subsample_n_obs, replace=False)]\n    sns.countplot(data=adata_1_sub.obs, x=\"cell_types\", ax=axes[0])",
        "detail": "ARCADIA.src.arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "plot_preprocessing_results",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.general",
        "description": "ARCADIA.src.arcadia.plotting.general",
        "peekOfCode": "def plot_preprocessing_results(adata_1, adata_2, plot_flag=True):\n    \"\"\"Plot results after preprocessing\"\"\"\n    if not plot_flag:\n        return\n    logger.info(\"Plotting preprocessing results...\")\n    fig, axes = plt.subplots(2, 2, figsize=(15, 15))\n    # RNA data (log-transformed)\n    sc.pl.pca(adata_1, color=\"cell_types\", show=False, ax=axes[0, 0])\n    axes[0, 0].set_title(\"RNA PCA (Log-transformed)\")\n    sc.pl.umap(adata_1, color=\"cell_types\", show=False, ax=axes[0, 1])",
        "detail": "ARCADIA.src.arcadia.plotting.general",
        "documentation": {}
    },
    {
        "label": "plot_count_distribution",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_count_distribution(adata_rna_new, plot_flag=True):\n    \"\"\"Plot histogram of count distribution\"\"\"\n    if issparse(adata_rna_new.X):\n        data = adata_rna_new.X.data\n        if data.shape[0] > 5000:\n            sample = np.random.choice(data, size=5000, replace=False)\n        else:\n            sample = data\n    else:\n        flat = adata_rna_new.X.flatten()",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_expression_heatmap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_expression_heatmap(adata, plot_flag=True):\n    \"\"\"Plot heatmap of expression data\"\"\"\n    if not plot_flag:\n        return\n    plt.figure(figsize=(6, 4))\n    sns.heatmap(\n        adata.X.toarray()[:1000, :1000] if issparse(adata.X) else adata.X[:1000, :1000],\n        cmap=\"viridis\",\n        xticklabels=False,\n        yticklabels=False,",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_merged_dataset_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_merged_dataset_analysis(adata_rna, plot_flag=True, subsample_size=2000):\n    \"\"\"Plot analysis of merged dataset before preprocessing\"\"\"\n    if not plot_flag:\n        return\n    # used scanpy to subsample the data\n    adata_rna_subsampled = adata_rna.copy()\n    sc.pp.subsample(adata_rna_subsampled, n_obs=min(subsample_size, adata_rna.n_obs))\n    plt.figure(figsize=(10, 10))\n    if issparse(adata_rna_subsampled.X):\n        sns.heatmap(adata_rna_subsampled.X.toarray()[:100, :100], cmap=\"viridis\")",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_protein_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_protein_analysis(adata_prot, subsample_size=2000, plot_flag=True, modality=\"\"):\n    \"\"\"Plot protein data analysis\"\"\"\n    if not plot_flag:\n        return\n    adata_prot_subsampled = adata_prot.copy()\n    sc.pp.subsample(adata_prot_subsampled, n_obs=min(subsample_size, adata_prot.n_obs))\n    analyze_and_visualize(adata_prot_subsampled, modality=modality, plot_flag=plot_flag)\n    qc_metrics(adata_prot_subsampled, plot_flag=plot_flag)\n    # Use total_counts if nCount_CODEX doesn't exist\n    count_col = (",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_protein_violin",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_protein_violin(adata_prot, plot_flag=True):\n    \"\"\"Plot protein violin plots\"\"\"\n    if not plot_flag:\n        return\n    # Use total_counts if nCount_CODEX doesn't exist\n    count_col = \"nCount_CODEX\" if \"nCount_CODEX\" in adata_prot.obs.columns else \"total_counts\"\n    if count_col not in adata_prot.obs.columns:\n        print(\n            f\"Warning: Neither 'nCount_CODEX' nor 'total_counts' found in adata.obs. Skipping violin plot.\"\n        )",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_original_data_umaps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_original_data_umaps(adata_rna, adata_prot, plot_flag=True):\n    \"\"\"Plot UMAP of original RNA and protein data\"\"\"\n    if not plot_flag:\n        return\n    # use subsample to speed up the plotting\n    adata_rna_subsampled = adata_rna.copy()\n    adata_prot_subsampled = adata_prot.copy()\n    sc.pp.subsample(adata_rna_subsampled, n_obs=min(2000, adata_rna.n_obs))\n    sc.pp.subsample(adata_prot_subsampled, n_obs=min(2000, adata_prot.n_obs))\n    sc.pp.pca(adata_rna_subsampled, copy=False)",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_variance_analysis_raw",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_variance_analysis_raw(adata_rna, plot_flag=True):\n    \"\"\"Plot variance vs mean expression for raw data\"\"\"\n    if not plot_flag:\n        return\n    adata_rna_temp = adata_rna.copy()\n    batch_key = \"batch\" if \"batch\" in adata_rna_temp.obs else None\n    sc.pp.highly_variable_genes(\n        adata_rna_temp, n_top_genes=2000, batch_key=batch_key, flavor=\"seurat\"\n    )\n    plt.figure(figsize=(8, 6))",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_gene_variance_elbow",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_gene_variance_elbow(variances_sorted, plot_flag=True):\n    \"\"\"Plot elbow plot of gene variances\"\"\"\n    if not plot_flag:\n        return\n    plt.figure(figsize=(8, 6))\n    plt.plot(range(1, len(variances_sorted) + 1), variances_sorted)\n    plt.xlabel(\"Gene rank\")\n    plt.ylabel(\"Variance\")\n    plt.yscale(\"log\")\n    plt.title(\"Elbow plot of Gene Variances\")",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_kneedle_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_kneedle_analysis(kneedle, plot_flag=True):\n    \"\"\"Plot kneedle analysis\"\"\"\n    if not plot_flag:\n        return\n    kneedle.plot_knee()\ndef plot_variance_analysis_processed(adata_rna, plot_flag=True):\n    \"\"\"Plot variance vs mean expression for processed data\"\"\"\n    if not plot_flag:\n        return\n    plt.figure(figsize=(8, 6))",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_variance_analysis_processed",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_variance_analysis_processed(adata_rna, plot_flag=True):\n    \"\"\"Plot variance vs mean expression for processed data\"\"\"\n    if not plot_flag:\n        return\n    plt.figure(figsize=(8, 6))\n    plt.scatter(adata_rna.var[\"means\"], adata_rna.var[\"variances\"], alpha=0.3, label=\"All genes\")\n    plt.scatter(\n        adata_rna.var[\"means\"][adata_rna.var[\"highly_variable\"]],\n        adata_rna.var[\"variances\"][adata_rna.var[\"highly_variable\"]],\n        color=\"red\",",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_batch_correction_before",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_batch_correction_before(adata_rna, plot_flag=True):\n    \"\"\"Plot batch correction analysis before correction\"\"\"\n    if not plot_flag:\n        return\n    if \"batch\" not in adata_rna.obs.columns:\n        print(\"Warning: No batch information found, skipping batch correction plots\")\n        return\n    if adata_rna.obs[\"batch\"].nunique() == 1:\n        print(\"Warning: there is only one batch, skipping batch correction plots\")\n        return",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_batch_correction_after",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_batch_correction_after(\n    adata_rna,\n    adata_prot,\n    batch_distance_before,\n    batch_distance_after,\n    pca_distance,\n    improvement,\n    plot_flag=True,\n):\n    \"\"\"Plot batch correction analysis after correction\"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_spatial_locations",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_spatial_locations(adata_prot, plot_flag=True):\n    \"\"\"Plot spatial locations of cells\"\"\"\n    if not plot_flag:\n        return\n    sc.pl.scatter(\n        adata_prot, x=\"X\", y=\"Y\", color=\"cell_types\", title=\"cell types with spatial locations\"\n    )\ndef plot_expression_heatmaps(adata_rna, adata_prot, plot_flag=True):\n    \"\"\"Plot expression heatmaps for RNA and protein data\"\"\"\n    if not plot_flag:",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_expression_heatmaps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_expression_heatmaps(adata_rna, adata_prot, plot_flag=True):\n    \"\"\"Plot expression heatmaps for RNA and protein data\"\"\"\n    if not plot_flag:\n        return\n    num_cells = min(1000, adata_rna.n_obs, adata_prot.n_obs)\n    random_indices_protein = np.random.choice(adata_prot.n_obs, num_cells, replace=False)\n    random_indices_rna = np.random.choice(adata_rna.n_obs, num_cells, replace=False)\n    protein_data = adata_prot.X[random_indices_protein, :]\n    sns.heatmap(\n        protein_data.todense() if issparse(protein_data) else protein_data,",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_final_alignment_results",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_final_alignment_results(adata_rna, adata_prot, plot_flag=True):\n    \"\"\"Plot final preprocessing results\"\"\"\n    if not plot_flag:\n        return\n    # Compute UMAP for both datasets\n    adata_rna_to_plot = adata_rna.copy()\n    adata_prot_to_plot = adata_prot.copy()\n    sc.pp.subsample(adata_rna_to_plot, n_obs=min(2000, adata_rna.n_obs))\n    sc.pp.subsample(adata_prot_to_plot, n_obs=min(2000, adata_prot.n_obs))\n    log1p_rna(adata_rna_to_plot)",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_spatial_distance_hist",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_spatial_distance_hist(\n    adata_prot, key=\"spatial_neighbors_distances\", title=None, plot_flag=True\n):\n    if not plot_flag:\n        return\n    data = adata_prot.obsp[key].data\n    # subsample the data randomly\n    subsample_size = min(len(data), 2000)\n    data = data[np.random.choice(len(data), subsample_size, replace=False)]\n    sns.histplot(data)",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_empirical_vs_annotated_cns",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_empirical_vs_annotated_cns(adata_prot, resolution=None, plot_flag=True):\n    if (not plot_flag) or \"lab_CN\" not in adata_prot.obs or resolution is None:\n        return\n    temp_empirical = adata_prot.copy()\n    # Ensure neighbor graph exists for Leiden\n    if \"neighbors\" not in temp_empirical.obsp:\n        sc.pp.neighbors(temp_empirical)\n    sc.tl.leiden(temp_empirical, resolution=resolution, key_added=\"CN\")\n    temp_empirical.obs[\"CN\"] = pd.Categorical(\n        [f\"CN_{cn}\" for cn in temp_empirical.obs[\"CN\"]],",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_feature_type_heatmap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_feature_type_heatmap(adata, plot_flag=True):\n    if not plot_flag:\n        return\n    plt.figure(figsize=(10, 8))\n    sns.heatmap(adata.X[:1000, :1000] if not issparse(adata.X) else adata.X[:1000, :1000].toarray())\n    plt.title(\"Protein data with all features types\")\n    plt.xlabel(\"Features\")\n    plt.ylabel(\"Cells\")\n    feature_types = adata.var[\"feature_type\"]\n    unique_types = feature_types.unique()",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_original_embeddings",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_original_embeddings(adata_rna, adata_prot, plot_flag=True):\n    if not plot_flag:\n        return\n    sc.pl.embedding(\n        adata_rna,\n        basis=\"X_original_pca\",\n        color=[\"cell_types\", \"major_cell_types\"],\n        title=[\"Original RNA pca minor cell types\", \"Original RNA pca major cell types\"],\n    )\n    sc.pl.embedding(",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_original_vs_new_protein_umap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_original_vs_new_protein_umap(\n    adata_prot, original_key=\"X_original_umap\", new_key=\"X_umap\", plot_flag=True, save_flag=True\n):\n    if not plot_flag:\n        return\n    import time\n    # use a subsample to speed up the plotting\n    adata_prot_subsampled = sc.pp.subsample(\n        adata_prot, n_obs=min(2000, adata_prot.n_obs), copy=True\n    )",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_pca_feature_contributions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_pca_feature_contributions(adata_rna, adata_prot, plot_flag=True):\n    if not plot_flag:\n        return\n    rna_pca_components = adata_rna.varm[\"PCs\"]\n    plt.figure(figsize=(12, 10))\n    sns.heatmap(\n        rna_pca_components,\n        cmap=\"viridis\",\n        center=0,\n        xticklabels=range(1, rna_pca_components.shape[1] + 1),",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_hvg_and_mean_variance",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_hvg_and_mean_variance(adata_prot, plot_flag=True):\n    if not plot_flag:\n        return\n    plt.figure(figsize=(10, 6))\n    sc.pl.highly_variable_genes(adata_prot, show=True)\n    plt.title(\"Highly Variable Genes\")\n    plt.show()\n    plt.close()\n    plt.figure(figsize=(10, 6))\n    plt.scatter(",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_two_umaps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_two_umaps(\n    adata_left, color_left, title_left, adata_right, color_right, title_right, plot_flag=True\n):\n    if not plot_flag:\n        return\n    fig, axes = plt.subplots(1, 2, figsize=(16, 6))\n    sc.pl.umap(adata_left, color=color_left, ax=axes[0], show=False, title=title_left)\n    sc.pl.umap(adata_right, color=color_right, ax=axes[1], show=False, title=title_right)\n    plt.tight_layout()\n    plt.show()",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_extreme_archetype_confusion",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_extreme_archetype_confusion(\n    adata_prot, y_true_extreme, y_pred_extreme, plot_flag=True, save_flag=True\n):\n    import time\n    from sklearn.metrics import f1_score\n    if not plot_flag:\n        return\n    f1_extreme = f1_score(y_true_extreme, y_pred_extreme, average=\"weighted\")\n    scale_factor = adata_prot.uns[\"pipeline_metadata\"].get(\"scale_factor\")\n    plt.figure(figsize=(12, 10))",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_umap_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_umap_analysis(adata_temp, color_key, title, plot_flag=True):\n    \"\"\"Plot UMAP analysis for protein data\"\"\"\n    if not plot_flag:\n        return\n    sc.pl.umap(adata_temp, color=color_key, title=title, show=True)\n    plt.show()\ndef plot_batches_and_conditions(adata_subsampled, plot_flag=True, modality=\"\"):\n    \"\"\"Plot batches and conditions analysis for protein data\"\"\"\n    if not plot_flag:\n        return",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_batches_and_conditions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_batches_and_conditions(adata_subsampled, plot_flag=True, modality=\"\"):\n    \"\"\"Plot batches and conditions analysis for protein data\"\"\"\n    if not plot_flag:\n        return\n    modality_prefix = f\"{modality} - \" if modality else \"\"\n    sc.pl.umap(\n        adata_subsampled,\n        color=\"cell_types\",\n        title=f\"{modality_prefix}Cell Types\",\n        save=\"cell_types_umap\",",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_heatmap_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_heatmap_analysis(adata_subsampled, modality, plot_flag=True):\n    \"\"\"Plot heatmap analysis for adata\"\"\"\n    if not plot_flag:\n        return\n    # Get the actual data dimensions\n    n_cells, n_features = adata_subsampled.X.shape\n    # Limit the heatmap to a reasonable size (max 1000x1000)\n    max_cells = min(1000, n_cells)\n    max_features = min(1000, n_features)\n    # Extract data for heatmap",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_umap_visualizations_original_data",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_umap_visualizations_original_data(adata_rna, adata_prot, subset_size=2000):\n    \"\"\"Generate UMAP visualizations for original RNA and protein data\"\"\"\n    adata_rna_subset = sc.pp.subsample(\n        adata_rna, n_obs=min(subset_size, adata_rna.n_obs), copy=True\n    ).copy()\n    adata_prot_subset = sc.pp.subsample(\n        adata_prot, n_obs=min(subset_size, adata_prot.n_obs), copy=True\n    ).copy()\n    if \"connectivities\" not in adata_rna_subset.obsm:\n        sc.pp.neighbors(adata_rna_subset)",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_rna_data_histogram",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_rna_data_histogram(adata_rna, plot_flag=True):\n    \"\"\"Plot histogram of RNA data values.\"\"\"\n    if not plot_flag:\n        return\n    from scipy.sparse import issparse\n    plt.figure()\n    hist_rna = (\n        adata_rna.X.data[:10000].flatten()\n        if issparse(adata_rna.X)\n        else adata_rna.X[:, :100].flatten()",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_protein_expression_sorted",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_protein_expression_sorted(adata_prot, n_cells=2000, n_features=50, plot_flag=True):\n    \"\"\"Plot sorted protein expression values.\"\"\"\n    if not plot_flag:\n        return\n    from scipy.sparse import issparse\n    X_prot = adata_prot.X.toarray() if issparse(adata_prot.X) else adata_prot.X\n    plt.figure(figsize=(10, 6))\n    plt.title(\"Protein expression (z-normalized from Step 0)\")\n    plt.plot(np.sort(X_prot[:n_cells, :n_features], axis=0))\n    plt.show()",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_spatial_only_umap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_spatial_only_umap(adata_spatial_only, color_key=\"CN\", plot_flag=True):\n    \"\"\"Plot UMAP of spatial-only data.\"\"\"\n    if not plot_flag:\n        return\n    sc.pp.pca(adata_spatial_only)\n    sc.pp.neighbors(adata_spatial_only)\n    sc.tl.umap(adata_spatial_only)\n    sc.pl.umap(adata_spatial_only, color=color_key)\ndef plot_b_cells_analysis(adata_rna, subset_size=5000):\n    \"\"\"Plot analysis for B cells\"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_b_cells_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_b_cells_analysis(adata_rna, subset_size=5000):\n    \"\"\"Plot analysis for B cells\"\"\"\n    adata_rna_subset = sc.pp.subsample(\n        adata_rna, n_obs=min(subset_size, adata_rna.n_obs), copy=True\n    )\n    adata_B_cells = adata_rna_subset[\n        adata_rna_subset.obs[\"major_cell_types\"] == adata_rna_subset.obs[\"major_cell_types\"][0]\n    ].copy()\n    # Ensure data is float for PCA\n    if not np.issubdtype(adata_B_cells.X.dtype, np.floating):",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_pca_and_umap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_pca_and_umap(adata_rna, adata_prot, subset_size=2000):\n    \"\"\"Plot PCA and UMAP visualizations\"\"\"\n    adata_rna_subset = sc.pp.subsample(\n        adata_rna, n_obs=min(subset_size, adata_rna.n_obs), copy=True\n    ).copy()\n    adata_prot_subset = sc.pp.subsample(\n        adata_prot, n_obs=min(subset_size, adata_prot.n_obs), copy=True\n    ).copy()\n    sc.pl.pca(\n        adata_rna_subset,",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_protein_umap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_protein_umap(adata_prot, subset_size=1000):\n    \"\"\"Plot protein UMAP visualizations\"\"\"\n    adata_prot_subset = sc.pp.subsample(\n        adata_prot, n_obs=min(subset_size, adata_prot.n_obs), copy=True\n    )\n    sc.pp.neighbors(adata_prot_subset, use_rep=\"X_pca\", key_added=\"X_neighborhood\")\n    sc.tl.umap(adata_prot_subset, neighbors_key=\"X_neighborhood\")\n    adata_prot_subset.obsm[\"X_original_umap\"] = adata_prot_subset.obsm[\"X_umap\"]\n    sc.pl.umap(\n        adata_prot_subset,",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_original_data_visualizations",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.preprocessing",
        "description": "ARCADIA.src.arcadia.plotting.preprocessing",
        "peekOfCode": "def plot_original_data_visualizations(adata_rna, adata_prot, subset_size=1000):\n    \"\"\"Plot original data visualizations\"\"\"\n    adata_rna_subset = sc.pp.subsample(\n        adata_rna, n_obs=min(subset_size, adata_rna.n_obs), copy=True\n    )\n    adata_prot_subset = sc.pp.subsample(\n        adata_prot, n_obs=min(subset_size, adata_prot.n_obs), copy=True\n    )\n    sc.pl.embedding(\n        adata_rna_subset,",
        "detail": "ARCADIA.src.arcadia.plotting.preprocessing",
        "documentation": {}
    },
    {
        "label": "plot_elbow_method",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_elbow_method(evs_protein, evs_rna, max_points=300, plot_flag=True):\n    \"\"\"Plot elbow method results.\"\"\"\n    if not plot_flag:\n        return\n    # Limit the number of points if too many\n    if len(evs_protein) > max_points or len(evs_rna) > max_points:\n        logger.info(f\"Limiting elbow plot to first {max_points} points\")\n        plot_protein = evs_protein[:max_points]\n        plot_rna = evs_rna[:max_points]\n    else:",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_spatial_data",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_spatial_data(adata_prot, max_cells=5000, plot_flag=True):\n    \"\"\"Plot spatial data for protein dataset\"\"\"\n    if not plot_flag:\n        return\n    logger.info(\"Plotting spatial data...\")\n    plt.figure(figsize=(10, 10))\n    # Subsample if needed\n    subsample_n_obs = min(max_cells, len(adata_prot))\n    adata_prot_sub = adata_prot[np.random.choice(len(adata_prot), subsample_n_obs, replace=False)]\n    # Get unique cell types and create a color map",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_spatial_data_comparison",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_spatial_data_comparison(adata_rna, adata_prot):\n    \"\"\"Plot spatial data comparison between RNA and protein datasets\"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(20, 8))\n    # RNA data\n    axes[0].scatter(\n        adata_rna.obsm[\"spatial\"][:, 0],\n        adata_rna.obsm[\"spatial\"][:, 1],\n        c=adata_rna.obs[\"CN\"],\n        cmap=\"tab10\",\n        alpha=0.6,",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_modality_embeddings",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_modality_embeddings(adata_1_rna, adata_2_prot, max_cells=2000, plot_flag=True):\n    \"\"\"Plot PCA and UMAP embeddings for both modalities.\"\"\"\n    if not plot_flag:\n        return\n    # Subsample data if needed\n    sc.pl.pca(\n        adata_1_rna,\n        color=[\"cell_types\", \"major_cell_types\"],\n        title=[\"RNA pca minor cell types\", \"RNA pca major cell types\"],\n    )",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_spatial_features",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_spatial_features(adata_prot, max_cells=2000):\n    \"\"\"Plot neighbor means and raw protein expression.\"\"\"\n    # Apply subsampling if too many cells\n    spatial_features = adata_prot[adata_prot.var[\"feature_type\"] != \"protein\"].X\n    protein_data = adata_prot[adata_prot.var[\"feature_type\"] == \"protein\"].X\n    if adata_prot.shape[0] > max_cells:\n        logger.info(f\"Subsampling to {max_cells} cells for neighbor means plot\")\n        idx = np.random.choice(adata_prot.shape[0], max_cells, replace=False)\n        spatial_features_plot = spatial_features[idx]\n        protein_data_plot = protein_data[idx]",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_spatial_clusters",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_spatial_clusters(adata_prot, max_cells=2000, plot_flag=True):\n    \"\"\"Plot spatial clusters and related visualizations.\"\"\"\n    if not plot_flag:\n        return\n    # if the color pallete does not match the number of categories, add more colors\n    if \"CN_colors\" in adata_prot.uns:\n        if len(adata_prot.uns[\"CN_colors\"]) < len(adata_prot.obs[\"CN\"].cat.categories):\n            new_palette = sns.color_palette(\"tab10\", len(adata_prot.obs[\"CN\"].cat.categories))\n            adata_prot.uns[\"CN_colors\"] = new_palette.as_hex()\n    # Apply subsampling for spatial plot if too many cells",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_protein_cn_subset_umaps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_protein_cn_subset_umaps(adata_prot, most_common_cell_type, plot_flag=True):\n    if not plot_flag:\n        return\n    import anndata as ad\n    protein_features = adata_prot.var_names[adata_prot.var[\"feature_type\"] == \"protein\"]\n    spatial_features = adata_prot.var_names[adata_prot.var[\"feature_type\"] != \"protein\"]\n    mask = adata_prot.obs[\"cell_types\"] == most_common_cell_type\n    prot_original = adata_prot[mask, protein_features].copy()\n    prot_cn = adata_prot[mask, spatial_features].copy()\n    combined = ad.concat([prot_original, prot_cn], axis=1)",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_protein_vs_cn_statistics",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_protein_vs_cn_statistics(protein_data, cn_data, plot_flag=True):\n    if not plot_flag:\n        return\n    fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n    protein_feature_means = np.mean(protein_data, axis=0)\n    cn_feature_means = np.mean(cn_data, axis=0)\n    max_num_feature_means = max(len(protein_feature_means), len(cn_feature_means))\n    protein_feature_means = protein_feature_means[:max_num_feature_means]\n    cn_feature_means = cn_feature_means[:max_num_feature_means]\n    axes[0].hist(protein_feature_means, alpha=0.5, bins=30, label=\"Protein Features\")",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_modality_embeddings",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_modality_embeddings(adata_1_rna, adata_2_prot, max_cells=2000, plot_flag=True):\n    \"\"\"Plot PCA and UMAP embeddings for both modalities.\"\"\"\n    if not plot_flag:\n        return\n    # Subsample data if needed\n    sc.pl.pca(\n        adata_1_rna,\n        color=[\"cell_types\", \"major_cell_types\"],\n        title=[\"RNA pca minor cell types\", \"RNA pca major cell types\"],\n    )",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_spatial_data_histograms",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_spatial_data_histograms(spatial_adata, n_cells=10, plot_flag=True):\n    \"\"\"Plot histograms of spatial data.\"\"\"\n    if not plot_flag:\n        return\n    # Plot histogram of flattened spatial data\n    plt.hist(spatial_adata.X.flatten()[:1000])\n    plt.show()\n    # Plot histograms of random cells\n    for i in range(n_cells):\n        plt.hist(spatial_adata.X[i, :], bins=30, alpha=0.5, label=f\"Cell {i}\")",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_feature_mean_distributions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_feature_mean_distributions(spatial_adata, plot_flag=True):\n    \"\"\"Plot distribution of mean feature values by feature type.\"\"\"\n    if not plot_flag:\n        return\n    feature_types = spatial_adata.var[\"feature_type\"]\n    mean_features = spatial_adata.X.mean(axis=0)\n    df = pd.DataFrame({\"mean_value\": mean_features, \"feature_type\": feature_types})\n    plt.figure(figsize=(10, 6))\n    for feature_type in df[\"feature_type\"].unique():\n        subset = df[df[\"feature_type\"] == feature_type]",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_feature_means_line",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_feature_means_line(adata, plot_flag=True):\n    \"\"\"Plot line plot of mean feature values.\"\"\"\n    if not plot_flag:\n        return\n    plt.figure(figsize=(10, 5))\n    plt.plot(adata.X.mean(axis=0))\n    plt.show()\ndef plot_feature_value_distributions(adata_prot, num_points=1000, plot_flag=True):\n    if not plot_flag:\n        return",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_feature_value_distributions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_feature_value_distributions(adata_prot, num_points=1000, plot_flag=True):\n    if not plot_flag:\n        return\n    protein_mask = adata_prot.var[\"feature_type\"] == \"protein\"\n    spatial_mask = adata_prot.var[\"feature_type\"] != \"protein\"\n    if issparse(adata_prot.X):\n        protein_features = adata_prot.X[:, protein_mask].toarray()\n        spatial_features = adata_prot.X[:, spatial_mask].toarray()\n    else:\n        protein_features = adata_prot.X[:, protein_mask]",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_modality_embeddings",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.spatial",
        "description": "ARCADIA.src.arcadia.plotting.spatial",
        "peekOfCode": "def plot_modality_embeddings(adata_1_rna, adata_2_prot, max_cells=2000, plot_flag=True):\n    \"\"\"Plot PCA and UMAP embeddings for both modalities.\"\"\"\n    if not plot_flag:\n        return\n    # Subsample data if needed\n    sc.pl.pca(\n        adata_1_rna,\n        color=[\"cell_types\", \"major_cell_types\"],\n        title=[\"RNA pca minor cell types\", \"RNA pca major cell types\"],\n    )",
        "detail": "ARCADIA.src.arcadia.plotting.spatial",
        "documentation": {}
    },
    {
        "label": "plot_all_fits_for_gene",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_all_fits_for_gene(gene_data, fit_results, gene_index, modality=\"\"):\n    \"\"\"\n    Visualizes the fits of all four candidate distributions for a single gene.\n    Creates a 2x2 grid showing the observed data histogram against each of the\n    four fitted probability distributions (Normal, Poisson, NB, ZINB).\n    Parameters:\n    - gene_data: 1D numpy array of the gene's expression data.\n    - fit_results: A dict containing the calculated AICs and fitted parameters.\n    - gene_index: The index of the gene in the original AnnData object.\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "pre_train_adata_histograms_heatmap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def pre_train_adata_histograms_heatmap(adata, plot_name, feature_type=\"protein\"):\n    n_cells = min(1000, adata.n_obs)\n    n_features = min(200, adata.n_vars)\n    random_cells = np.random.choice(adata.obs_names, n_cells, replace=False)\n    random_features = np.random.choice(adata.var_names, n_features, replace=False)\n    subset = adata[random_cells, random_features]\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 16))\n    # Convert to dense if sparse\n    X_dense = subset.X.toarray() if hasattr(subset.X, \"toarray\") else subset.X\n    sns.heatmap(X_dense, cmap=\"viridis\", cbar_kws={\"label\": \"Expression\"}, ax=ax1)",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_warmup_loss_distributions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_warmup_loss_distributions(\n    warmup_raw_losses: dict, precentile: tuple[float, float] = (5, 95)\n):\n    \"\"\"\n    Plots histograms of raw loss distributions from the warmup phase,\n    showing original.\n    Args:\n        warmup_raw_losses: A dictionary where keys are loss names and\n                           values are lists of raw loss values.\n        precentile: Tuple of percentiles (lower, upper) for clipping.",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_data_overview",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_data_overview(adata_1, adata_2, max_cells=5000, plot_flag=True):\n    \"\"\"Plot overview of RNA and protein data\"\"\"\n    if not plot_flag:\n        return\n    logger.info(\"Plotting data overview...\")\n    fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n    # Subsample if needed\n    subsample_n_obs_1 = min(max_cells, len(adata_1))\n    adata_1_sub = adata_1[np.random.choice(len(adata_1), subsample_n_obs_1, replace=False)]\n    subsample_n_obs_2 = min(max_cells, len(adata_2))",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_cell_type_distribution",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_cell_type_distribution(adata_1, adata_2, max_cells=5000, plot_flag=True):\n    \"\"\"Plot cell type distribution for both datasets\"\"\"\n    if not plot_flag:\n        return\n    logger.info(\"Plotting cell type distribution...\")\n    fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n    # RNA data\n    subsample_n_obs = min(max_cells, len(adata_1))\n    adata_1_sub = adata_1[np.random.choice(len(adata_1), subsample_n_obs, replace=False)]\n    sns.countplot(data=adata_1_sub.obs, x=\"cell_types\", ax=axes[0])",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_spatial_data",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_spatial_data(adata_prot, max_cells=5000, plot_flag=True):\n    \"\"\"Plot spatial data for protein dataset\"\"\"\n    if not plot_flag:\n        return\n    logger.info(\"Plotting spatial data...\")\n    plt.figure(figsize=(10, 10))\n    # Subsample if needed\n    subsample_n_obs = min(max_cells, len(adata_prot))\n    adata_prot_sub = adata_prot[np.random.choice(len(adata_prot), subsample_n_obs, replace=False)]\n    # Get unique cell types and create a color map",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_preprocessing_results",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_preprocessing_results(adata_1, adata_2, plot_flag=True):\n    \"\"\"Plot results after preprocessing\"\"\"\n    if not plot_flag:\n        return\n    logger.info(\"Plotting preprocessing results...\")\n    fig, axes = plt.subplots(2, 2, figsize=(15, 15))\n    # RNA data (log-transformed)\n    sc.pl.pca(adata_1, color=\"cell_types\", show=False, ax=axes[0, 0])\n    axes[0, 0].set_title(\"RNA PCA (Log-transformed)\")\n    sc.pl.umap(adata_1, color=\"cell_types\", show=False, ax=axes[0, 1])",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_spatial_data_comparison",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_spatial_data_comparison(adata_rna, adata_prot):\n    \"\"\"Plot spatial data comparison between RNA and protein datasets\"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(20, 8))\n    # RNA data\n    axes[0].scatter(\n        adata_rna.obsm[\"spatial\"][:, 0],\n        adata_rna.obsm[\"spatial\"][:, 1],\n        c=adata_rna.obs[\"CN\"],\n        cmap=\"tab10\",\n        alpha=0.6,",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_train_val_normalized_losses",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_train_val_normalized_losses(history_):\n    \"\"\"Plot training and validation losses normalized in the same figure.\n    Args:\n        history_: Dictionary containing training and validation loss histories\n    This function:\n    1. Uses epoch-wise means of the losses\n    2. Normalizes the losses for better visualization (0-1 range)\n    3. Plots training and validation losses in separate subplots for easier comparison\n    4. Uses consistent colors for the same loss type across both plots\n    5. Properly handles validation data collected at intervals (check_val_every_n_epoch)",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_latent_pca_both_modalities_cn",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_latent_pca_both_modalities_cn(\n    rna_mean,\n    protein_mean,\n    adata_rna_subset,\n    adata_prot_subset,\n    index_rna,\n    index_prot,\n    global_step=None,\n    use_subsample=True,\n):",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_counterfactual_comparison",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_counterfactual_comparison(\n    adata_rna,\n    adata_prot,\n    counterfactual_adata_rna,\n    counterfactual_protein_adata,\n    epoch=\"\",\n    use_subsample=True,\n    rna_similarity_score=None,\n    protein_similarity_score=None,\n    rna_ilisi_score=None,",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_latent_pca_both_modalities_by_celltype",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_latent_pca_both_modalities_by_celltype(\n    adata_rna_subset,\n    adata_prot_subset,\n    rna_latent,\n    prot_latent,\n    index_rna=None,\n    index_prot=None,\n    global_step=None,\n    use_subsample=True,\n):",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_latent_mean_std_legacy",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_latent_mean_std_legacy(\n    rna_inference_outputs,\n    protein_inference_outputs,\n    adata_rna,\n    adata_prot,\n    index_rna=None,\n    index_prot=None,\n    use_subsample=True,\n):\n    \"\"\"Plot latent space visualization combining heatmaps and PCA plots.",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_rna_protein_matching_means_and_scale",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_rna_protein_matching_means_and_scale(\n    rna_latent_mean,\n    protein_latent_mean,\n    rna_latent_std,\n    protein_latent_std,\n    archetype_dis_mat,\n    use_subsample=True,\n    global_step=None,\n):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_inference_outputs",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_inference_outputs(\n    rna_inference_outputs,\n    protein_inference_outputs,\n    latent_distances,\n    rna_distances,\n    prot_distances,\n):\n    \"\"\"Plot inference outputs\"\"\"\n    logger.info(\"Plotting inference outputs...\")\n    fig, axes = plt.subplots(2, 3)",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_similarity_loss_history",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_similarity_loss_history(\n    similarity_loss_all_history,\n    active_similarity_loss_active_history,\n    global_step,\n    similarity_weight=None,\n    similarity_dynamic=None,\n):\n    \"\"\"\n    Plot the similarity loss history_ and highlight active steps\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_losses",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_losses(keys, title, history_=None):\n    \"\"\"Plot normalized losses for given keys.\"\"\"\n    plt.figure(figsize=(10, 5))\n    normalized_losses = {}\n    labels = {}\n    for key in keys:\n        if history_ is None:\n            # Assume keys are already values\n            values = key if isinstance(key, (list, np.ndarray)) else [key]\n        else:",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_normalized_losses",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_normalized_losses(history_):\n    \"\"\"Plot normalized training and validation losses in separate figures.\"\"\"\n    # Get all loss keys from history_\n    loss_keys = [k for k in history_.keys() if \"loss\" in k.lower() and len(history_[k]) > 0]\n    # Split into train and validation losses\n    train_loss_keys = [k for k in loss_keys if k.startswith(\"train_\") and \"adv\" not in k.lower()]\n    val_loss_keys = [\n        k\n        for k in loss_keys\n        if (k.startswith(\"val_\") or k.startswith(\"validation_\")) and \"adv\" not in k.lower()",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_cell_type_prediction_confusion_matrix",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_cell_type_prediction_confusion_matrix(\n    true_cell_types=None, predicted_cell_types=None, global_step=None\n):\n    if true_cell_types is None or predicted_cell_types is None:  # show default confusion matrix\n        confusion_matrix_values = np.array(\n            [\n                [91, 4, 3, 0, 0, 0],\n                [22, 77, 0, 0, 0, 0],\n                [14, 1, 79, 4, 0, 0],\n                [13, 1, 3, 70, 0, 0],",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_cn_prediction_confusion_matrix",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_cn_prediction_confusion_matrix(\n    true_cn=None, predicted_cn=None, cell_types=None, global_step=None\n):\n    \"\"\"\n    Plot confusion matrix for CN (cell neighborhood) prediction accuracy.\n    Similar to plot_cell_type_prediction_confusion_matrix but for CN labels.\n    Args:\n        true_cn: True CN labels (pandas Series or array-like)\n        predicted_cn: Predicted CN labels (pandas Series or array-like)\n        cell_types: Cell type labels for per-cell-type analysis (optional)",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_cn_prediction_per_cell_type",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_cn_prediction_per_cell_type(true_cn, predicted_cn, cell_types, global_step=None):\n    \"\"\"\n    Plot CN prediction confusion matrices for each cell type in separate subplots.\n    Args:\n        true_cn: True CN labels (pandas Series or array-like)\n        predicted_cn: Predicted CN labels (pandas Series or array-like)\n        cell_types: Cell type labels (pandas Series or array-like)\n        global_step: Current global step for saving (optional)\n    \"\"\"\n    # Convert to pandas Series if needed",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_pca_umap_latent_space_during_train",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_pca_umap_latent_space_during_train(prefix, combined_latent, epoch, global_step=\"\"):\n    sc.pp.pca(combined_latent)\n    # Helper function to create scatter plot with different markers for extreme archetypes\n    def plot_with_extreme_markers(ax, combined_latent, color_col, title, basis=\"X_pca\"):\n        # Check if extreme archetype information exists\n        if \"is_extreme_archetype\" in combined_latent.obs.columns:\n            extreme_mask = combined_latent.obs[\"is_extreme_archetype\"].astype(bool)\n            non_extreme_mask = ~extreme_mask\n            # Get coordinates\n            coords = combined_latent.obsm[basis]",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "reconstruction_comparison_plot",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def reconstruction_comparison_plot(\n    rna_vae,\n    protein_vae,\n    rna_batch,\n    protein_batch,\n    rna_inference_outputs,\n    protein_inference_outputs,\n    global_step=None,\n):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_cosine_distance",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_cosine_distance(rna_batch, protein_batch):\n    umap_model = UMAP(n_components=2, random_state=42).fit(rna_batch[\"archetype_vec\"], min_dist=5)\n    # Transform both modalities using the same UMAP model\n    rna_archetype_2pc = umap_model.transform(rna_batch[\"archetype_vec\"])\n    prot_archetype_2pc = umap_model.transform(protein_batch[\"archetype_vec\"])\n    rna_norm = rna_archetype_2pc / np.linalg.norm(rna_archetype_2pc, axis=1)[:, None]\n    scale = 1.2\n    prot_norm = scale * prot_archetype_2pc / np.linalg.norm(prot_archetype_2pc, axis=1)[:, None]\n    plt.scatter(rna_norm[:, 0], rna_norm[:, 1], label=\"RNA\", alpha=0.7)\n    plt.scatter(prot_norm[:, 0], prot_norm[:, 1], label=\"Protein\", alpha=0.7)",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_pre_training_visualizations",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_pre_training_visualizations(adata_rna_subset, adata_prot_subset, plot_flag=True):\n    \"\"\"Plot PCA and UMAP visualizations before training.\"\"\"\n    if not plot_flag:\n        return\n    sc.pl.pca(adata_rna_subset, color=[\"CN\", \"cell_types\", \"batch\"])\n    sc.pl.pca(adata_prot_subset, color=[\"CN\", \"cell_types\", \"batch\"])\n    sc.pl.umap(adata_rna_subset, color=[\"CN\", \"cell_types\", \"batch\"])\n    sc.pl.umap(adata_prot_subset, color=[\"CN\", \"cell_types\", \"batch\"])\ndef plot_batch_specific_umaps(adata_rna_subset, plot_flag=True):\n    \"\"\"Plot batch-specific UMAP visualizations.\"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_batch_specific_umaps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_batch_specific_umaps(adata_rna_subset, plot_flag=True):\n    \"\"\"Plot batch-specific UMAP visualizations.\"\"\"\n    if not plot_flag:\n        return\n    from arcadia.data_utils import log1p_rna\n    for batch in adata_rna_subset.obs[\"batch\"].unique():\n        adata = adata_rna_subset[adata_rna_subset.obs[\"batch\"] == batch].copy()\n        adata_2 = adata_rna_subset[adata_rna_subset.obs[\"batch\"] == batch].copy()\n        if not adata.uns[\"pipeline_metadata\"].get(\"log1p\", False):\n            log1p_rna(adata)",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_archetype_vs_latent_distances",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_archetype_vs_latent_distances(archetype_dis_tensor, latent_distances, threshold):\n    \"\"\"Plot archetype vs latent distances\"\"\"\n    logger.info(\"Plotting archetype vs latent distances...\")\n    fig, axes = plt.subplots(1, 2, figsize=(10, 5))\n    # Plot archetype distances\n    axes[0].hist(archetype_dis_tensor.detach().cpu().numpy().flatten(), bins=50)\n    axes[0].axvline(x=threshold, color=\"r\", linestyle=\"--\", label=f\"Threshold: {threshold}\")\n    axes[0].set_title(\"Archetype Distances\")\n    axes[0].legend()\n    # Plot latent distances",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_latent_distances",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_latent_distances(latent_distances, threshold):\n    \"\"\"Plot latent distances and threshold\"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(10, 5))\n    # Plot latent distances heatmap\n    sns.heatmap(latent_distances.detach().cpu().numpy(), ax=axes[0])\n    axes[0].set_title(\"Latent Distances\")\n    axes[0].legend()\n    # Plot latent distances\n    axes[1].hist(latent_distances.detach().cpu().numpy().flatten(), bins=50)\n    axes[1].axvline(x=threshold, color=\"r\", linestyle=\"--\", label=f\"Threshold: {threshold}\")",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_combined_latent_space",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_combined_latent_space(combined_latent, use_subsample=True):\n    \"\"\"Plot combined latent space visualizations\"\"\"\n    # Subsample if requested\n    if use_subsample:\n        subsample_n_obs = min(1000, combined_latent.shape[0])\n        subsample_idx = np.random.choice(combined_latent.shape[0], subsample_n_obs, replace=False)\n        combined_latent_plot = combined_latent[subsample_idx].copy()\n    else:\n        combined_latent_plot = combined_latent.copy()\n    # Plot UMAP",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_cell_type_distributions",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_cell_type_distributions(combined_latent, top_n=3, use_subsample=True):\n    \"\"\"Plot UMAP for top N most common cell types\"\"\"\n    top_cell_types = combined_latent.obs[\"cell_types\"].value_counts().index[:top_n]\n    for cell_type in top_cell_types:\n        cell_type_data = combined_latent[combined_latent.obs[\"cell_types\"] == cell_type]\n        # Subsample if requested\n        if use_subsample and cell_type_data.shape[0] > 700:\n            n_subsample = min(700, cell_type_data.shape[0])\n            subsample_idx = np.random.choice(cell_type_data.shape[0], n_subsample, replace=False)\n            cell_type_data_plot = cell_type_data[subsample_idx].copy()",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_rna_protein_latent_cn_cell_type_umap",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_rna_protein_latent_cn_cell_type_umap(adata_rna, adata_prot, use_subsample=True):\n    \"\"\"Plot RNA and protein embeddings\"\"\"\n    # Create copies to avoid modifying the original data\n    if use_subsample:\n        # Subsample RNA data\n        n_subsample_rna = min(700, adata_rna.shape[0])\n        subsample_idx_rna = np.random.choice(adata_rna.shape[0], n_subsample_rna, replace=False)\n        adata_rna_plot = adata_rna[subsample_idx_rna].copy()\n        # Subsample protein data\n        n_subsample_prot = min(700, adata_prot.shape[0])",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_latent_single",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_latent_single(means, adata, index, color_label=\"CN\", title=\"\", subset_size=1000):\n    adata_subset = sc.pp.subsample(adata, n_obs=min(subset_size, adata.n_obs), copy=True)\n    plt.figure()\n    pca = PCA(n_components=3)\n    means_cpu = means.detach().cpu().numpy()\n    index_cpu = index.detach().cpu().numpy().flatten()\n    pca.fit(means_cpu)\n    rna_pca = pca.transform(means_cpu)\n    plt.subplot(1, 1, 1)\n    plt.scatter(",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_umap_with_extremes",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_umap_with_extremes(\n    adata,\n    color_key=None,\n    extreme_key=\"is_extreme_archetype\",\n    basis=\"umap\",\n    base_size=20,\n    extreme_size=40,\n    extreme_color=None,\n    alpha=0.8,\n    title=None,",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_encoded_latent_space_comparison",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_encoded_latent_space_comparison(\n    adata_rna_subset,\n    adata_prot_subset,\n    rna_latent,\n    prot_latent,\n    index_rna=None,\n    index_prot=None,\n    global_step=None,\n    use_subsample=True,\n    n_subsample=2000,",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "test_plot_latent_pca_both_modalities_by_celltype",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def test_plot_latent_pca_both_modalities_by_celltype():\n    \"\"\"Test function for plot_latent_pca_both_modalities_by_celltype with synthetic data.\"\"\"\n    import numpy as np\n    from anndata import AnnData\n    # Set random seed for reproducibility\n    np.random.seed(42)\n    # Generate synthetic data\n    n_cells = 2000\n    n_cell_types = 5\n    latent_dim = 20",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_training_metrics_history",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_training_metrics_history(metrics_history):\n    \"\"\"Plot training metrics history_ over epochs.\n    Args:\n        metrics_history (list): List of dictionaries containing metrics for each epoch\n        save_path (str): Path to save the plot\n    Returns:\n        matplotlib.figure.Figure: The generated figure\n    \"\"\"\n    try:\n        # Convert metrics history_ to DataFrame",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "visualize_gmm_threshold",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def visualize_gmm_threshold(X, dynamic_threshold, gmm, noise_idx):\n    nonzero_vals = X[X > 0].reshape(-1, 1)\n    x = np.linspace(nonzero_vals.min(), nonzero_vals.max(), 1000).reshape(-1, 1)\n    logprob = gmm.score_samples(x)\n    pdf = np.exp(logprob)\n    responsibilities = gmm.predict_proba(x)\n    pdf_individual = responsibilities * pdf[:, np.newaxis]\n    plt.figure(figsize=(10, 6))\n    plt.hist(\n        nonzero_vals,",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "visualize_integer_conversion",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def visualize_integer_conversion(X, X_int):\n    plt.figure(figsize=(10, 6))\n    plt.hist(X.flatten(), bins=50, alpha=0.5, label=\"Original values\")\n    plt.hist(X_int.flatten(), bins=50, alpha=0.5, label=\"Integer-converted\")\n    plt.xlabel(\"Value\")\n    plt.ylabel(\"Frequency\")\n    plt.title(\"Original vs. Integer-Converted Data\")\n    plt.legend()\n    plt.show()\n    safe_mlflow_log_figure(plt.gcf(), \"integer_conversion.pdf\")",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "visualize_integer_conversion_subplots",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def visualize_integer_conversion_subplots(X, X_int, bins=50):\n    fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n    # Handle sparse matrices - convert to dense for plotting\n    X_flat = X.toarray().flatten() if hasattr(X, \"toarray\") else X.flatten()\n    X_int_flat = X_int.toarray().flatten() if hasattr(X_int, \"toarray\") else X_int.flatten()\n    # Original values\n    axes[0].hist(X_flat, bins=bins, color=\"skyblue\", alpha=0.7)\n    axes[0].set_title(\"Original Values\")\n    axes[0].set_xlabel(\"Value\")\n    axes[0].set_ylabel(\"Frequency\")",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_rna_protein_matching_means_and_scale",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_rna_protein_matching_means_and_scale(\n    rna_latent_mean,\n    protein_latent_mean,\n    rna_latent_std,\n    protein_latent_std,\n    archetype_dis_mat,\n    use_subsample=True,\n    global_step=None,\n):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_counterfactual_comparison_with_suffix",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_counterfactual_comparison_with_suffix(\n    adata_rna,\n    adata_prot,\n    counterfactual_adata_rna,\n    counterfactual_protein_adata,\n    epoch=\"\",\n    suffix=\"\",\n    use_subsample=True,\n    rna_similarity_score=None,\n    protein_similarity_score=None,",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "set_consistent_cell_type_colors",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def set_consistent_cell_type_colors(adata_rna, adata_prot):\n    \"\"\"\n    Set consistent cell type colors across both RNA and protein modalities.\n    Uses custom palettes from color_palletes.py if dataset_name matches, otherwise falls back to matplotlib colormaps.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n    Returns:\n        dict: Dictionary mapping cell types to hex colors\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "plot_first_batch_umaps",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.plotting.training",
        "description": "ARCADIA.src.arcadia.plotting.training",
        "peekOfCode": "def plot_first_batch_umaps(\n    rna_batch,\n    protein_batch,\n    rna_vae,\n    protein_vae,\n    adata_rna,\n    adata_prot,\n    colors=None,\n    title=None,\n    use_subsample=True,",
        "detail": "ARCADIA.src.arcadia.plotting.training",
        "documentation": {}
    },
    {
        "label": "spatial_analysis",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.spatial.analysis",
        "description": "ARCADIA.src.arcadia.spatial.analysis",
        "peekOfCode": "def spatial_analysis(adata: sc.AnnData) -> None:\n    \"\"\"Optional spatial analysis\"\"\"\n    try:\n        import squidpy as sq\n        print(\"\\nPerforming spatial analysis...\")\n        # subsample the adata to 3000 cells\n        adata_subsampled = sc.pp.subsample(adata, n_obs=3000, copy=True)\n        sq.gr.spatial_neighbors(adata_subsampled, coord_type=\"generic\")\n        sq.pl.spatial_scatter(adata_subsampled, color=\"cell_types\", shape=None)\n    except ImportError:",
        "detail": "ARCADIA.src.arcadia.spatial.analysis",
        "documentation": {}
    },
    {
        "label": "create_smart_neighbors",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.spatial.neighbors",
        "description": "ARCADIA.src.arcadia.spatial.neighbors",
        "peekOfCode": "def create_smart_neighbors(adata_prot: sc.AnnData, percentile_threshold: int = 95) -> sc.AnnData:\n    \"\"\"\n    Creates smart neighbors for the protein data by protecting the 5 closest neighbors for each cell\n    and then filtering the neighbors based on the distance threshold\n    \"\"\"\n    spatial_distances = adata_prot.obsp[\"spatial_neighbors_distances\"]\n    connectivities = adata_prot.obsp[\"spatial_neighbors_connectivities\"]\n    percentile_threshold = 95\n    percentile_value = np.percentile(spatial_distances.data, percentile_threshold)\n    # here we want to protect the 5 closest neighbors for each cell, since we can't have cells without neighbors",
        "detail": "ARCADIA.src.arcadia.spatial.neighbors",
        "documentation": {}
    },
    {
        "label": "DualVAETrainingPlan",
        "kind": 6,
        "importPath": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "description": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "peekOfCode": "class DualVAETrainingPlan(TrainingPlan):\n    @staticmethod\n    def normalise_weights(weight_dict: dict[str, float]):\n        \"\"\"\n        Input dict with keys as weight label strings and values as weight value floats.\n        Scale all positive weights so their sum is 1.0.\n        Raises error if no nonezero weights.\n        \"\"\"\n        total = sum(v for v in weight_dict.values() if v > 0)\n        if total == 0:",
        "detail": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "documentation": {}
    },
    {
        "label": "training_plan",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "description": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "peekOfCode": "training_plan = self._training_plan_cls(self.module, **plan_kwargs) # existing line\nself._training_plan = training_plan # add this line\n\"\"\"\nimport json\nimport os\nimport warnings\nfrom datetime import datetime\nfrom pathlib import Path\nimport anndata\nimport mlflow",
        "detail": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "documentation": {}
    },
    {
        "label": "self._training_plan",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "description": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "peekOfCode": "self._training_plan = training_plan # add this line\n\"\"\"\nimport json\nimport os\nimport warnings\nfrom datetime import datetime\nfrom pathlib import Path\nimport anndata\nimport mlflow\nimport numpy as np",
        "detail": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "documentation": {}
    },
    {
        "label": "pd.options.display.max_rows",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "description": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "peekOfCode": "pd.options.display.max_rows = 10\npd.options.display.max_columns = 10\nnp.set_printoptions(threshold=100)\nconfig_path = Path(__file__).parent.parent.parent.parent / \"configs\" / \"config.json\"\nif os.path.exists(config_path):\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]",
        "detail": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "documentation": {}
    },
    {
        "label": "pd.options.display.max_columns",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "description": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "peekOfCode": "pd.options.display.max_columns = 10\nnp.set_printoptions(threshold=100)\nconfig_path = Path(__file__).parent.parent.parent.parent / \"configs\" / \"config.json\"\nif os.path.exists(config_path):\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:",
        "detail": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "description": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "peekOfCode": "config_path = Path(__file__).parent.parent.parent.parent / \"configs\" / \"config.json\"\nif os.path.exists(config_path):\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "ARCADIA.src.arcadia.training.dual_vae_training_plan",
        "documentation": {}
    },
    {
        "label": "GradNorm",
        "kind": 6,
        "importPath": "ARCADIA.src.arcadia.training.gradnorm",
        "description": "ARCADIA.src.arcadia.training.gradnorm",
        "peekOfCode": "class GradNorm(nn.Module):\n    \"\"\"\n    GradNorm: Gradient Normalization for Adaptive Loss Balancing in Deep Multitask Networks\n    https://arxiv.org/abs/1711.02257\n    This implementation balances multiple loss functions by dynamically adjusting their weights\n    based on gradient magnitudes and relative training rates.\n    \"\"\"\n    def __init__(self, n_tasks, alpha=1.5, device=\"cpu\", logger=None):\n        super(GradNorm, self).__init__()\n        self.n_tasks = n_tasks",
        "detail": "ARCADIA.src.arcadia.training.gradnorm",
        "documentation": {}
    },
    {
        "label": "get_training_params_hash",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.loss_scaling",
        "description": "ARCADIA.src.arcadia.training.loss_scaling",
        "peekOfCode": "def get_training_params_hash(params: dict) -> str:\n    \"\"\"Computes a SHA256 hash for a dictionary of training parameters.\"\"\"\n    params_string = json.dumps(params, sort_keys=True, indent=None)\n    return hashlib.sha256(params_string.encode(\"utf-8\")).hexdigest()\ndef load_loss_scales_from_cache(training_params_for_hash: dict, cache_path: Path):\n    \"\"\"Load loss scales from cache if they exist for the given parameters.\"\"\"\n    if not cache_path.exists():\n        return None\n    params_hash = get_training_params_hash(training_params_for_hash)\n    try:",
        "detail": "ARCADIA.src.arcadia.training.loss_scaling",
        "documentation": {}
    },
    {
        "label": "load_loss_scales_from_cache",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.loss_scaling",
        "description": "ARCADIA.src.arcadia.training.loss_scaling",
        "peekOfCode": "def load_loss_scales_from_cache(training_params_for_hash: dict, cache_path: Path):\n    \"\"\"Load loss scales from cache if they exist for the given parameters.\"\"\"\n    if not cache_path.exists():\n        return None\n    params_hash = get_training_params_hash(training_params_for_hash)\n    try:\n        with open(cache_path, \"r\") as f:\n            scales_cache = json.load(f)\n        if params_hash in scales_cache:\n            logger.info(f\"Loaded loss scales from cache using hash {params_hash[:7]}...\")",
        "detail": "ARCADIA.src.arcadia.training.loss_scaling",
        "documentation": {}
    },
    {
        "label": "save_loss_scales_to_cache",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.loss_scaling",
        "description": "ARCADIA.src.arcadia.training.loss_scaling",
        "peekOfCode": "def save_loss_scales_to_cache(training_params_for_hash: dict, loss_scales: dict, cache_path: Path):\n    \"\"\"Save calculated loss scales to the cache.\"\"\"\n    params_hash = get_training_params_hash(training_params_for_hash)\n    scales_cache = {}\n    if cache_path.exists():\n        try:\n            with open(cache_path, \"r\") as f:\n                scales_cache = json.load(f)\n        except (json.JSONDecodeError, IOError):\n            logger.warning(",
        "detail": "ARCADIA.src.arcadia.training.loss_scaling",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.training.loss_scaling",
        "description": "ARCADIA.src.arcadia.training.loss_scaling",
        "peekOfCode": "logger = setup_logger(level=\"INFO\")\ndef get_training_params_hash(params: dict) -> str:\n    \"\"\"Computes a SHA256 hash for a dictionary of training parameters.\"\"\"\n    params_string = json.dumps(params, sort_keys=True, indent=None)\n    return hashlib.sha256(params_string.encode(\"utf-8\")).hexdigest()\ndef load_loss_scales_from_cache(training_params_for_hash: dict, cache_path: Path):\n    \"\"\"Load loss scales from cache if they exist for the given parameters.\"\"\"\n    if not cache_path.exists():\n        return None\n    params_hash = get_training_params_hash(training_params_for_hash)",
        "detail": "ARCADIA.src.arcadia.training.loss_scaling",
        "documentation": {}
    },
    {
        "label": "compute_pairwise_distances",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.losses",
        "description": "ARCADIA.src.arcadia.training.losses",
        "peekOfCode": "def compute_pairwise_distances(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:\n    \"\"\"Compute pairwise distances between two sets of points.\n    Args:\n        x: Tensor [N, D]\n        y: Tensor [M, D]\n    Returns:\n        Distance matrix [N, M]\n    \"\"\"\n    x_norm = (x**2).sum(dim=1, keepdim=True)  # [N, 1]\n    y_norm = (y**2).sum(dim=1, keepdim=True)  # [M, 1]",
        "detail": "ARCADIA.src.arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "mmd_loss",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.losses",
        "description": "ARCADIA.src.arcadia.training.losses",
        "peekOfCode": "def mmd_loss(x, y, sigma=1.0):\n    \"\"\"Compute (unbiased) MMD between two sets of samples x and y.\n    Args:\n        x, y: Tensor samples [N, D] and [M, D]\n        sigma: RBF bandwidth. If None or <=0, use median heuristic with multi-kernel\n    Returns:\n        MMD loss (scalar tensor)\n    \"\"\"\n    def rbf_kernel(a, b, sigma_val):\n        dist = compute_pairwise_distances(a, b) ** 2",
        "detail": "ARCADIA.src.arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "run_cell_type_clustering_loss",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.losses",
        "description": "ARCADIA.src.arcadia.training.losses",
        "peekOfCode": "def run_cell_type_clustering_loss(\n    adata,\n    latent_mean,\n    indices,\n    device=\"cuda:0\" if torch.cuda.is_available() else \"cpu\",\n    plot_flag=False,\n    modality_type=None,\n    return_components=False,\n):\n    \"\"\"Calculate cell type clustering loss to preserve cell type relationships.",
        "detail": "ARCADIA.src.arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "calculate_modality_balance_loss",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.losses",
        "description": "ARCADIA.src.arcadia.training.losses",
        "peekOfCode": "def calculate_modality_balance_loss(rna_components, protein_components):\n    \"\"\"\n    Calculate loss that punishes differences between modality-specific loss components.\n    Args:\n        rna_components: Dictionary with RNA loss components\n        protein_components: Dictionary with protein loss components\n    Returns:\n        modality_balance_loss: Tensor representing the balance loss\n    \"\"\"\n    # Calculate differences between corresponding components",
        "detail": "ARCADIA.src.arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "cn_distribution_separation_loss",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.losses",
        "description": "ARCADIA.src.arcadia.training.losses",
        "peekOfCode": "def cn_distribution_separation_loss(\n    adata,\n    latent,\n    cell_type_key=\"cell_types\",\n    cn_key=\"CN\",\n    device=\"cuda:0\" if torch.cuda.is_available() else \"cpu\",\n    sigma=None,\n    global_step=None,\n):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "calculate_cross_modal_cell_type_loss",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.losses",
        "description": "ARCADIA.src.arcadia.training.losses",
        "peekOfCode": "def calculate_cross_modal_cell_type_loss(\n    adata_rna,\n    adata_prot,\n    rna_latent_mean,\n    protein_latent_mean,\n    rna_indices,\n    prot_indices,\n    device=\"cuda:0\" if torch.cuda.is_available() else \"cpu\",\n    sigma=1.0,\n):",
        "detail": "ARCADIA.src.arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "extreme_archetypes_loss",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.losses",
        "description": "ARCADIA.src.arcadia.training.losses",
        "peekOfCode": "def extreme_archetypes_loss(\n    rna_batch, prot_batch, latent_distances, logger_, to_print=False, rna_vae=None, protein_vae=None\n):\n    rna_extreme_mask, _, _ = identify_extreme_archetypes_balanced(\n        rna_batch[\"archetype_vec\"],\n        rna_vae.adata[rna_batch[\"labels\"]],\n        logger_=logger_,\n        percentile=90,\n        to_print=to_print,\n    )",
        "detail": "ARCADIA.src.arcadia.training.losses",
        "documentation": {}
    },
    {
        "label": "fosknn",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def fosknn(\n    adata,\n    modality_key=\"modality\",\n    pair_key=\"pair_id\",\n    rep_key=\"X\",\n    pairwise_distances=None,\n    k=30,\n    prefix=\"\",\n    print_flag=False,\n):",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "foscttm",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def foscttm(\n    adata,\n    modality_key=\"modality\",\n    pair_key=\"pair_id\",\n    rep_key=\"X\",\n    pairwise_distances=None,\n    prefix=\"\",\n    print_flag=False,\n):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "pair_distance",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def pair_distance(\n    adata,\n    modality_key=\"modality\",\n    pair_key=\"pair_id\",\n    rep_key=\"X\",\n    pairwise_distances=None,\n    prefix=\"\",\n    print_flag=False,\n):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "mixing_metric",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def mixing_metric(\n    adata,\n    modality_key=\"modality\",\n    rep_key=\"X\",\n    k_neighborhood=300,\n    neighbor_ref=5,\n    prefix=\"\",\n    print_flag=False,\n):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "modality_kbet_mixing_score",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def modality_kbet_mixing_score(\n    adata: AnnData,\n    label_key=\"modality\",\n    group_key=None,\n    rep_key=\"X\",\n    k=30,\n    alpha=0.05,\n    min_cells=10,\n    min_freq=0.05,\n    prefix=\"\",",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "kbet_within_cell_types",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def kbet_within_cell_types(\n    adata: AnnData,\n    label_key=\"CN\",\n    group_key=\"cell_types\",\n    rep_key=\"X\",\n    k=30,\n    alpha=0.05,\n    min_cells=10,\n    min_freq=0.05,  # Minimum frequency for CN categories to be included\n    prefix=\"\",",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "cms_within_cell_types",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def cms_within_cell_types(\n    adata,\n    label_key=\"CN\",\n    group_key=\"cell_types\",\n    rep_key=\"X\",\n    k=30,\n    alpha=0.05,\n    min_cells=10,\n    min_per_label=5,\n    prefix=\"\",",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "silhouette_by_label_within_cell_types",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def silhouette_by_label_within_cell_types(\n    adata,\n    label_key=\"CN\",\n    group_key=\"cell_types\",\n    rep_key=\"X\",\n    metric=\"euclidean\",\n    min_cells=10,\n    prefix=\"\",\n    print_flag=False,\n):",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "silhouette_score_calc",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def silhouette_score_calc(combined_latent, print_flag=False):\n    \"\"\"Calculate silhouette score with proper NaN handling.\n    Args:\n        combined_latent: AnnData object with latent embedding in .X\n    Returns:\n        float: Silhouette score or NaN if calculation fails\n    \"\"\"\n    try:\n        # Check for NaN values in the data\n        if hasattr(combined_latent.X, \"toarray\"):",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calc_dist",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calc_dist(rna_latent, prot_latent, label_key=\"cell_types\"):\n    \"\"\"Calculate nearest protein cell types for each RNA cell.\n    Args:\n        rna_latent: AnnData object with RNA latent embedding\n        prot_latent: AnnData object with protein latent embedding\n    Returns:\n        pandas.Series: Nearest protein cell types for each RNA cell\n    \"\"\"\n    # Handle sparse matrices\n    if hasattr(rna_latent.X, \"toarray\"):",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "f1_score_calc",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def f1_score_calc(adata_rna, adata_prot, label_key=\"cell_types\"):\n    \"\"\"Calculate F1 score.\n    Args:\n        adata_rna: AnnData object with RNA data\n        adata_prot: AnnData object with protein data\n    Returns:\n        float: F1 score\n    \"\"\"\n    return f1_score(\n        adata_rna.obs[label_key],",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "ari_score_calc",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def ari_score_calc(adata_rna, adata_prot):\n    \"\"\"Calculate ARI score with error handling.\n    Args:\n        adata_rna: AnnData object with RNA data\n        adata_prot: AnnData object with protein data\n    Returns:\n        float: ARI score or NaN if calculation fails\n    \"\"\"\n    try:\n        return adjusted_rand_score(adata_rna.obs[\"cell_types\"], calc_dist(adata_rna, adata_prot))",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "matching_accuracy",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def matching_accuracy(rna_latent, prot_latent, global_step=None, plot_flag=False):\n    \"\"\"\n    Calculate matching accuracy between RNA and protein cells.\n    Used in MaxFuse paper.\n    Args:\n        rna_latent: AnnData object with RNA latent embedding\n        prot_latent: AnnData object with protein latent embedding\n        global_step: Current global step for plotting (optional)\n        plot_flag: Whether to plot the confusion matrix\n    Returns:",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calc_dist_cn",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calc_dist_cn(rna_latent, prot_latent, k=3, pairwise_distances=None):\n    \"\"\"Calculate nearest protein CN for each RNA cell using k-nearest neighbors.\n    Args:\n        rna_latent: AnnData object with RNA latent embedding\n        prot_latent: AnnData object with protein latent embedding\n        pairwise_distances: Precomputed distance matrix (n_rna x n_prot).\n                            If None, computed from adata.X. Shape: (n_rna, n_prot)\n        k: Number of nearest neighbors to consider\n    Returns:\n        pandas.Series: Predicted CN values for each RNA cell",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "cross_modality_cn_accuracy",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def cross_modality_cn_accuracy(\n    rna_latent, prot_latent, k=3, global_step=None, distance_matrix=None\n):\n    \"\"\"\n    Calculate CN (cell neighborhood) matching accuracy between RNA and protein cells.\n    Similar to cross_modality_cell_type_accuracy but for CN labels.\n    Args:\n        rna_latent: AnnData object with RNA latent embedding\n        prot_latent: AnnData object with protein latent embedding\n        k: Number of nearest neighbors to consider for CN prediction",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calc_dist_cn_from_matrix",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calc_dist_cn_from_matrix(rna_latent, prot_latent, distance_matrix):\n    \"\"\"\n    Get nearest CN labels from precomputed distance matrix.\n    Args:\n        rna_latent: AnnData object with RNA cell data\n        prot_latent: AnnData object with protein cell data\n        distance_matrix: Precomputed distance matrix (shape: n_rna x n_prot)\n    Returns:\n        pd.Series: Nearest protein CN labels for each RNA cell\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "normalize_silhouette",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def normalize_silhouette(silhouette_vals):\n    \"\"\"Normalize silhouette scores from [-1, 1] to [0, 1].\"\"\"\n    return (np.mean(silhouette_vals) + 1) / 2\ndef compute_silhouette_f1(rna_latent, prot_latent):\n    \"\"\"\n    Compute the Silhouette F1 score from the MaxFuse paper.\n    embeddings: np.ndarray, shape (n_samples, n_features)\n    celltype_labels: list or array of ground-truth biological labels\n    modality_labels: list or array of modality labels (e.g., RNA, ATAC)\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "compute_silhouette_f1",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def compute_silhouette_f1(rna_latent, prot_latent):\n    \"\"\"\n    Compute the Silhouette F1 score from the MaxFuse paper.\n    embeddings: np.ndarray, shape (n_samples, n_features)\n    celltype_labels: list or array of ground-truth biological labels\n    modality_labels: list or array of modality labels (e.g., RNA, ATAC)\n    \"\"\"\n    # protein embeddings\n    prot_embeddings = prot_latent.X\n    # rna embeddings",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "morans_i",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def morans_i(\n    adata,\n    score_key=\"matched_archetype_weight\",\n    use_rep=\"X\",\n    n_neighbors=15,\n    neighbors_key=None,\n):\n    \"\"\"\n    Compute Moran's I spatial autocorrelation statistic for score organization in an embedding.\n    Moran's I measures whether similar score values cluster together spatially in the",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "compute_ari_f1",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def compute_ari_f1(\n    adata,\n    celltype_key=\"cell_types\",\n    modality_key=\"modality\",\n    n_clusters=None,\n    n_runs=10,\n    random_state=42,\n):\n    \"\"\"\n    https://github.com/shuxiaoc/maxfuse/blob/7ccf6b4a32e01d013265b9c72ade8878d3172aa4/Archive/tonsil/code/benchmark/metrics.R#L176",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_color_entropy_within_cell_types",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calculate_color_entropy_within_cell_types(\n    combined_latent,\n    color_key: str = \"CN\",\n    rep_key: str = \"X\",  # use_rep argument for sc.pp.neighbors\n    k: int = 15,\n    prefix: str = \"\",\n    plot_flag: bool = False,\n    min_cells: int = 10,\n):\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_cn_ilisi_within_cell_types",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calculate_cn_ilisi_within_cell_types(\n    combined_latent: AnnData, prefix: str = \"\", plot_flag: bool = False\n):\n    \"\"\"\n    Calculate CN iLISI score within each cell type cluster.\n    Args:\n        combined_latent: AnnData object with combined RNA and protein data latent embeddings\n        prefix: Prefix for metric names (e.g., \"val_\", \"train_\")\n    Returns:\n        dict: Dictionary containing CN iLISI metrics",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_iLISI",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calculate_iLISI(\n    adata,\n    batch_key=\"batch\",\n    neighbors_key=\"neighbors\",\n    plot_flag=False,\n    use_subsample=True,\n    global_step=None,\n):\n    \"\"\"\n    Calculate integration Local Inverse Simpson's Index (LISI) using precomputed neighbors.",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_batch_ilisi_score",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calculate_batch_ilisi_score(adata, batch_key, n_neighbors=15):\n    \"\"\"Calculate how well batches are mixed using iLISI (integration Local Inverse Simpson's Index)\"\"\"\n    import scanpy as sc\n    # Ensure neighbors are computed\n    # Adjust n_neighbors for small datasets\n    max_neighbors = min(n_neighbors, adata.n_obs - 1)\n    if max_neighbors < 5:\n        max_neighbors = min(5, adata.n_obs - 1)\n    sc.pp.neighbors(adata, n_neighbors=max_neighbors)\n    # Use the existing calculate_iLISI function",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_cell_type_silhouette",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calculate_cell_type_silhouette(adata, celltype_key, use_rep=\"X_pca\"):\n    \"\"\"Calculate how well cell types cluster together\"\"\"\n    if celltype_key not in adata.obs.columns:\n        return None\n    if use_rep in adata.obsm:\n        X = adata.obsm[use_rep]\n    else:\n        X = adata.X\n    labels = adata.obs[celltype_key].values\n    # Only calculate if we have multiple cell types",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_cLISI",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calculate_cLISI(adata, label_key=\"cell_type\", neighbors_key=\"neighbors\", plot_flag=False):\n    \"\"\"\n    Calculate cell-type Local Inverse Simpson's Index (LISI) using precomputed neighbors.\n    The cLISI score measures how well cell types are separated in the embedding space.\n    Higher scores indicate better cell type separation, with a minimum value of 1\n    (all neighbors same cell type) and maximum of k+1 (all neighbors different cell types),\n    where k is the number of neighbors used.\n    Parameters\n    ----------\n    adata : AnnData",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "mixing_score",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def mixing_score(\n    rna_inference_outputs_mean,\n    protein_inference_outputs_mean,\n    adata_rna_subset,\n    adata_prot_subset,\n    index_rna=None,\n    index_prot=None,\n    plot_flag=False,\n):\n    if index_rna is None:",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "calculate_post_training_metrics",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.metrics",
        "description": "ARCADIA.src.arcadia.training.metrics",
        "peekOfCode": "def calculate_post_training_metrics(adata_rna, adata_prot, prot_matches_in_rna):\n    \"\"\"Calculate various metrics for model evaluation.\"\"\"\n    from sklearn.metrics import adjusted_mutual_info_score\n    # Ensure arrays have consistent lengths\n    rna_cell_types = adata_rna.obs[\"cell_types\"].values[prot_matches_in_rna]\n    prot_cell_types = adata_prot.obs[\"cell_types\"].values\n    if len(rna_cell_types) != len(prot_cell_types):\n        import warnings\n        warnings.warn(\n            f\"Mismatched array lengths: RNA {len(rna_cell_types)} vs Protein {len(prot_cell_types)}\"",
        "detail": "ARCADIA.src.arcadia.training.metrics",
        "documentation": {}
    },
    {
        "label": "select_gene_likelihood",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def select_gene_likelihood(\n    adata: AnnData,\n    n_sample_genes: int = 1000,\n    visualize: bool = True,\n    modality=None,\n    logger_=None,\n    use_autozi=False,\n    layer: str = None,\n) -> str:\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "process_latent_spaces",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def process_latent_spaces(adata_rna, adata_prot):\n    \"\"\"Process and combine latent spaces from both modalities.\n    This function assumes that the latent representations have been computed\n    using vae.module() and stored in the \"X_scVI\" field of the AnnData objects.\n    Args:\n        adata_rna: RNA AnnData object with latent representation in obsm[\"X_scVI\"]\n        adata_prot: Protein AnnData object with latent representation in obsm[\"X_scVI\"]\n    Returns:\n        rna_latent: RNA latent AnnData\n        prot_latent: Protein latent AnnData",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "match_cells_and_calculate_distances",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def match_cells_and_calculate_distances(rna_latent, prot_latent):\n    \"\"\"Match cells between modalities and calculate distances.\"\"\"\n    # Calculate pairwise distances\n    latent_distances = batched_cdist(rna_latent.X, prot_latent.X)\n    # Find matches\n    prot_matches_in_rna = np.argmin(latent_distances, axis=0)\n    matching_distances = np.min(latent_distances, axis=0)\n    # Generate random matches for comparison\n    rand_indices = np.random.permutation(len(rna_latent))\n    rand_latent_distances = latent_distances[rand_indices, :]",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "simulate_counts_zero_inflated",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def simulate_counts_zero_inflated(adata, threshold=None, target_max=10000, plot_flag=False):\n    X = adata.X.copy()\n    # If no threshold provided, estimate with GMM\n    if threshold is None:\n        nonzero_vals = X[X > 0].reshape(-1, 1)\n        gmm = GaussianMixture(n_components=2, random_state=0).fit(nonzero_vals)\n        means = gmm.means_.flatten()\n        stds = np.sqrt(gmm.covariances_).flatten()\n        noise_idx = np.argmin(means)\n        threshold = means[noise_idx] + 2 * stds[noise_idx]",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "transfer_to_integer_range_nb",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def transfer_to_integer_range_nb(adata, target_max=10000, plot_flag=False):\n    \"\"\"\n    Convert continuous data to integer range suitable for negative binomial modeling.\n    Preserves the overdispersion characteristics of the original data.\n    \"\"\"\n    X = adata.X.copy()\n    # Remove negative values if present\n    X[X < 0] = 0\n    # For NB, we want to preserve the mean-variance relationship\n    # Scale by the minimum positive value to maintain relative differences",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "transfer_to_integer_range_normal",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def transfer_to_integer_range_normal(adata, target_max=10000, plot_flag=False):\n    X = adata.X.copy()\n    # Remove negative values if present\n    X[X < 0] = 0\n    # Linearly rescale to [0, target_max]\n    X_max = np.max(X)\n    if X_max > 0:\n        X_scaled = X / X_max * target_max\n    else:\n        X_scaled = X",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "batched_cdist",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def batched_cdist(X, Y, batch_size=5000):\n    \"\"\"Calculate pairwise distances in batches to prevent memory issues.\"\"\"\n    n_x = X.shape[0]\n    n_y = Y.shape[0]\n    distances = np.zeros((n_x, n_y))\n    for i in tqdm(range(0, n_x, batch_size), desc=\"Processing rows\", total=n_x // batch_size):\n        end_i = min(i + batch_size, n_x)\n        batch_X = X[i:end_i]\n        for j in range(0, n_y, batch_size):\n            end_j = min(j + batch_size, n_y)",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "is_already_integer",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def is_already_integer(adata):\n    \"\"\"Check if data is already close to integers\"\"\"\n    X = adata.X.toarray() if hasattr(adata.X, \"toarray\") else adata.X\n    return np.allclose(X, np.round(X))\ndef ensure_correct_dtype(adata, target_dtype=np.int32):\n    \"\"\"Ensure data has correct integer dtype if already integer\"\"\"\n    if adata.X.dtype != target_dtype:\n        adata.X = adata.X.astype(target_dtype)\n    return adata\n# Functions needed by DualVAETrainingPlan",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "ensure_correct_dtype",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def ensure_correct_dtype(adata, target_dtype=np.int32):\n    \"\"\"Ensure data has correct integer dtype if already integer\"\"\"\n    if adata.X.dtype != target_dtype:\n        adata.X = adata.X.astype(target_dtype)\n    return adata\n# Functions needed by DualVAETrainingPlan\ndef compute_pairwise_distances(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:\n    # x: [N, D], y: [M, D]\n    # Returns: [N, M] distance matrix\n    x_norm = (x**2).sum(dim=1, keepdim=True)  # [N, 1]",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "compute_pairwise_distances",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def compute_pairwise_distances(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:\n    # x: [N, D], y: [M, D]\n    # Returns: [N, M] distance matrix\n    x_norm = (x**2).sum(dim=1, keepdim=True)  # [N, 1]\n    y_norm = (y**2).sum(dim=1, keepdim=True)  # [M, 1]\n    xy = torch.matmul(x, y.transpose(-2, -1))  # [N, M]\n    return torch.sqrt(torch.clamp(x_norm + y_norm.transpose(-2, -1) - 2 * xy, min=1e-8))\ndef compute_pairwise_kl_two_items(loc1, loc2, scale1, scale2, eps=1e-8, plot_flag=False):\n    # Assumes scale* are std, not variance\n    loc1 = loc1.unsqueeze(1)",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "compute_pairwise_kl_two_items",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def compute_pairwise_kl_two_items(loc1, loc2, scale1, scale2, eps=1e-8, plot_flag=False):\n    # Assumes scale* are std, not variance\n    loc1 = loc1.unsqueeze(1)\n    loc2 = loc2.unsqueeze(0)\n    s1 = torch.clamp(scale1.unsqueeze(1), min=eps)\n    s2 = torch.clamp(scale2.unsqueeze(0), min=eps)\n    diff = loc1 - loc2\n    kl = (torch.log(s2 / s1) + (s1**2 + diff**2) / (2 * s2**2) - 0.5).sum(dim=-1)\n    if plot_flag and False:  # verity this works before plotting\n        # Plot PCA of concatenated means, all points blue, closest pair red, farthest pair green",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "get_memory_usage",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def get_memory_usage():\n    \"\"\"Get current memory usage in GB\"\"\"\n    process = psutil.Process(os.getpid())\n    return process.memory_info().rss / 1024 / 1024 / 1024  # Convert to GB\ndef log_memory_usage(prefix=\"\"):\n    \"\"\"Log current memory usage\"\"\"\n    mem_usage = get_memory_usage()\n    logger.info(f\"{prefix}Memory usage: {mem_usage:.2f} GB\")\n    return mem_usage\ndef clear_memory():",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "log_memory_usage",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def log_memory_usage(prefix=\"\"):\n    \"\"\"Log current memory usage\"\"\"\n    mem_usage = get_memory_usage()\n    logger.info(f\"{prefix}Memory usage: {mem_usage:.2f} GB\")\n    return mem_usage\ndef clear_memory():\n    \"\"\"Clear memory by running garbage collection and clearing CUDA cache if available\"\"\"\n    gc.collect()\n    if torch.cuda.is_available():\n        torch.cuda.empty_cache()",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "clear_memory",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def clear_memory():\n    \"\"\"Clear memory by running garbage collection and clearing CUDA cache if available\"\"\"\n    gc.collect()\n    if torch.cuda.is_available():\n        torch.cuda.empty_cache()\n    return get_memory_usage()\ndef log_parameters(params, run_index, total_runs):\n    \"\"\"Log parameters for a run.\"\"\"\n    logger.info(f\"\\nParameters for run {run_index + 1}/{total_runs}:\")\n    # Group parameters by category",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "log_parameters",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def log_parameters(params, run_index, total_runs):\n    \"\"\"Log parameters for a run.\"\"\"\n    logger.info(f\"\\nParameters for run {run_index + 1}/{total_runs}:\")\n    # Group parameters by category\n    model_params = {\n        \"n_hidden_rna\": params.get(\"n_hidden_rna\"),\n        \"n_hidden_prot\": params.get(\"n_hidden_prot\"),\n        \"n_layers\": params.get(\"n_layers\"),\n        \"latent_dim\": params.get(\"latent_dim\"),\n    }",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "generate_post_training_visualizations",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def generate_post_training_visualizations(\n    adata_rna,\n    adata_prot,\n    rna_latent,\n    prot_latent,\n    combined_latent,\n    history,\n    matching_results,\n):\n    \"\"\"Generate all visualizations for the model.\"\"\"",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def handle_error(e, params, run_name):\n    \"\"\"Handle errors during hyperparameter search.\"\"\"\n    logger.error(\"\\n\" + \"=\" * 80)\n    logger.error(\" RUN FAILED \".center(80))\n    logger.error(\"=\" * 80 + \"\\n\")\n    error_msg = f\"\"\"\n    Error in run {run_name}:\n    Error Type: {type(e).__name__}\n    Error Message: {str(e)}\n    Memory Usage: {get_memory_usage():.2f} GB",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "generate_target_cluster_structure_from_cell_types",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def generate_target_cluster_structure_from_cell_types(\n    adata_original_for_vae_plots,\n    orginal_num_features,\n    cell_types_column=\"cell_types\",\n):\n    from simple_protein_vae import calculate_silhouette_score\n    \"\"\"\n    Generate target cluster structure using existing cell type annotations.\n    This function calculates target cluster structure statistics based on\n    provided cell type labels instead of performing unsupervised clustering.",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "generate_target_cluster_structure_unsuprvised",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def generate_target_cluster_structure_unsuprvised(\n    adata_original_for_vae_plots,\n    orginal_num_features,\n    clustering_resolution=None,\n):\n    \"\"\"\n    Generate target cluster structure for VAE training.\n    This function performs unsupervised clustering on protein features only\n    and calculates target cluster structure statistics.\n    Parameters",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "train_vae_for_archetype_generation",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def train_vae_for_archetype_generation(\n    adata_2_prot,\n    adata_original_for_vae_plots,\n    target_cluster_structure,\n    vae_hyperparams,\n    experiment_name=\"Archetype_Generation_Protein_VAE\",\n    run_name_prefix=\"VAE_dim_reduction_protein_in_archetype_script\",\n):\n    \"\"\"\n    Train a VAE for protein data dimensionality reduction in archetype generation pipeline.",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "validate_scvi_training_mixin",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def validate_scvi_training_mixin():\n    \"\"\"Validate that the required line exists in scVI's _training_mixin.py file.\"\"\"\n    try:\n        # Import scvi to get the actual module path\n        import scvi\n        # make sume scvi is 1.2.2.post\n        if scvi.__version__ != \"1.2.2.post2\":\n            raise ValueError(f\"scVI version must be 1.2.2.post, got {scvi.__version__}\")\n        scvi_path = scvi.__file__\n        base_dir = os.path.dirname(os.path.dirname(scvi_path))",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "predict_rna_cn_from_protein_neighbors",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def predict_rna_cn_from_protein_neighbors(\n    latent_distances: torch.Tensor,\n    protein_cn_values: np.ndarray,\n    protein_batch_labels: np.ndarray,\n    k: int = 3,\n) -> np.ndarray:\n    \"\"\"\n    Predict RNA CN from protein CN by finding closest protein cells in latent space.\n    Args:\n        latent_distances: Distance matrix between RNA and protein cells",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "get_latent_embedding",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def get_latent_embedding(\n    model,\n    adata,\n    batch_size=1000,\n    device=\"cuda:0\" if torch.cuda.is_available() else \"cpu\",\n):\n    \"\"\"Get latent embedding for data using a trained model.\n    Args:\n        model: Trained SCVI model (RNA or protein)\n        adata: AnnData object with data to embed",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "create_counterfactual_adata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "def create_counterfactual_adata(\n    self: \"DualVAETrainingPlan\",\n    adata_rna_save: AnnData,\n    adata_prot_save: AnnData,\n    rna_latent=None,\n    protein_latent=None,\n    plot_flag=False,\n    skip_normalization=False,\n) -> tuple[AnnData, AnnData, AnnData, AnnData]:\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "_project_root",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "_project_root = Path(__file__).resolve().parent.parent.parent\nif str(_project_root / \"CODEX_RNA_seq\") not in sys.path:\n    sys.path.insert(0, str(_project_root / \"CODEX_RNA_seq\"))\ndef generate_target_cluster_structure_from_cell_types(\n    adata_original_for_vae_plots,\n    orginal_num_features,\n    cell_types_column=\"cell_types\",\n):\n    from simple_protein_vae import calculate_silhouette_score\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "_project_root",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.training.utils",
        "description": "ARCADIA.src.arcadia.training.utils",
        "peekOfCode": "_project_root = Path(__file__).resolve().parent.parent.parent\nif str(_project_root / \"CODEX_RNA_seq\") not in sys.path:\n    sys.path.insert(0, str(_project_root / \"CODEX_RNA_seq\"))\ndef validate_scvi_training_mixin():\n    \"\"\"Validate that the required line exists in scVI's _training_mixin.py file.\"\"\"\n    try:\n        # Import scvi to get the actual module path\n        import scvi\n        # make sume scvi is 1.2.2.post\n        if scvi.__version__ != \"1.2.2.post2\":",
        "detail": "ARCADIA.src.arcadia.training.utils",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def parse_arguments():\n    \"\"\"Parse command line arguments for hyperparameter search.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Hyperparameter search for VAE training\")\n    # Add arguments for all possible grid parameters\n    grid_params = [\n        \"plot_x_times\",\n        \"check_val_every_n_epoch\",\n        \"max_epochs\",\n        \"save_checkpoint_every_n_epochs\",\n        \"batch_size\",",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_pipeline_arguments",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def parse_pipeline_arguments():\n    \"\"\"Parse command line arguments for pipeline scripts.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Pipeline script with dataset name support\")\n    # Add dataset name argument\n    parser.add_argument(\n        \"--dataset_name\",\n        type=str,\n        default=None,\n        help=\"Specify which dataset to load (if not provided, defaults to None)\",\n    )",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "convert_arg_type",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def convert_arg_type(value, param_name):\n    \"\"\"Convert string argument to appropriate type based on parameter name.\"\"\"\n    if value is None:\n        return None\n    # Boolean parameters\n    bool_params = [\n        \"plot_first_step\",\n        \"outlier_detection_enabled\",\n        \"similarity_dynamic\",\n        \"load_optimizer_state\",",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "find_latest_checkpoint_folder",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def find_latest_checkpoint_folder(logger, dataset_name=None):\n    \"\"\"Find the latest checkpoint folder from MLflow runs with actual model files, ignoring deleted experiments.\"\"\"\n    import yaml\n    mlruns_path = \"mlruns\"\n    if not os.path.exists(mlruns_path):\n        logger.warning(f\"MLflow runs directory not found: {mlruns_path}\")\n        return None\n    # Find all checkpoint folders in all experiments and runs\n    checkpoint_pattern = os.path.join(mlruns_path, \"*\", \"*\", \"artifacts\", \"checkpoints\", \"epoch_*\")\n    checkpoint_folders = glob.glob(checkpoint_pattern)",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "apply_command_line_overrides",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def apply_command_line_overrides(param_grid, args, logger):\n    \"\"\"Apply command line argument overrides to parameter grid.\"\"\"\n    for param_name in param_grid.keys():\n        arg_value = getattr(args, param_name, None)\n        if arg_value is not None:\n            converted_value = convert_arg_type(arg_value, param_name)\n            param_grid[param_name] = [converted_value]\n            logger.info(f\"Overriding {param_name} with command line value: {converted_value}\")\n    return param_grid\ndef apply_baseline_settings(param_grid, args, logger):",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "apply_baseline_settings",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def apply_baseline_settings(param_grid, args, logger):\n    \"\"\"Apply baseline model settings if requested.\"\"\"\n    if args.baseline:\n        logger.info(\n            \"Applying baseline model settings - setting all weights to 0 except similarity (100000), RNA, and protein reconstruction\"\n        )\n        baseline_overrides = {\n            \"contrastive_weight\": [0],\n            \"diversity_weight\": [0.0],\n            \"matching_weight\": [0],",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_compare_arguments",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def parse_compare_arguments():\n    \"\"\"\n    Parse command line arguments for comparison script.\n    Returns:\n        tuple: (args, unknown) - parsed arguments and unknown arguments\n    Example:\n        >>> args, unknown = parse_compare_arguments()\n        >>> print(args.experiment_name)\n        'cite_seq'\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "get_default_compare_args",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def get_default_compare_args():\n    \"\"\"Get default arguments for comparison script (for notebook/interactive use).\"\"\"\n    class Args:\n        checkpoint_path = None\n        experiment_name = None\n        other_model_name = \"maxfuse\"\n        experiment_id = None\n        run_id = None\n    return Args()\ndef find_checkpoint_from_experiment_name(experiment_name, max_results=5):",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "find_checkpoint_from_experiment_name",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def find_checkpoint_from_experiment_name(experiment_name, max_results=5):\n    \"\"\"\n    Find the latest checkpoint from an MLflow experiment by name using MLflow API.\n    Args:\n        experiment_name: Name of the MLflow experiment (e.g., \"cite_seq\", \"tonsil\")\n        max_results: Maximum number of recent runs to check (default: 5)\n    Returns:\n        tuple: (checkpoint_path, experiment_id, run_id)\n            - checkpoint_path: Full path to the latest checkpoint folder\n            - experiment_id: MLflow experiment ID",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "parse_batch_performance_arguments",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.args",
        "description": "ARCADIA.src.arcadia.utils.args",
        "peekOfCode": "def parse_batch_performance_arguments():\n    \"\"\"\n    Parse command line arguments for batch performance analysis script.\n    Returns:\n        Namespace: parsed arguments with dataset_names, num_runs, skip_first_n_runs, other_model_name\n    Example:\n        >>> args = parse_batch_performance_arguments()\n        >>> print(args.dataset_names)\n        ['tonsil', 'cite_seq']\n        >>> print(args.num_runs)",
        "detail": "ARCADIA.src.arcadia.utils.args",
        "documentation": {}
    },
    {
        "label": "setup_environment",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.environment",
        "description": "ARCADIA.src.arcadia.utils.environment",
        "peekOfCode": "def setup_environment():\n    \"\"\"Setup environment variables and random seeds\"\"\"\n    device = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\n    pd.set_option(\"display.max_columns\", 10)\n    pd.set_option(\"display.max_rows\", 10)\n    warnings.filterwarnings(\"ignore\")\n    pd.options.display.max_rows = 10\n    pd.options.display.max_columns = 10\n    np.set_printoptions(threshold=100)\n    np.random.seed(0)",
        "detail": "ARCADIA.src.arcadia.utils.environment",
        "documentation": {}
    },
    {
        "label": "get_umap_filtered_fucntion",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.environment",
        "description": "ARCADIA.src.arcadia.utils.environment",
        "peekOfCode": "def get_umap_filtered_fucntion():\n    \"\"\"Get UMAP function that filters duplicates before running.\"\"\"\n    # Save original UMAP function if not already wrapped\n    _original_umap = sc.tl.umap\n    def umap_filtered(adata, *args, **kwargs):\n        if \"duplicate\" in adata.obs.columns:\n            # Filter duplicates and remove the triggering column\n            adata_filtered = adata[~adata.obs[\"duplicate\"]].copy()\n            adata_filtered.obs[\"duplicate_temp\"] = adata_filtered.obs[\"duplicate\"]\n            del adata_filtered.obs[\"duplicate\"]",
        "detail": "ARCADIA.src.arcadia.utils.environment",
        "documentation": {}
    },
    {
        "label": "filter_and_transform",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "def filter_and_transform(record):\n    # Filter by level\n    if record[\"level\"].no < logger.level(\"INFO\").no:\n        return False\n    # Transform module name\n    record[\"extra\"] = {\"module_name\": record[\"name\"].split(\".\")[-1]}\n    return True\ndef setup_logger(log_file=None, level=\"INFO\", rotation=\"500 MB\"):\n    \"\"\"Configure logger with custom format and optional file output.\n    Args:",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "def setup_logger(log_file=None, level=\"INFO\", rotation=\"500 MB\"):\n    \"\"\"Configure logger with custom format and optional file output.\n    Args:\n        log_file: Single log file path or list of log file paths\n        level: Logging level\n        rotation: Log rotation size\n    \"\"\"\n    # Remove default handler\n    logger.remove()\n    # Custom format without date and with module name (stripping CODEX_RNA_seq prefix)",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "print_distance_metrics",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "def print_distance_metrics(prot_distances, rna_distances, num_acceptable, num_cells, matching_loss):\n    logger.info(\"\\n--- DISTANCE METRICS ---\\n\")\n    table_data = [\n        [\"Metric\", \"Value\"],\n        [\"Mean protein distances\", f\"{prot_distances.mean().item():.4f}\"],\n        [\"Mean RNA distances\", f\"{rna_distances.mean().item():.4f}\"],\n        [\"Acceptable ratio\", f\"{num_acceptable.float().item() / num_cells:.4f}\"],\n        [\"Matching loss\", f\"{matching_loss.item():.4f}\"],\n    ]\n    logger.info(\"\\n\" + tabulate(table_data, headers=\"firstrow\", tablefmt=\"fancy_grid\"))",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "log_epoch_end",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "def log_epoch_end(current_epoch, train_losses, val_losses, log_to_mlflow=True):\n    # Calculate epoch averages\n    epoch_avg_train_loss = sum(train_losses) / len(train_losses)\n    epoch_avg_val_loss = sum(val_losses) / len(val_losses) if val_losses else np.nan\n    logger.info(f\"\\n--- EPOCH {current_epoch} SUMMARY ---\\n\")\n    table_data = [\n        [\"Metric\", \"Value\"],\n        [\"Average train loss\", f\"{epoch_avg_train_loss:.4f}\"],\n        [\"Average validation loss\", f\"{epoch_avg_val_loss:.4f}\"],\n    ]",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "estimate_training_time",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "def estimate_training_time(rna_cells, prot_cells, params, total_combinations):\n    \"\"\"\n    Estimates training time based on dataset sizes and hyperparameters.\n    Args:\n        rna_cells: Number of RNA cells\n        prot_cells: Number of protein cells\n        params: Dictionary of hyperparameters\n        total_combinations: Total number of parameter combinations to try\n    Returns:\n        Tuple of (estimated_time_per_iter, total_estimated_time)",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "save_tabulate_to_txt",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "def save_tabulate_to_txt(losses, global_step, total_steps, is_validation=False):\n    \"\"\"Save losses as a formatted table and log it to MLflow.\n    Args:\n        losses: Dictionary containing loss values\n        global_step: Current global step\n        total_steps: Total number of steps\n        is_validation: Whether this is validation data\n    \"\"\"\n    # Convert tensor values to Python scalars\n    losses_to_save = {",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "log_step",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "def log_step(\n    losses,\n    metrics=None,\n    global_step=None,\n    current_epoch=None,\n    is_validation=False,\n    similarity_weight=None,\n    similarity_active=None,\n    num_acceptable=None,\n    num_cells=None,",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "logger = setup_logger(level=\"INFO\")\n# Create a global logger instance that can be modified\nglobal_logger = logger\n# %%\n# Imports\n# %%\ndef print_distance_metrics(prot_distances, rna_distances, num_acceptable, num_cells, matching_loss):\n    logger.info(\"\\n--- DISTANCE METRICS ---\\n\")\n    table_data = [\n        [\"Metric\", \"Value\"],",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "global_logger",
        "kind": 5,
        "importPath": "ARCADIA.src.arcadia.utils.logging",
        "description": "ARCADIA.src.arcadia.utils.logging",
        "peekOfCode": "global_logger = logger\n# %%\n# Imports\n# %%\ndef print_distance_metrics(prot_distances, rna_distances, num_acceptable, num_cells, matching_loss):\n    logger.info(\"\\n--- DISTANCE METRICS ---\\n\")\n    table_data = [\n        [\"Metric\", \"Value\"],\n        [\"Mean protein distances\", f\"{prot_distances.mean().item():.4f}\"],\n        [\"Mean RNA distances\", f\"{rna_distances.mean().item():.4f}\"],",
        "detail": "ARCADIA.src.arcadia.utils.logging",
        "documentation": {}
    },
    {
        "label": "get_caller_file",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def get_caller_file():\n    \"\"\"Get the filename of the calling script.\"\"\"\n    # two frames up\n    caller_frame = inspect.stack()[2]\n    filename = caller_frame.filename  # Full path to the caller's file\n    # Handle notebook execution - look for the original script name\n    if \"ipykernel\" in filename or \"/tmp/\" in filename or \"/var/tmp/\" in filename:\n        # Try to find a more meaningful filename from the stack\n        for frame_info in inspect.stack():\n            frame_filename = frame_info.filename",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "initialize_pipeline_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def initialize_pipeline_metadata(\n    timestamp_str: str,\n    FILENAME: str,\n    dataset_name: str,\n) -> Dict[str, Any]:\n    \"\"\"\n    Initialize pipeline metadata structure for the first preprocessing step.\n    Creates empty dicts for all pipeline steps to avoid existence checks downstream.\n    Args:\n        timestamp_str: Timestamp string for the pipeline run",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "update_preprocess_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def update_preprocess_metadata(\n    adata,\n    filtering_steps: List[str],\n    normalization: Optional[str] = None,\n    n_highly_variable_genes_rna: Optional[int] = None,\n) -> None:\n    \"\"\"\n    Update preprocessing metadata for the Schreiber dataset preprocessing steps.\n    Args:\n        adata: AnnData object to update",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "initialize_archetype_generation_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def initialize_archetype_generation_metadata(\n    adata_rna,\n    adata_prot,\n    rna_file: str,\n    prot_file: str,\n    cn_type: str,\n    num_cn_clusters: int,\n    leiden_resolution: Optional[float] = None,\n    vae_hyperparams: Optional[Dict[str, Any]] = None,\n    pca_params: Optional[Dict[str, Any]] = None,",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "update_archetype_generation_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def update_archetype_generation_metadata(\n    adata_rna,\n    adata_prot,\n    cross_modal_distance_matrix: Optional[np.ndarray] = None,\n    rna_to_prot_matches: Optional[np.ndarray] = None,\n    prot_to_rna_matches: Optional[np.ndarray] = None,\n) -> None:\n    \"\"\"\n    Update archetype generation metadata with cross-modal matching results.\n    Args:",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "initialize_prepare_data_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def initialize_prepare_data_metadata(adata_rna, adata_prot) -> None:\n    \"\"\"\n    Initialize prepare data metadata.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n    \"\"\"\n    adata_rna.uns[\"pipeline_metadata\"][\"prepare_data\"].update(\n        {\n            \"original_shape\": list(adata_rna.shape),",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "update_prepare_data_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def update_prepare_data_metadata(adata_rna, adata_prot, archetype_distances: np.ndarray) -> None:\n    \"\"\"\n    Update prepare data metadata with archetype matching results.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n        archetype_distances: Distance matrix between RNA and protein archetypes\n    \"\"\"\n    if \"prepare_data\" not in adata_rna.uns[\"pipeline_metadata\"]:\n        initialize_prepare_data_metadata(adata_rna, adata_prot)",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "initialize_train_vae_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def initialize_train_vae_metadata(\n    adata_rna, adata_prot, training_parameters: Dict[str, Any]\n) -> None:\n    \"\"\"\n    Initialize VAE training metadata.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n        training_parameters: Dictionary of training parameters\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "update_train_vae_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def update_train_vae_metadata(adata_rna, adata_prot, training_results: Dict[str, Any]) -> None:\n    \"\"\"\n    Update VAE training metadata with results.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n        training_results: Dictionary of training results\n    \"\"\"\n    if \"train_vae\" not in adata_rna.uns[\"pipeline_metadata\"]:\n        print(\"Warning: train_vae metadata not found. Initialize first.\")",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "copy_pipeline_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def copy_pipeline_metadata(source_adata, target_adata) -> None:\n    \"\"\"\n    Copy pipeline metadata from source to target AnnData object.\n    Args:\n        source_adata: Source AnnData object\n        target_adata: Target AnnData object\n    \"\"\"\n    if \"pipeline_metadata\" in source_adata.uns:\n        target_adata.uns[\"pipeline_metadata\"] = source_adata.uns[\"pipeline_metadata\"].copy()\ndef get_pipeline_summary(adata) -> Dict[str, Any]:",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "get_pipeline_summary",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def get_pipeline_summary(adata) -> Dict[str, Any]:\n    \"\"\"\n    Get a summary of the pipeline metadata.\n    Args:\n        adata: AnnData object\n    Returns:\n        Dictionary containing pipeline summary\n    \"\"\"\n    if \"pipeline_metadata\" not in adata.uns:\n        return {\"error\": \"No pipeline metadata found\"}",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "finalize_preprocess_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def finalize_preprocess_metadata(\n    adata_rna, adata_prot, selected_batches_or_samples: List[str]\n) -> None:\n    \"\"\"\n    Finalize metadata for preprocessing scripts.\n    Args:\n        adata_rna: RNA AnnData object\n        adata_prot: Protein AnnData object\n        selected_batches_or_samples: List of batch names or sample names used in preprocessing\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "finalize_align_datasets_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def finalize_align_datasets_metadata(adata_rna, adata_prot, n_highly_variable_genes: int) -> None:\n    \"\"\"\n    Finalize metadata for _1_align_datasets.py\n    \"\"\"\n    update_preprocess_metadata(\n        adata_rna,\n        [],\n        normalization=\"raw_data_before_spatial_features\",\n        n_highly_variable_genes_rna=n_highly_variable_genes,\n    )",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "finalize_spatial_info_integrate_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def finalize_spatial_info_integrate_metadata(\n    adata_rna,\n    adata_prot,\n    rna_file: str,\n    prot_file: str,\n    vae_hyperparams: Optional[Dict[str, Any]] = None,\n) -> None:\n    \"\"\"\n    Finalize metadata for _2_spatial_info_integrate.py\n    \"\"\"",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "finalize_archetype_generation_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def finalize_archetype_generation_metadata(\n    adata_rna,\n    adata_prot,\n    similarity_matrix: np.ndarray,\n    rna_to_prot_matches: np.ndarray,\n    prot_to_rna_matches: np.ndarray,\n    pca_params: Optional[Dict[str, Any]] = None,\n) -> None:\n    \"\"\"\n    Finalize metadata for _3_archetype_generation_neighbors_covet.py",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "finalize_prepare_data_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def finalize_prepare_data_metadata(adata_rna, adata_prot, archetype_distances: np.ndarray) -> None:\n    \"\"\"\n    Finalize metadata for _4_prepare_data_for_training.py\n    \"\"\"\n    initialize_prepare_data_metadata(adata_rna, adata_prot)\n    update_prepare_data_metadata(adata_rna, adata_prot, archetype_distances)\ndef finalize_train_vae_metadata(\n    adata_rna,\n    adata_prot,\n    training_params: Dict[str, Any],",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "finalize_train_vae_metadata",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.metadata",
        "description": "ARCADIA.src.arcadia.utils.metadata",
        "peekOfCode": "def finalize_train_vae_metadata(\n    adata_rna,\n    adata_prot,\n    training_params: Dict[str, Any],\n    training_results: Optional[Dict[str, Any]] = None,\n) -> None:\n    \"\"\"\n    Finalize metadata for _5_train_vae_with_archetypes_vectors.py\n    \"\"\"\n    initialize_train_vae_metadata(adata_rna, adata_prot, training_params)",
        "detail": "ARCADIA.src.arcadia.utils.metadata",
        "documentation": {}
    },
    {
        "label": "here",
        "kind": 2,
        "importPath": "ARCADIA.src.arcadia.utils.paths",
        "description": "ARCADIA.src.arcadia.utils.paths",
        "peekOfCode": "def here():\n    \"\"\"Get the directory containing the calling script or current working directory.\n    Returns:\n        Path: Path to the directory containing the calling script, or current working directory\n              if called from a notebook or interactive session.\n    \"\"\"\n    try:\n        frame = inspect.stack()[1]\n        caller_file = frame.filename\n        return Path(caller_file).resolve().parent",
        "detail": "ARCADIA.src.arcadia.utils.paths",
        "documentation": {}
    },
    {
        "label": "here",
        "kind": 2,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "def here():\n    try:\n        return Path(__file__).resolve().parent\n    except NameError:\n        return Path.cwd()\n# Set up paths - model_comparison is at project root level\nTHIS_DIR = here()\nPROJECT_ROOT = THIS_DIR.parent\nARCADIA_ROOT = PROJECT_ROOT / \"ARCADIA\"\nARCADIA_SRC = ARCADIA_ROOT / \"src\"",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "save_confusion_matrix_csv",
        "kind": 2,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "def save_confusion_matrix_csv(true_labels, predicted_labels, save_path, normalize='columns'):\n    \"\"\"Save confusion matrix as percentage CSV compatible with generate_publication_figures_github.py.\"\"\"\n    cm = pd.crosstab(\n        true_labels.values,\n        predicted_labels.values,\n        rownames=[\"True\"],\n        colnames=[\"Predicted\"],\n        margins=False,\n    )\n    if normalize == 'columns':",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "FILENAME",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "FILENAME = \"compare_results.py\"\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"louvain\")\ndef here():\n    try:\n        return Path(__file__).resolve().parent\n    except NameError:\n        return Path.cwd()\n# Set up paths - model_comparison is at project root level\nTHIS_DIR = here()",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "THIS_DIR = here()\nPROJECT_ROOT = THIS_DIR.parent\nARCADIA_ROOT = PROJECT_ROOT / \"ARCADIA\"\nARCADIA_SRC = ARCADIA_ROOT / \"src\"\n# Update sys.path to include ARCADIA/src for imports\nsys.path.insert(0, str(ARCADIA_SRC))\nsys.path.insert(0, str(ARCADIA_ROOT))\n# Change to ARCADIA directory for MLflow tracking\nos.chdir(str(ARCADIA_ROOT))\nimport anndata as ad",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "PROJECT_ROOT",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "PROJECT_ROOT = THIS_DIR.parent\nARCADIA_ROOT = PROJECT_ROOT / \"ARCADIA\"\nARCADIA_SRC = ARCADIA_ROOT / \"src\"\n# Update sys.path to include ARCADIA/src for imports\nsys.path.insert(0, str(ARCADIA_SRC))\nsys.path.insert(0, str(ARCADIA_ROOT))\n# Change to ARCADIA directory for MLflow tracking\nos.chdir(str(ARCADIA_ROOT))\nimport anndata as ad\nimport numpy as np",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "ARCADIA_ROOT",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "ARCADIA_ROOT = PROJECT_ROOT / \"ARCADIA\"\nARCADIA_SRC = ARCADIA_ROOT / \"src\"\n# Update sys.path to include ARCADIA/src for imports\nsys.path.insert(0, str(ARCADIA_SRC))\nsys.path.insert(0, str(ARCADIA_ROOT))\n# Change to ARCADIA directory for MLflow tracking\nos.chdir(str(ARCADIA_ROOT))\nimport anndata as ad\nimport numpy as np\nimport scanpy as sc",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "ARCADIA_SRC",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "ARCADIA_SRC = ARCADIA_ROOT / \"src\"\n# Update sys.path to include ARCADIA/src for imports\nsys.path.insert(0, str(ARCADIA_SRC))\nsys.path.insert(0, str(ARCADIA_ROOT))\n# Change to ARCADIA directory for MLflow tracking\nos.chdir(str(ARCADIA_ROOT))\nimport anndata as ad\nimport numpy as np\nimport scanpy as sc\nimport matplotlib as mpl",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "config_path = ARCADIA_ROOT / \"CODEX_RNA_seq\" / \"config.json\"\nif config_path.exists():\n    with open(config_path, \"r\") as f:\n        config_ = json.load(f)\n    num_rna_cells = config_[\"subsample\"][\"num_rna_cells\"]\n    num_protein_cells = config_[\"subsample\"][\"num_protein_cells\"]\n    plot_flag = config_[\"plot_flag\"]\nelse:\n    num_rna_cells = num_protein_cells = 2000\n    plot_flag = True",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "start_time",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "start_time = datetime.now()\ntimestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\", fontsize=10)\nbase_path = \"CODEX_RNA_seq/data\"\n# In[2]:\n# load arcadia data\nif args.checkpoint_path is not None:\n    # Use explicitly provided checkpoint path (highest priority)\n    checkpoint_path = args.checkpoint_path\n    experiment_id_from_path = None",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "timestamp_str",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "timestamp_str = start_time.strftime(\"%Y%m%d_%H%M%S\")\nsc.settings.set_figure_params(dpi=50, facecolor=\"white\", fontsize=10)\nbase_path = \"CODEX_RNA_seq/data\"\n# In[2]:\n# load arcadia data\nif args.checkpoint_path is not None:\n    # Use explicitly provided checkpoint path (highest priority)\n    checkpoint_path = args.checkpoint_path\n    experiment_id_from_path = None\n    run_id_from_path = None",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "base_path",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "base_path = \"CODEX_RNA_seq/data\"\n# In[2]:\n# load arcadia data\nif args.checkpoint_path is not None:\n    # Use explicitly provided checkpoint path (highest priority)\n    checkpoint_path = args.checkpoint_path\n    experiment_id_from_path = None\n    run_id_from_path = None\nelif args.experiment_name is not None:\n    # Find checkpoint from experiment name",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "config_path",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "config_path = Path(checkpoint_path).parent.parent / \"model_config.json\"\ncheckpoint_folder = Path(checkpoint_path)\n# Print checkpoint age\ncheckpoint_time = datetime.fromtimestamp(os.path.getmtime(checkpoint_folder))\ntime_diff = datetime.now() - checkpoint_time\nif time_diff.days > 0:\n    print(\n        f\"Checkpoint was created {time_diff.days} days, {time_diff.seconds//3600} hours, {(time_diff.seconds%3600)//60} minutes ago\"\n    )\nelif time_diff.seconds > 3600:",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "checkpoint_folder",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "checkpoint_folder = Path(checkpoint_path)\n# Print checkpoint age\ncheckpoint_time = datetime.fromtimestamp(os.path.getmtime(checkpoint_folder))\ntime_diff = datetime.now() - checkpoint_time\nif time_diff.days > 0:\n    print(\n        f\"Checkpoint was created {time_diff.days} days, {time_diff.seconds//3600} hours, {(time_diff.seconds%3600)//60} minutes ago\"\n    )\nelif time_diff.seconds > 3600:\n    print(",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "checkpoint_time",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "checkpoint_time = datetime.fromtimestamp(os.path.getmtime(checkpoint_folder))\ntime_diff = datetime.now() - checkpoint_time\nif time_diff.days > 0:\n    print(\n        f\"Checkpoint was created {time_diff.days} days, {time_diff.seconds//3600} hours, {(time_diff.seconds%3600)//60} minutes ago\"\n    )\nelif time_diff.seconds > 3600:\n    print(\n        f\"Checkpoint was created {time_diff.seconds//3600} hours, {(time_diff.seconds%3600)//60} minutes ago\"\n    )",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "time_diff",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "time_diff = datetime.now() - checkpoint_time\nif time_diff.days > 0:\n    print(\n        f\"Checkpoint was created {time_diff.days} days, {time_diff.seconds//3600} hours, {(time_diff.seconds%3600)//60} minutes ago\"\n    )\nelif time_diff.seconds > 3600:\n    print(\n        f\"Checkpoint was created {time_diff.seconds//3600} hours, {(time_diff.seconds%3600)//60} minutes ago\"\n    )\nelse:",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "dataset_name = adata_rna_arcadia.uns.get(\"dataset_name\", \"unknown\")\nif args.other_model_name is None:\n    # other_model_name = \"maxfuse\"\n    other_model_name = \"scmodal\"\nelse:\n    other_model_name = args.other_model_name\nif dataset_name == \"tonsil\":\n    adata_rna_arcadia.uns[\"dataset_name\"] = \"tonsil\"\n    adata_prot_arcadia.uns[\"dataset_name\"] = \"tonsil\"\n    dataset_name = \"tonsil\"",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_rna_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_rna_other = load_adata_latest(\n    str(PROJECT_ROOT / f\"model_comparison/outputs/{other_model_name}_{dataset_name}\"),\n    \"rna\",\n    dataset_name=dataset_name,\n    exact_step=7,\n    index_from_end=0,\n    return_path=False,\n)\nadata_prot_other = load_adata_latest(\n    str(PROJECT_ROOT / f\"model_comparison/outputs/{other_model_name}_{dataset_name}\"),",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_prot_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_prot_other = load_adata_latest(\n    str(PROJECT_ROOT / f\"model_comparison/outputs/{other_model_name}_{dataset_name}\"),\n    \"protein\",\n    dataset_name=dataset_name,\n    exact_step=7,\n    index_from_end=0,\n    return_path=False,\n)\nif dataset_name == \"tonsil\":\n    adata_rna_other.uns[\"dataset_name\"] = \"tonsil\"",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_rna_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_rna_arcadia = add_matched_archetype_weight(adata_rna_arcadia)\nadata_prot_arcadia = add_matched_archetype_weight(adata_prot_arcadia)\nadata_rna_arcadia, adata_rna_other, mutual_genes = align_data(\n    adata_rna_arcadia, adata_rna_other, \"rna\", other_model_name\n)\nadata_prot_arcadia, adata_prot_other, mutual_prot = align_data(\n    adata_prot_arcadia, adata_prot_other, \"protein\", other_model_name\n)\nif num_rna_cells < 12000 or num_protein_cells < 12000:\n    sc.pp.subsample(adata_rna_arcadia, n_obs=(min(num_rna_cells, adata_rna_arcadia.n_obs)))",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_prot_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_prot_arcadia = add_matched_archetype_weight(adata_prot_arcadia)\nadata_rna_arcadia, adata_rna_other, mutual_genes = align_data(\n    adata_rna_arcadia, adata_rna_other, \"rna\", other_model_name\n)\nadata_prot_arcadia, adata_prot_other, mutual_prot = align_data(\n    adata_prot_arcadia, adata_prot_other, \"protein\", other_model_name\n)\nif num_rna_cells < 12000 or num_protein_cells < 12000:\n    sc.pp.subsample(adata_rna_arcadia, n_obs=(min(num_rna_cells, adata_rna_arcadia.n_obs)))\n    sc.pp.subsample(adata_prot_arcadia, n_obs=(min(num_protein_cells, adata_prot_arcadia.n_obs)))",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "select_most_common_cell_type",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "select_most_common_cell_type = False\nif select_most_common_cell_type:\n    cell_type_counts = adata_rna_arcadia.obs[\"cell_types\"].value_counts()\n    most_common_cell_type = cell_type_counts.index[0]\n    adata_rna_arcadia = adata_rna_arcadia[\n        adata_rna_arcadia.obs[\"cell_types\"] == most_common_cell_type\n    ].copy()\n    adata_prot_arcadia = adata_prot_arcadia[\n        adata_prot_arcadia.obs[\"cell_types\"] == most_common_cell_type\n    ].copy()",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_rna_arcadia.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_rna_arcadia.obsm[\"latent\"] = adata_rna_arcadia.obsm[\"X_scVI\"]\nadata_prot_arcadia.obsm[\"latent\"] = adata_prot_arcadia.obsm[\"X_scVI\"]\nadata_rna_arcadia.obsm.pop(\"X_scVI\")\nadata_prot_arcadia.obsm.pop(\"X_scVI\")\n# add CN and matched_archetype_weight and filter genes from adata_rna_arcadia to match adata_rna_other\nlatent_arcadia_rna = adata_rna_arcadia.obsm[\"latent\"]\nlatent_arcadia_prot = adata_prot_arcadia.obsm[\"latent\"]\nlatent_other_rna = adata_rna_other.obsm[\"latent\"]\nlatent_other_prot = adata_prot_other.obsm[\"latent\"]\nadata_latent_arcadia_rna = AnnData(latent_arcadia_rna, obs=adata_rna_arcadia.obs)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_prot_arcadia.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_prot_arcadia.obsm[\"latent\"] = adata_prot_arcadia.obsm[\"X_scVI\"]\nadata_rna_arcadia.obsm.pop(\"X_scVI\")\nadata_prot_arcadia.obsm.pop(\"X_scVI\")\n# add CN and matched_archetype_weight and filter genes from adata_rna_arcadia to match adata_rna_other\nlatent_arcadia_rna = adata_rna_arcadia.obsm[\"latent\"]\nlatent_arcadia_prot = adata_prot_arcadia.obsm[\"latent\"]\nlatent_other_rna = adata_rna_other.obsm[\"latent\"]\nlatent_other_prot = adata_prot_other.obsm[\"latent\"]\nadata_latent_arcadia_rna = AnnData(latent_arcadia_rna, obs=adata_rna_arcadia.obs)\nadata_latent_arcadia_prot = AnnData(latent_arcadia_prot, obs=adata_prot_arcadia.obs)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "latent_arcadia_rna",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "latent_arcadia_rna = adata_rna_arcadia.obsm[\"latent\"]\nlatent_arcadia_prot = adata_prot_arcadia.obsm[\"latent\"]\nlatent_other_rna = adata_rna_other.obsm[\"latent\"]\nlatent_other_prot = adata_prot_other.obsm[\"latent\"]\nadata_latent_arcadia_rna = AnnData(latent_arcadia_rna, obs=adata_rna_arcadia.obs)\nadata_latent_arcadia_prot = AnnData(latent_arcadia_prot, obs=adata_prot_arcadia.obs)\nadata_latent_other_rna = AnnData(latent_other_rna, obs=adata_rna_other.obs)\nadata_latent_other_prot = AnnData(latent_other_prot, obs=adata_prot_other.obs)\nsc.pp.neighbors(adata_latent_arcadia_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_arcadia_prot, n_neighbors=15)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "latent_arcadia_prot",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "latent_arcadia_prot = adata_prot_arcadia.obsm[\"latent\"]\nlatent_other_rna = adata_rna_other.obsm[\"latent\"]\nlatent_other_prot = adata_prot_other.obsm[\"latent\"]\nadata_latent_arcadia_rna = AnnData(latent_arcadia_rna, obs=adata_rna_arcadia.obs)\nadata_latent_arcadia_prot = AnnData(latent_arcadia_prot, obs=adata_prot_arcadia.obs)\nadata_latent_other_rna = AnnData(latent_other_rna, obs=adata_rna_other.obs)\nadata_latent_other_prot = AnnData(latent_other_prot, obs=adata_prot_other.obs)\nsc.pp.neighbors(adata_latent_arcadia_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_arcadia_prot, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_rna, n_neighbors=15)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "latent_other_rna",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "latent_other_rna = adata_rna_other.obsm[\"latent\"]\nlatent_other_prot = adata_prot_other.obsm[\"latent\"]\nadata_latent_arcadia_rna = AnnData(latent_arcadia_rna, obs=adata_rna_arcadia.obs)\nadata_latent_arcadia_prot = AnnData(latent_arcadia_prot, obs=adata_prot_arcadia.obs)\nadata_latent_other_rna = AnnData(latent_other_rna, obs=adata_rna_other.obs)\nadata_latent_other_prot = AnnData(latent_other_prot, obs=adata_prot_other.obs)\nsc.pp.neighbors(adata_latent_arcadia_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_arcadia_prot, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_prot, n_neighbors=15)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "latent_other_prot",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "latent_other_prot = adata_prot_other.obsm[\"latent\"]\nadata_latent_arcadia_rna = AnnData(latent_arcadia_rna, obs=adata_rna_arcadia.obs)\nadata_latent_arcadia_prot = AnnData(latent_arcadia_prot, obs=adata_prot_arcadia.obs)\nadata_latent_other_rna = AnnData(latent_other_rna, obs=adata_rna_other.obs)\nadata_latent_other_prot = AnnData(latent_other_prot, obs=adata_prot_other.obs)\nsc.pp.neighbors(adata_latent_arcadia_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_arcadia_prot, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_prot, n_neighbors=15)\n# %%",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_arcadia_rna",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_arcadia_rna = AnnData(latent_arcadia_rna, obs=adata_rna_arcadia.obs)\nadata_latent_arcadia_prot = AnnData(latent_arcadia_prot, obs=adata_prot_arcadia.obs)\nadata_latent_other_rna = AnnData(latent_other_rna, obs=adata_rna_other.obs)\nadata_latent_other_prot = AnnData(latent_other_prot, obs=adata_prot_other.obs)\nsc.pp.neighbors(adata_latent_arcadia_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_arcadia_prot, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_prot, n_neighbors=15)\n# %%\nadata_latent_arcadia_rna.obs[\"modality\"] = \"RNA\"",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_arcadia_prot",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_arcadia_prot = AnnData(latent_arcadia_prot, obs=adata_prot_arcadia.obs)\nadata_latent_other_rna = AnnData(latent_other_rna, obs=adata_rna_other.obs)\nadata_latent_other_prot = AnnData(latent_other_prot, obs=adata_prot_other.obs)\nsc.pp.neighbors(adata_latent_arcadia_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_arcadia_prot, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_prot, n_neighbors=15)\n# %%\nadata_latent_arcadia_rna.obs[\"modality\"] = \"RNA\"\nadata_latent_arcadia_prot.obs[\"modality\"] = \"Protein\"",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_other_rna",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_other_rna = AnnData(latent_other_rna, obs=adata_rna_other.obs)\nadata_latent_other_prot = AnnData(latent_other_prot, obs=adata_prot_other.obs)\nsc.pp.neighbors(adata_latent_arcadia_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_arcadia_prot, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_prot, n_neighbors=15)\n# %%\nadata_latent_arcadia_rna.obs[\"modality\"] = \"RNA\"\nadata_latent_arcadia_prot.obs[\"modality\"] = \"Protein\"\nadata_latent_other_rna.obs[\"modality\"] = \"RNA\"",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_other_prot",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_other_prot = AnnData(latent_other_prot, obs=adata_prot_other.obs)\nsc.pp.neighbors(adata_latent_arcadia_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_arcadia_prot, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_rna, n_neighbors=15)\nsc.pp.neighbors(adata_latent_other_prot, n_neighbors=15)\n# %%\nadata_latent_arcadia_rna.obs[\"modality\"] = \"RNA\"\nadata_latent_arcadia_prot.obs[\"modality\"] = \"Protein\"\nadata_latent_other_rna.obs[\"modality\"] = \"RNA\"\nadata_latent_other_prot.obs[\"modality\"] = \"Protein\"",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_arcadia_rna.obs[\"modality\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_arcadia_rna.obs[\"modality\"] = \"RNA\"\nadata_latent_arcadia_prot.obs[\"modality\"] = \"Protein\"\nadata_latent_other_rna.obs[\"modality\"] = \"RNA\"\nadata_latent_other_prot.obs[\"modality\"] = \"Protein\"\n# Add pair_id for metrics that require matched pairs (FOSKNN, FOSCTTM, pair_distance)\n# Use the obs index as pair_id since RNA and protein have matching indices\nadata_latent_arcadia_rna.obs[\"pair_id\"] = adata_latent_arcadia_rna.obs.index\nadata_latent_arcadia_prot.obs[\"pair_id\"] = adata_latent_arcadia_prot.obs.index\nadata_latent_other_rna.obs[\"pair_id\"] = adata_latent_other_rna.obs.index\nadata_latent_other_prot.obs[\"pair_id\"] = adata_latent_other_prot.obs.index",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_arcadia_prot.obs[\"modality\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_arcadia_prot.obs[\"modality\"] = \"Protein\"\nadata_latent_other_rna.obs[\"modality\"] = \"RNA\"\nadata_latent_other_prot.obs[\"modality\"] = \"Protein\"\n# Add pair_id for metrics that require matched pairs (FOSKNN, FOSCTTM, pair_distance)\n# Use the obs index as pair_id since RNA and protein have matching indices\nadata_latent_arcadia_rna.obs[\"pair_id\"] = adata_latent_arcadia_rna.obs.index\nadata_latent_arcadia_prot.obs[\"pair_id\"] = adata_latent_arcadia_prot.obs.index\nadata_latent_other_rna.obs[\"pair_id\"] = adata_latent_other_rna.obs.index\nadata_latent_other_prot.obs[\"pair_id\"] = adata_latent_other_prot.obs.index\n# Create combined latent data for metrics that need both modalities",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_other_rna.obs[\"modality\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_other_rna.obs[\"modality\"] = \"RNA\"\nadata_latent_other_prot.obs[\"modality\"] = \"Protein\"\n# Add pair_id for metrics that require matched pairs (FOSKNN, FOSCTTM, pair_distance)\n# Use the obs index as pair_id since RNA and protein have matching indices\nadata_latent_arcadia_rna.obs[\"pair_id\"] = adata_latent_arcadia_rna.obs.index\nadata_latent_arcadia_prot.obs[\"pair_id\"] = adata_latent_arcadia_prot.obs.index\nadata_latent_other_rna.obs[\"pair_id\"] = adata_latent_other_rna.obs.index\nadata_latent_other_prot.obs[\"pair_id\"] = adata_latent_other_prot.obs.index\n# Create combined latent data for metrics that need both modalities\ncombined_latent_arcadia = ad.concat(",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_other_prot.obs[\"modality\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_other_prot.obs[\"modality\"] = \"Protein\"\n# Add pair_id for metrics that require matched pairs (FOSKNN, FOSCTTM, pair_distance)\n# Use the obs index as pair_id since RNA and protein have matching indices\nadata_latent_arcadia_rna.obs[\"pair_id\"] = adata_latent_arcadia_rna.obs.index\nadata_latent_arcadia_prot.obs[\"pair_id\"] = adata_latent_arcadia_prot.obs.index\nadata_latent_other_rna.obs[\"pair_id\"] = adata_latent_other_rna.obs.index\nadata_latent_other_prot.obs[\"pair_id\"] = adata_latent_other_prot.obs.index\n# Create combined latent data for metrics that need both modalities\ncombined_latent_arcadia = ad.concat(\n    [adata_latent_arcadia_rna, adata_latent_arcadia_prot],",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_arcadia_rna.obs[\"pair_id\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_arcadia_rna.obs[\"pair_id\"] = adata_latent_arcadia_rna.obs.index\nadata_latent_arcadia_prot.obs[\"pair_id\"] = adata_latent_arcadia_prot.obs.index\nadata_latent_other_rna.obs[\"pair_id\"] = adata_latent_other_rna.obs.index\nadata_latent_other_prot.obs[\"pair_id\"] = adata_latent_other_prot.obs.index\n# Create combined latent data for metrics that need both modalities\ncombined_latent_arcadia = ad.concat(\n    [adata_latent_arcadia_rna, adata_latent_arcadia_prot],\n    label=\"modality_concat\",\n    keys=[\"RNA\", \"Protein\"],\n)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_arcadia_prot.obs[\"pair_id\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_arcadia_prot.obs[\"pair_id\"] = adata_latent_arcadia_prot.obs.index\nadata_latent_other_rna.obs[\"pair_id\"] = adata_latent_other_rna.obs.index\nadata_latent_other_prot.obs[\"pair_id\"] = adata_latent_other_prot.obs.index\n# Create combined latent data for metrics that need both modalities\ncombined_latent_arcadia = ad.concat(\n    [adata_latent_arcadia_rna, adata_latent_arcadia_prot],\n    label=\"modality_concat\",\n    keys=[\"RNA\", \"Protein\"],\n)\ncombined_latent_other = ad.concat(",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_other_rna.obs[\"pair_id\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_other_rna.obs[\"pair_id\"] = adata_latent_other_rna.obs.index\nadata_latent_other_prot.obs[\"pair_id\"] = adata_latent_other_prot.obs.index\n# Create combined latent data for metrics that need both modalities\ncombined_latent_arcadia = ad.concat(\n    [adata_latent_arcadia_rna, adata_latent_arcadia_prot],\n    label=\"modality_concat\",\n    keys=[\"RNA\", \"Protein\"],\n)\ncombined_latent_other = ad.concat(\n    [adata_latent_other_rna, adata_latent_other_prot],",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "adata_latent_other_prot.obs[\"pair_id\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "adata_latent_other_prot.obs[\"pair_id\"] = adata_latent_other_prot.obs.index\n# Create combined latent data for metrics that need both modalities\ncombined_latent_arcadia = ad.concat(\n    [adata_latent_arcadia_rna, adata_latent_arcadia_prot],\n    label=\"modality_concat\",\n    keys=[\"RNA\", \"Protein\"],\n)\ncombined_latent_other = ad.concat(\n    [adata_latent_other_rna, adata_latent_other_prot],\n    label=\"modality_concat\",",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "combined_latent_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "combined_latent_arcadia = ad.concat(\n    [adata_latent_arcadia_rna, adata_latent_arcadia_prot],\n    label=\"modality_concat\",\n    keys=[\"RNA\", \"Protein\"],\n)\ncombined_latent_other = ad.concat(\n    [adata_latent_other_rna, adata_latent_other_prot],\n    label=\"modality_concat\",\n    keys=[\"RNA\", \"Protein\"],\n)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "combined_latent_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "combined_latent_other = ad.concat(\n    [adata_latent_other_rna, adata_latent_other_prot],\n    label=\"modality_concat\",\n    keys=[\"RNA\", \"Protein\"],\n)\n# Compute neighbors for iLISI calculation\nsc.pp.neighbors(combined_latent_arcadia, use_rep=\"X\")\nsc.pp.neighbors(combined_latent_other, use_rep=\"X\")\n# In[7]:\n# %%",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "current_time",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "current_time = time()\n# Arcadia distances\nrna_X_arcadia = (\n    adata_latent_arcadia_rna.X.toarray()\n    if hasattr(adata_latent_arcadia_rna.X, \"toarray\")\n    else adata_latent_arcadia_rna.X\n)\nprot_X_arcadia = (\n    adata_latent_arcadia_prot.X.toarray()\n    if hasattr(adata_latent_arcadia_prot.X, \"toarray\")",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "rna_X_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "rna_X_arcadia = (\n    adata_latent_arcadia_rna.X.toarray()\n    if hasattr(adata_latent_arcadia_rna.X, \"toarray\")\n    else adata_latent_arcadia_rna.X\n)\nprot_X_arcadia = (\n    adata_latent_arcadia_prot.X.toarray()\n    if hasattr(adata_latent_arcadia_prot.X, \"toarray\")\n    else adata_latent_arcadia_prot.X\n)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "prot_X_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "prot_X_arcadia = (\n    adata_latent_arcadia_prot.X.toarray()\n    if hasattr(adata_latent_arcadia_prot.X, \"toarray\")\n    else adata_latent_arcadia_prot.X\n)\n# Other model distances\nrna_X_other = (\n    adata_latent_other_rna.X.toarray()\n    if hasattr(adata_latent_other_rna.X, \"toarray\")\n    else adata_latent_other_rna.X",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "rna_X_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "rna_X_other = (\n    adata_latent_other_rna.X.toarray()\n    if hasattr(adata_latent_other_rna.X, \"toarray\")\n    else adata_latent_other_rna.X\n)\nprot_X_other = (\n    adata_latent_other_prot.X.toarray()\n    if hasattr(adata_latent_other_prot.X, \"toarray\")\n    else adata_latent_other_prot.X\n)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "prot_X_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "prot_X_other = (\n    adata_latent_other_prot.X.toarray()\n    if hasattr(adata_latent_other_prot.X, \"toarray\")\n    else adata_latent_other_prot.X\n)\n# Combined latent distances (for FOSKNN and FOSCTTM)\ncombined_X_arcadia = (\n    combined_latent_arcadia.X.toarray()\n    if hasattr(combined_latent_arcadia.X, \"toarray\")\n    else combined_latent_arcadia.X",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "combined_X_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "combined_X_arcadia = (\n    combined_latent_arcadia.X.toarray()\n    if hasattr(combined_latent_arcadia.X, \"toarray\")\n    else combined_latent_arcadia.X\n)\n# %%\n# cross_modal_distances_arcadia = cdist(rna_X_arcadia, prot_X_arcadia, metric=\"euclidean\")\n# cross_modal_distances_other = cdist(rna_X_other, prot_X_other, metric=\"euclidean\")\n# combined_distances_arcadia = cdist(combined_X_arcadia, combined_X_arcadia, metric=\"euclidean\")\ncross_modal_distances_arcadia = None",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "cross_modal_distances_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "cross_modal_distances_arcadia = None\ncross_modal_distances_other = None\ncombined_distances_arcadia = None\ncombined_X_other = (\n    combined_latent_other.X.toarray()\n    if hasattr(combined_latent_other.X, \"toarray\")\n    else combined_latent_other.X\n)\n# combined_distances_other = cdist(combined_X_other, combined_X_other, metric=\"euclidean\")\ncombined_distances_other = None",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "cross_modal_distances_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "cross_modal_distances_other = None\ncombined_distances_arcadia = None\ncombined_X_other = (\n    combined_latent_other.X.toarray()\n    if hasattr(combined_latent_other.X, \"toarray\")\n    else combined_latent_other.X\n)\n# combined_distances_other = cdist(combined_X_other, combined_X_other, metric=\"euclidean\")\ncombined_distances_other = None\nprint(f\"Distance matrix computation took {time() - current_time:.2f} seconds\")",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "combined_distances_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "combined_distances_arcadia = None\ncombined_X_other = (\n    combined_latent_other.X.toarray()\n    if hasattr(combined_latent_other.X, \"toarray\")\n    else combined_latent_other.X\n)\n# combined_distances_other = cdist(combined_X_other, combined_X_other, metric=\"euclidean\")\ncombined_distances_other = None\nprint(f\"Distance matrix computation took {time() - current_time:.2f} seconds\")\n# %%",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "combined_X_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "combined_X_other = (\n    combined_latent_other.X.toarray()\n    if hasattr(combined_latent_other.X, \"toarray\")\n    else combined_latent_other.X\n)\n# combined_distances_other = cdist(combined_X_other, combined_X_other, metric=\"euclidean\")\ncombined_distances_other = None\nprint(f\"Distance matrix computation took {time() - current_time:.2f} seconds\")\n# %%\n# Get metrics functions once for reuse",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "combined_distances_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "combined_distances_other = None\nprint(f\"Distance matrix computation took {time() - current_time:.2f} seconds\")\n# %%\n# Get metrics functions once for reuse\nmetrics_funcs_two_modalities = {\n    \"combined_latent_silhouette_f1\": mtrc.compute_silhouette_f1,\n    \"cross_modality_cell_type_accuracy\": mtrc.matching_accuracy,\n    \"cross_modality_cn_accuracy\": mtrc.cross_modality_cn_accuracy,\n    \"f1_score\": mtrc.f1_score_calc,\n    \"cn_f1_score\": mtrc.f1_score_calc,",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "metrics_funcs_two_modalities",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "metrics_funcs_two_modalities = {\n    \"combined_latent_silhouette_f1\": mtrc.compute_silhouette_f1,\n    \"cross_modality_cell_type_accuracy\": mtrc.matching_accuracy,\n    \"cross_modality_cn_accuracy\": mtrc.cross_modality_cn_accuracy,\n    \"f1_score\": mtrc.f1_score_calc,\n    \"cn_f1_score\": mtrc.f1_score_calc,\n    # \"ari_score\": mtrc.ari_score_calc,\n}\nmetric_funcs_one_modality = {\n    \"cn_kbet_within_cell_types\": mtrc.kbet_within_cell_types,",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "metric_funcs_one_modality",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "metric_funcs_one_modality = {\n    \"cn_kbet_within_cell_types\": mtrc.kbet_within_cell_types,\n    \"calculate_cell_type_silhouette\": mtrc.calculate_cell_type_silhouette,\n    \"morans_i\": mtrc.morans_i,\n}\nmetric_funcs_combined_modalities = {\n    \"ari_f1\": mtrc.compute_ari_f1,\n    \"cn_ilisi_within_cell_types\": mtrc.calculate_cn_ilisi_within_cell_types,\n    \"silhouette_score\": mtrc.silhouette_score_calc,\n    \"calculate_iLISI\": mtrc.calculate_iLISI,",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "metric_funcs_combined_modalities",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "metric_funcs_combined_modalities = {\n    \"ari_f1\": mtrc.compute_ari_f1,\n    \"cn_ilisi_within_cell_types\": mtrc.calculate_cn_ilisi_within_cell_types,\n    \"silhouette_score\": mtrc.silhouette_score_calc,\n    \"calculate_iLISI\": mtrc.calculate_iLISI,\n    \"cn_kbet_within_cell_types\": mtrc.kbet_within_cell_types,\n    \"modality_kbet_mixing_score\": mtrc.modality_kbet_mixing_score,\n    \"pair_distance\": mtrc.pair_distance,\n    \"mixing_metric\": mtrc.mixing_metric,\n    \"morans_i\": mtrc.morans_i,  # Moran's I on combined data",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "metrics_kwargs",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "metrics_kwargs = {\n    \"cn_kbet_within_cell_types\": {\"label_key\": \"CN\", \"group_key\": \"cell_types\", \"rep_key\": \"X\"},\n    \"modality_kbet_mixing_score\": {\"label_key\": \"modality\", \"group_key\": None, \"rep_key\": \"X\"},\n    \"calculate_cell_type_silhouette\": {\"celltype_key\": \"cell_types\", \"use_rep\": \"X\"},\n    \"calculate_iLISI\": {\"batch_key\": \"modality\", \"plot_flag\": plot_flag},\n    \"cn_f1_score\": {\"label_key\": \"CN\"},\n    \"cross_modality_cn_accuracy\": {\"k\": 3, \"global_step\": 0 if plot_flag else None},\n    \"morans_i\": {\"score_key\": \"matched_archetype_weight\", \"use_rep\": \"X\", \"n_neighbors\": 15},\n    \"pair_distance\": {\n        \"modality_key\": \"modality\",",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "metrics_dir",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "metrics_dir = PROJECT_ROOT / \"metrics\"\nmetrics_dir.mkdir(exist_ok=True)\n# Helper function to save confusion matrices\ndef save_confusion_matrix_csv(true_labels, predicted_labels, save_path, normalize='columns'):\n    \"\"\"Save confusion matrix as percentage CSV compatible with generate_publication_figures_github.py.\"\"\"\n    cm = pd.crosstab(\n        true_labels.values,\n        predicted_labels.values,\n        rownames=[\"True\"],\n        colnames=[\"Predicted\"],",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_df_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_df_arcadia = calculate_single_model_metrics(\n    adata_latent_arcadia_rna,\n    adata_latent_arcadia_prot,\n    combined_latent_arcadia,\n    model_name=\"arcadia\",\n    combined_distances=combined_distances_arcadia,\n    cross_modal_distances=cross_modal_distances_arcadia,\n    metrics_funcs_two_modalities=metrics_funcs_two_modalities,\n    metric_funcs_one_modality=metric_funcs_one_modality,\n    metric_funcs_combined_modalities=metric_funcs_combined_modalities,",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_df_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_df_other = pd.DataFrame({})\nresults_df_other = calculate_single_model_metrics(\n    adata_latent_other_rna,\n    adata_latent_other_prot,\n    combined_latent_other,\n    model_name=other_model_name,\n    combined_distances=combined_distances_other,\n    cross_modal_distances=cross_modal_distances_other,\n    metrics_funcs_two_modalities=metrics_funcs_two_modalities,\n    metric_funcs_one_modality=metric_funcs_one_modality,",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_df_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_df_other = calculate_single_model_metrics(\n    adata_latent_other_rna,\n    adata_latent_other_prot,\n    combined_latent_other,\n    model_name=other_model_name,\n    combined_distances=combined_distances_other,\n    cross_modal_distances=cross_modal_distances_other,\n    metrics_funcs_two_modalities=metrics_funcs_two_modalities,\n    metric_funcs_one_modality=metric_funcs_one_modality,\n    metric_funcs_combined_modalities=metric_funcs_combined_modalities,",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_pivot",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_pivot = merge_model_results(\n    results_df_arcadia, results_df_other, other_model_name=other_model_name\n)\n# Add metadata columns\nresults_pivot[\"timestamp\"] = timestamp_str\nif args.experiment_id:\n    results_pivot[\"experiment_id\"] = args.experiment_id\nif args.run_id:\n    results_pivot[\"run_id\"] = args.run_id\nresults_pivot[\"dataset_name\"] = dataset_name",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_pivot[\"timestamp\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_pivot[\"timestamp\"] = timestamp_str\nif args.experiment_id:\n    results_pivot[\"experiment_id\"] = args.experiment_id\nif args.run_id:\n    results_pivot[\"run_id\"] = args.run_id\nresults_pivot[\"dataset_name\"] = dataset_name\nresults_pivot[\"other_model_name\"] = other_model_name\nresults_pivot[\"checkpoint_path\"] = str(checkpoint_path)\nresults_pivot[\"n_rna_cells\"] = adata_latent_arcadia_rna.n_obs\nresults_pivot[\"n_protein_cells\"] = adata_latent_arcadia_prot.n_obs",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_pivot[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_pivot[\"dataset_name\"] = dataset_name\nresults_pivot[\"other_model_name\"] = other_model_name\nresults_pivot[\"checkpoint_path\"] = str(checkpoint_path)\nresults_pivot[\"n_rna_cells\"] = adata_latent_arcadia_rna.n_obs\nresults_pivot[\"n_protein_cells\"] = adata_latent_arcadia_prot.n_obs\n# Reorder columns to put metadata first\ncols = [\n    \"timestamp\",\n    \"experiment_id\",\n    \"run_id\",",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_pivot[\"other_model_name\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_pivot[\"other_model_name\"] = other_model_name\nresults_pivot[\"checkpoint_path\"] = str(checkpoint_path)\nresults_pivot[\"n_rna_cells\"] = adata_latent_arcadia_rna.n_obs\nresults_pivot[\"n_protein_cells\"] = adata_latent_arcadia_prot.n_obs\n# Reorder columns to put metadata first\ncols = [\n    \"timestamp\",\n    \"experiment_id\",\n    \"run_id\",\n    \"dataset_name\",",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_pivot[\"checkpoint_path\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_pivot[\"checkpoint_path\"] = str(checkpoint_path)\nresults_pivot[\"n_rna_cells\"] = adata_latent_arcadia_rna.n_obs\nresults_pivot[\"n_protein_cells\"] = adata_latent_arcadia_prot.n_obs\n# Reorder columns to put metadata first\ncols = [\n    \"timestamp\",\n    \"experiment_id\",\n    \"run_id\",\n    \"dataset_name\",\n    \"other_model_name\",",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_pivot[\"n_rna_cells\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_pivot[\"n_rna_cells\"] = adata_latent_arcadia_rna.n_obs\nresults_pivot[\"n_protein_cells\"] = adata_latent_arcadia_prot.n_obs\n# Reorder columns to put metadata first\ncols = [\n    \"timestamp\",\n    \"experiment_id\",\n    \"run_id\",\n    \"dataset_name\",\n    \"other_model_name\",\n    \"checkpoint_path\",",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_pivot[\"n_protein_cells\"]",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_pivot[\"n_protein_cells\"] = adata_latent_arcadia_prot.n_obs\n# Reorder columns to put metadata first\ncols = [\n    \"timestamp\",\n    \"experiment_id\",\n    \"run_id\",\n    \"dataset_name\",\n    \"other_model_name\",\n    \"checkpoint_path\",\n    \"n_rna_cells\",",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "cols",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "cols = [\n    \"timestamp\",\n    \"experiment_id\",\n    \"run_id\",\n    \"dataset_name\",\n    \"other_model_name\",\n    \"checkpoint_path\",\n    \"n_rna_cells\",\n    \"n_protein_cells\",\n    \"metric_name\",",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "cols",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "cols = [c for c in cols if c in results_pivot.columns]\nresults_pivot = results_pivot[cols]\n# Save results (without timestamp so results accumulate in same file)\noutput_file = metrics_dir / f\"results_comparison_{dataset_name}_{other_model_name}.csv\"\nsave_comparison_results(results_pivot, output_file=str(output_file))\nprint(\"\\n\" + \"=\" * 80)\nprint(\"RESULTS COMPARISON\")\nprint(\"=\" * 80)\nprint(results_pivot.to_string(index=False))\nprint(\"=\" * 80)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "results_pivot",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "results_pivot = results_pivot[cols]\n# Save results (without timestamp so results accumulate in same file)\noutput_file = metrics_dir / f\"results_comparison_{dataset_name}_{other_model_name}.csv\"\nsave_comparison_results(results_pivot, output_file=str(output_file))\nprint(\"\\n\" + \"=\" * 80)\nprint(\"RESULTS COMPARISON\")\nprint(\"=\" * 80)\nprint(results_pivot.to_string(index=False))\nprint(\"=\" * 80)\n# %%",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "output_file",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "output_file = metrics_dir / f\"results_comparison_{dataset_name}_{other_model_name}.csv\"\nsave_comparison_results(results_pivot, output_file=str(output_file))\nprint(\"\\n\" + \"=\" * 80)\nprint(\"RESULTS COMPARISON\")\nprint(\"=\" * 80)\nprint(results_pivot.to_string(index=False))\nprint(\"=\" * 80)\n# %%\n# Compute and save confusion matrices for cell type matching\nprint(\"\\n\" + \"=\" * 80)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "confusion_matrices_dir",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "confusion_matrices_dir = PROJECT_ROOT / 'data' / 'confusion_matrices'\nconfusion_matrices_dir.mkdir(parents=True, exist_ok=True)\n# Import calc_dist for computing nearest neighbors\nfrom arcadia.training.metrics import calc_dist\n# For ARCADIA - compute predicted cell types\nnn_celltypes_arcadia = calc_dist(adata_latent_arcadia_rna, adata_latent_arcadia_prot, label_key=\"cell_types\")\ntrue_celltypes_arcadia = adata_latent_arcadia_rna.obs[\"cell_types\"]\nif dataset_name == \"tonsil\":\n    save_confusion_matrix_csv(\n        true_celltypes_arcadia, ",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "nn_celltypes_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "nn_celltypes_arcadia = calc_dist(adata_latent_arcadia_rna, adata_latent_arcadia_prot, label_key=\"cell_types\")\ntrue_celltypes_arcadia = adata_latent_arcadia_rna.obs[\"cell_types\"]\nif dataset_name == \"tonsil\":\n    save_confusion_matrix_csv(\n        true_celltypes_arcadia, \n        nn_celltypes_arcadia,\n        confusion_matrices_dir / 'tonsil_ct_matching_arcadia.csv'\n    )\nelif dataset_name == \"cite_seq\" or dataset_name == \"synthetic\":\n    save_confusion_matrix_csv(",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "true_celltypes_arcadia",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "true_celltypes_arcadia = adata_latent_arcadia_rna.obs[\"cell_types\"]\nif dataset_name == \"tonsil\":\n    save_confusion_matrix_csv(\n        true_celltypes_arcadia, \n        nn_celltypes_arcadia,\n        confusion_matrices_dir / 'tonsil_ct_matching_arcadia.csv'\n    )\nelif dataset_name == \"cite_seq\" or dataset_name == \"synthetic\":\n    save_confusion_matrix_csv(\n        true_celltypes_arcadia,",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "nn_celltypes_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "nn_celltypes_other = calc_dist(adata_latent_other_rna, adata_latent_other_prot, label_key=\"cell_types\")\ntrue_celltypes_other = adata_latent_other_rna.obs[\"cell_types\"]\nif dataset_name == \"tonsil\":\n    save_confusion_matrix_csv(\n        true_celltypes_other,\n        nn_celltypes_other,\n        confusion_matrices_dir / f'tonsil_ct_matching_{other_model_name}.csv'\n    )\nelif dataset_name == \"cite_seq\" or dataset_name == \"synthetic\":\n    save_confusion_matrix_csv(",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "true_celltypes_other",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "true_celltypes_other = adata_latent_other_rna.obs[\"cell_types\"]\nif dataset_name == \"tonsil\":\n    save_confusion_matrix_csv(\n        true_celltypes_other,\n        nn_celltypes_other,\n        confusion_matrices_dir / f'tonsil_ct_matching_{other_model_name}.csv'\n    )\nelif dataset_name == \"cite_seq\" or dataset_name == \"synthetic\":\n    save_confusion_matrix_csv(\n        true_celltypes_other,",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "data_dir",
        "kind": 5,
        "importPath": "model_comparison.compare_results",
        "description": "model_comparison.compare_results",
        "peekOfCode": "data_dir = PROJECT_ROOT / 'data'\ndata_dir.mkdir(exist_ok=True)\n# For ARCADIA - get UMAP coordinates from combined latent\n# Check if UMAP already exists, otherwise compute it\nif 'X_umap' in combined_latent_arcadia.obsm:\n    umap_coords_arcadia = combined_latent_arcadia.obsm['X_umap']\nelif 'umap' in combined_latent_arcadia.obsm:\n    umap_coords_arcadia = combined_latent_arcadia.obsm['umap']\nelse:\n    # Compute UMAP if not already computed (neighbors should already exist from line 316)",
        "detail": "model_comparison.compare_results",
        "documentation": {}
    },
    {
        "label": "here",
        "kind": 2,
        "importPath": "model_comparison.comparison_utils",
        "description": "model_comparison.comparison_utils",
        "peekOfCode": "def here():\n    \"\"\"Get the directory containing this script or current working directory.\"\"\"\n    try:\n        if os.getcwd() == \"/workspace\":\n            return Path(\"/workspace\")\n        return Path(__file__).resolve().parent\n    except NameError:\n        return Path.cwd()\ndef _get_latest_from_numbered_files(folder, files, index_from_end=0, exact_step=None):\n    \"\"\"Helper function to get latest file from numbered files (e.g., 0_rna_2025-01-01-12-00-00.h5ad, 1_rna.h5ad).\"\"\"",
        "detail": "model_comparison.comparison_utils",
        "documentation": {}
    },
    {
        "label": "get_latest_file",
        "kind": 2,
        "importPath": "model_comparison.comparison_utils",
        "description": "model_comparison.comparison_utils",
        "peekOfCode": "def get_latest_file(\n    folder, prefix, index_from_end=0, dataset_name=None, exact_step=None\n) -> Optional[str]:\n    \"\"\"\n    Get the latest file with given prefix from folder.\n    With new naming convention (e.g., 0_rna_2025-01-01-12-00-00.h5ad), finds files from exact step.\n    Args:\n        folder: Base folder to search in\n        prefix: File prefix to match (e.g., \"rna\", \"protein\")\n        index_from_end: Index from end of sorted files (0 = latest/highest number)",
        "detail": "model_comparison.comparison_utils",
        "documentation": {}
    },
    {
        "label": "plt.rcParams[\"figure.figsize\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "plt.rcParams[\"figure.figsize\"] = (6, 4)\nif here().parent.name == \"notebooks\":\n    os.chdir(\"../../\")\nROOT = here().parent\nTHIS_DIR = here()\nprint(f\"ROOT: {ROOT}\")\nprint(f\"THIS_DIR: {THIS_DIR}\")\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "ROOT = here().parent\nTHIS_DIR = here()\nprint(f\"ROOT: {ROOT}\")\nprint(f\"THIS_DIR: {THIS_DIR}\")\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nos.chdir(str(ROOT))\nprint(f\"Working directory: {os.getcwd()}\")\n# %% [markdown]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "THIS_DIR = here()\nprint(f\"ROOT: {ROOT}\")\nprint(f\"THIS_DIR: {THIS_DIR}\")\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nos.chdir(str(ROOT))\nprint(f\"Working directory: {os.getcwd()}\")\n# %% [markdown]\n# ## Data acquire",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "dataset_name = \"cite_seq\"\nprint(\"Loading CITE-seq spleen lymph node data from h5ad files...\")\nrna_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"rna\", exact_step=1, dataset_name=dataset_name\n)\nprotein_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"protein\", exact_step=1, dataset_name=dataset_name\n)\nrna_adata = sc.read(str(rna_file))\nprotein_adata = sc.read(str(protein_file))",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_file",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"rna\", exact_step=1, dataset_name=dataset_name\n)\nprotein_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"protein\", exact_step=1, dataset_name=dataset_name\n)\nrna_adata = sc.read(str(rna_file))\nprotein_adata = sc.read(str(protein_file))\n# %% [markdown]\n# **Optional**: meta data for the cells. In this case we are using them to **evaluate the integration results**, but for actual running, MaxFuse does not require you have this information.",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_file",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"protein\", exact_step=1, dataset_name=dataset_name\n)\nrna_adata = sc.read(str(rna_file))\nprotein_adata = sc.read(str(protein_file))\n# %% [markdown]\n# **Optional**: meta data for the cells. In this case we are using them to **evaluate the integration results**, but for actual running, MaxFuse does not require you have this information.\n# %%\n# Cell type labels are already in the obs from preprocessed data\n# For compatibility with maxfuse tutorial, create celltype.l1 and celltype.l2",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata = sc.read(str(rna_file))\nprotein_adata = sc.read(str(protein_file))\n# %% [markdown]\n# **Optional**: meta data for the cells. In this case we are using them to **evaluate the integration results**, but for actual running, MaxFuse does not require you have this information.\n# %%\n# Cell type labels are already in the obs from preprocessed data\n# For compatibility with maxfuse tutorial, create celltype.l1 and celltype.l2\n# Use cell_types as the main label (l1), and minor_cell_types as l2\nrna_adata.obs[\"celltype.l1\"] = rna_adata.obs[\"cell_types\"]\nrna_adata.obs[\"celltype.l2\"] = rna_adata.obs[\"minor_cell_types\"]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata = sc.read(str(protein_file))\n# %% [markdown]\n# **Optional**: meta data for the cells. In this case we are using them to **evaluate the integration results**, but for actual running, MaxFuse does not require you have this information.\n# %%\n# Cell type labels are already in the obs from preprocessed data\n# For compatibility with maxfuse tutorial, create celltype.l1 and celltype.l2\n# Use cell_types as the main label (l1), and minor_cell_types as l2\nrna_adata.obs[\"celltype.l1\"] = rna_adata.obs[\"cell_types\"]\nrna_adata.obs[\"celltype.l2\"] = rna_adata.obs[\"minor_cell_types\"]\nprotein_adata.obs[\"celltype.l1\"] = protein_adata.obs[\"cell_types\"]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"celltype.l1\"] = rna_adata.obs[\"cell_types\"]\nrna_adata.obs[\"celltype.l2\"] = rna_adata.obs[\"minor_cell_types\"]\nprotein_adata.obs[\"celltype.l1\"] = protein_adata.obs[\"cell_types\"]\nprotein_adata.obs[\"celltype.l2\"] = protein_adata.obs[\"minor_cell_types\"]\n# Extract labels for evaluation\nlabels_l1_rna = rna_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = rna_adata.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {rna_adata.shape[0]} cells\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"celltype.l2\"] = rna_adata.obs[\"minor_cell_types\"]\nprotein_adata.obs[\"celltype.l1\"] = protein_adata.obs[\"cell_types\"]\nprotein_adata.obs[\"celltype.l2\"] = protein_adata.obs[\"minor_cell_types\"]\n# Extract labels for evaluation\nlabels_l1_rna = rna_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = rna_adata.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Protein dataset: {protein_adata.shape[0]} cells\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"celltype.l1\"] = protein_adata.obs[\"cell_types\"]\nprotein_adata.obs[\"celltype.l2\"] = protein_adata.obs[\"minor_cell_types\"]\n# Extract labels for evaluation\nlabels_l1_rna = rna_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = rna_adata.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(rna_adata.obs.index[:5])}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"celltype.l2\"] = protein_adata.obs[\"minor_cell_types\"]\n# Extract labels for evaluation\nlabels_l1_rna = rna_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = rna_adata.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(protein_adata.obs.index[:5])}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "labels_l1_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "labels_l1_rna = rna_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = rna_adata.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(protein_adata.obs.index[:5])}\")\nprint(f\"RNA cell types: {sorted(set(labels_l1_rna))}\")\nprint(f\"Protein cell types: {sorted(set(labels_l1_prot))}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "labels_l2_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "labels_l2_rna = rna_adata.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(protein_adata.obs.index[:5])}\")\nprint(f\"RNA cell types: {sorted(set(labels_l1_rna))}\")\nprint(f\"Protein cell types: {sorted(set(labels_l1_prot))}\")\n# %% [markdown]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "labels_l1_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "labels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(protein_adata.obs.index[:5])}\")\nprint(f\"RNA cell types: {sorted(set(labels_l1_rna))}\")\nprint(f\"Protein cell types: {sorted(set(labels_l1_prot))}\")\n# %% [markdown]\n# Here we are integrating protein and RNA data, and most of the time there are name differences between protein (antibody) and their corresponding gene names.",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "labels_l2_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "labels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(protein_adata.obs.index[:5])}\")\nprint(f\"RNA cell types: {sorted(set(labels_l1_rna))}\")\nprint(f\"Protein cell types: {sorted(set(labels_l1_prot))}\")\n# %% [markdown]\n# Here we are integrating protein and RNA data, and most of the time there are name differences between protein (antibody) and their corresponding gene names.\n#",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "data_dir",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "data_dir = \"ARCADIA/raw_datasets\"\ncorrespondence = pd.read_csv(f\"{data_dir}/tonsil/protein_gene_conversion.csv\")\ncorrespondence.head()\n# %% [markdown]\n# But of course this files does contain all names including custom names in new assays. If a certain correspondence is not found, either it is missing in the other modality, or you should customly add the name conversion to this ```.csv``` file.\n# %%\n# Check protein variable names format\nprint(f\"Sample protein var names: {list(protein_adata.var_names[:10])}\")\nprint(f\"Sample RNA var names: {list(rna_adata.var_names[:10])}\")\n# Create a mapping from clean protein names to actual var_names",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "correspondence = pd.read_csv(f\"{data_dir}/tonsil/protein_gene_conversion.csv\")\ncorrespondence.head()\n# %% [markdown]\n# But of course this files does contain all names including custom names in new assays. If a certain correspondence is not found, either it is missing in the other modality, or you should customly add the name conversion to this ```.csv``` file.\n# %%\n# Check protein variable names format\nprint(f\"Sample protein var names: {list(protein_adata.var_names[:10])}\")\nprint(f\"Sample RNA var names: {list(rna_adata.var_names[:10])}\")\n# Create a mapping from clean protein names to actual var_names\n# Protein names are in format 'ADT_CD102_A0104', we need to extract 'CD102'",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_name_mapping",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_name_mapping = {}\nfor var_name in protein_adata.var_names:\n    if var_name.startswith(\"ADT_\"):\n        # Extract the middle part (e.g., 'CD102' from 'ADT_CD102_A0104')\n        parts = var_name.split(\"_\")\n        if len(parts) >= 2:\n            clean_name = parts[1].split(\"(\")[0]  # Handle cases like 'CD115(CSF-1R)'\n            protein_name_mapping[clean_name] = var_name\nprint(f\"Created mapping for {len(protein_name_mapping)} proteins\")\nprint(f\"Sample mappings: {list(protein_name_mapping.items())[:5]}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_protein_correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_protein_correspondence = []\n# Create a case-insensitive mapping for RNA gene names (human uppercase -> mouse titlecase)\nrna_gene_mapping = {gene.upper(): gene for gene in rna_adata.var_names}\nfor i in range(correspondence.shape[0]):\n    curr_protein_name, curr_rna_names = correspondence.iloc[i]\n    # Try to find the protein in our mapping\n    actual_protein_name = protein_name_mapping.get(curr_protein_name)\n    if actual_protein_name is None:\n        continue\n    if (",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_gene_mapping",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_gene_mapping = {gene.upper(): gene for gene in rna_adata.var_names}\nfor i in range(correspondence.shape[0]):\n    curr_protein_name, curr_rna_names = correspondence.iloc[i]\n    # Try to find the protein in our mapping\n    actual_protein_name = protein_name_mapping.get(curr_protein_name)\n    if actual_protein_name is None:\n        continue\n    if (\n        curr_rna_names.find(\"Ignore\") != -1\n    ):  # some correspondence ignored eg. protein isoform to one gene",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_protein_correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_protein_correspondence = np.array(rna_protein_correspondence)\nprint(f\"Found {len(rna_protein_correspondence)} RNA-protein correspondences\")\n# %%\n# Find common cells between RNA and protein datasets\ncommon_cells = rna_adata.obs.index.intersection(protein_adata.obs.index)\nprint(f\"Common cells between RNA and protein: {len(common_cells)}\")\nprint(f\"RNA unique cells: {len(rna_adata.obs.index) - len(common_cells)}\")\nprint(f\"Protein unique cells: {len(protein_adata.obs.index) - len(common_cells)}\")\n# Subset both datasets to common cells\nrna_adata = rna_adata[common_cells].copy()",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "common_cells",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "common_cells = rna_adata.obs.index.intersection(protein_adata.obs.index)\nprint(f\"Common cells between RNA and protein: {len(common_cells)}\")\nprint(f\"RNA unique cells: {len(rna_adata.obs.index) - len(common_cells)}\")\nprint(f\"Protein unique cells: {len(protein_adata.obs.index) - len(common_cells)}\")\n# Subset both datasets to common cells\nrna_adata = rna_adata[common_cells].copy()\nprotein_adata = protein_adata[common_cells].copy()\nprint(f\"After filtering to common cells:\")\nprint(f\"RNA dataset: {rna_adata.shape}\")\nprint(f\"Protein dataset: {protein_adata.shape}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata = rna_adata[common_cells].copy()\nprotein_adata = protein_adata[common_cells].copy()\nprint(f\"After filtering to common cells:\")\nprint(f\"RNA dataset: {rna_adata.shape}\")\nprint(f\"Protein dataset: {protein_adata.shape}\")\n# Now subsample if needed (using the same indices for both)\nnum_cells = 300000000\nmax_cells = min(num_cells, len(common_cells))\nif len(common_cells) > max_cells:\n    np.random.seed(42)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata = protein_adata[common_cells].copy()\nprint(f\"After filtering to common cells:\")\nprint(f\"RNA dataset: {rna_adata.shape}\")\nprint(f\"Protein dataset: {protein_adata.shape}\")\n# Now subsample if needed (using the same indices for both)\nnum_cells = 300000000\nmax_cells = min(num_cells, len(common_cells))\nif len(common_cells) > max_cells:\n    np.random.seed(42)\n    subsample_indices = np.random.choice(len(common_cells), max_cells, replace=False)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "num_cells",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "num_cells = 300000000\nmax_cells = min(num_cells, len(common_cells))\nif len(common_cells) > max_cells:\n    np.random.seed(42)\n    subsample_indices = np.random.choice(len(common_cells), max_cells, replace=False)\n    subsample_cells = common_cells[subsample_indices]\n    rna_adata = rna_adata[subsample_cells].copy()\n    protein_adata = protein_adata[subsample_cells].copy()\n    print(f\"Subsampled to {max_cells} cells\")\n# Update labels after subsampling (extract from the subsampled obs)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "max_cells",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "max_cells = min(num_cells, len(common_cells))\nif len(common_cells) > max_cells:\n    np.random.seed(42)\n    subsample_indices = np.random.choice(len(common_cells), max_cells, replace=False)\n    subsample_cells = common_cells[subsample_indices]\n    rna_adata = rna_adata[subsample_cells].copy()\n    protein_adata = protein_adata[subsample_cells].copy()\n    print(f\"Subsampled to {max_cells} cells\")\n# Update labels after subsampling (extract from the subsampled obs)\nlabels_l1_rna = rna_adata.obs[\"celltype.l1\"].to_numpy()",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "labels_l1_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "labels_l1_rna = rna_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = rna_adata.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\n# Verify that RNA and protein datasets now have matching cells\nprint(f\"Final RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Final Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA index sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein index sample: {list(protein_adata.obs.index[:5])}\")\nprint(f\"Indices match: {all(rna_adata.obs.index == protein_adata.obs.index)}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "labels_l2_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "labels_l2_rna = rna_adata.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\n# Verify that RNA and protein datasets now have matching cells\nprint(f\"Final RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Final Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA index sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein index sample: {list(protein_adata.obs.index[:5])}\")\nprint(f\"Indices match: {all(rna_adata.obs.index == protein_adata.obs.index)}\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "labels_l1_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "labels_l1_prot = protein_adata.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\n# Verify that RNA and protein datasets now have matching cells\nprint(f\"Final RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Final Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA index sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein index sample: {list(protein_adata.obs.index[:5])}\")\nprint(f\"Indices match: {all(rna_adata.obs.index == protein_adata.obs.index)}\")\n# %%\n# Columns rna_shared and protein_shared are matched.",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "labels_l2_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "labels_l2_prot = protein_adata.obs[\"celltype.l2\"].to_numpy()\n# Verify that RNA and protein datasets now have matching cells\nprint(f\"Final RNA dataset: {rna_adata.shape[0]} cells\")\nprint(f\"Final Protein dataset: {protein_adata.shape[0]} cells\")\nprint(f\"RNA index sample: {list(rna_adata.obs.index[:5])}\")\nprint(f\"Protein index sample: {list(protein_adata.obs.index[:5])}\")\nprint(f\"Indices match: {all(rna_adata.obs.index == protein_adata.obs.index)}\")\n# %%\n# Columns rna_shared and protein_shared are matched.\n# One may encounter \"Variable names are not unique\" warning,",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_shared = rna_adata[:, rna_protein_correspondence[:, 0]].copy()\nprotein_shared = protein_adata[:, rna_protein_correspondence[:, 1]].copy()\n# Use raw counts from layers for maxfuse (it will do its own normalization)\nif \"counts\" in rna_shared.layers:\n    rna_shared.X = rna_shared.layers[\"counts\"].copy()\n    print(\"Using raw counts from rna_shared.layers['counts']\")\nif \"counts\" in protein_shared.layers:\n    protein_shared.X = protein_shared.layers[\"counts\"].copy()\n    print(\"Using raw counts from protein_shared.layers['counts']\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_shared = protein_adata[:, rna_protein_correspondence[:, 1]].copy()\n# Use raw counts from layers for maxfuse (it will do its own normalization)\nif \"counts\" in rna_shared.layers:\n    rna_shared.X = rna_shared.layers[\"counts\"].copy()\n    print(\"Using raw counts from rna_shared.layers['counts']\")\nif \"counts\" in protein_shared.layers:\n    protein_shared.X = protein_shared.layers[\"counts\"].copy()\n    print(\"Using raw counts from protein_shared.layers['counts']\")\n# %%\n# Make sure no column is static",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_X",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_X = rna_shared.X.toarray() if issparse(rna_shared.X) else rna_shared.X\nprotein_X = protein_shared.X.toarray() if issparse(protein_shared.X) else protein_shared.X\nmask = (rna_X.std(axis=0) > 1e-5) & (protein_X.std(axis=0) > 1e-5)\nrna_shared = rna_shared[:, mask].copy()\nprotein_shared = protein_shared[:, mask].copy()\n# %% [markdown]\n# We apply standard Scanpy preprocessing steps to `rna_shared` and `protein_shared`.\n# One modification we do is that we normalize the rows of the two arrays to be a common `target_sum`.\n# If the input data is already pre-processed (normalized etc), we suggest skipping the standardized processing steps below.\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_X",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_X = protein_shared.X.toarray() if issparse(protein_shared.X) else protein_shared.X\nmask = (rna_X.std(axis=0) > 1e-5) & (protein_X.std(axis=0) > 1e-5)\nrna_shared = rna_shared[:, mask].copy()\nprotein_shared = protein_shared[:, mask].copy()\n# %% [markdown]\n# We apply standard Scanpy preprocessing steps to `rna_shared` and `protein_shared`.\n# One modification we do is that we normalize the rows of the two arrays to be a common `target_sum`.\n# If the input data is already pre-processed (normalized etc), we suggest skipping the standardized processing steps below.\n# %%\n# row sum for RNA",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "mask",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "mask = (rna_X.std(axis=0) > 1e-5) & (protein_X.std(axis=0) > 1e-5)\nrna_shared = rna_shared[:, mask].copy()\nprotein_shared = protein_shared[:, mask].copy()\n# %% [markdown]\n# We apply standard Scanpy preprocessing steps to `rna_shared` and `protein_shared`.\n# One modification we do is that we normalize the rows of the two arrays to be a common `target_sum`.\n# If the input data is already pre-processed (normalized etc), we suggest skipping the standardized processing steps below.\n# %%\n# row sum for RNA\nrna_X_for_sum = rna_shared.X.toarray() if issparse(rna_shared.X) else rna_shared.X",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_shared = rna_shared[:, mask].copy()\nprotein_shared = protein_shared[:, mask].copy()\n# %% [markdown]\n# We apply standard Scanpy preprocessing steps to `rna_shared` and `protein_shared`.\n# One modification we do is that we normalize the rows of the two arrays to be a common `target_sum`.\n# If the input data is already pre-processed (normalized etc), we suggest skipping the standardized processing steps below.\n# %%\n# row sum for RNA\nrna_X_for_sum = rna_shared.X.toarray() if issparse(rna_shared.X) else rna_shared.X\nrna_counts = rna_X_for_sum.sum(axis=1)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_shared = protein_shared[:, mask].copy()\n# %% [markdown]\n# We apply standard Scanpy preprocessing steps to `rna_shared` and `protein_shared`.\n# One modification we do is that we normalize the rows of the two arrays to be a common `target_sum`.\n# If the input data is already pre-processed (normalized etc), we suggest skipping the standardized processing steps below.\n# %%\n# row sum for RNA\nrna_X_for_sum = rna_shared.X.toarray() if issparse(rna_shared.X) else rna_shared.X\nrna_counts = rna_X_for_sum.sum(axis=1)\n# row sum for protein",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_X_for_sum",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_X_for_sum = rna_shared.X.toarray() if issparse(rna_shared.X) else rna_shared.X\nrna_counts = rna_X_for_sum.sum(axis=1)\n# row sum for protein\nprotein_X_for_sum = protein_shared.X.toarray() if issparse(protein_shared.X) else protein_shared.X\nprotein_counts = protein_X_for_sum.sum(axis=1)\n# take median of each and then take mean\ntarget_sum = (np.median(rna_counts.copy()) + np.median(protein_counts.copy())) / 2\n# %%\n# process rna_shared\nsc.pp.normalize_total(rna_shared, target_sum=target_sum)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_counts",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_counts = rna_X_for_sum.sum(axis=1)\n# row sum for protein\nprotein_X_for_sum = protein_shared.X.toarray() if issparse(protein_shared.X) else protein_shared.X\nprotein_counts = protein_X_for_sum.sum(axis=1)\n# take median of each and then take mean\ntarget_sum = (np.median(rna_counts.copy()) + np.median(protein_counts.copy())) / 2\n# %%\n# process rna_shared\nsc.pp.normalize_total(rna_shared, target_sum=target_sum)\nsc.pp.log1p(rna_shared)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_X_for_sum",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_X_for_sum = protein_shared.X.toarray() if issparse(protein_shared.X) else protein_shared.X\nprotein_counts = protein_X_for_sum.sum(axis=1)\n# take median of each and then take mean\ntarget_sum = (np.median(rna_counts.copy()) + np.median(protein_counts.copy())) / 2\n# %%\n# process rna_shared\nsc.pp.normalize_total(rna_shared, target_sum=target_sum)\nsc.pp.log1p(rna_shared)\nsc.pp.scale(rna_shared)\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_counts",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_counts = protein_X_for_sum.sum(axis=1)\n# take median of each and then take mean\ntarget_sum = (np.median(rna_counts.copy()) + np.median(protein_counts.copy())) / 2\n# %%\n# process rna_shared\nsc.pp.normalize_total(rna_shared, target_sum=target_sum)\nsc.pp.log1p(rna_shared)\nsc.pp.scale(rna_shared)\n# %%\n# plot UMAPs of rna cells based only on rna markers with protein correspondence",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "target_sum",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "target_sum = (np.median(rna_counts.copy()) + np.median(protein_counts.copy())) / 2\n# %%\n# process rna_shared\nsc.pp.normalize_total(rna_shared, target_sum=target_sum)\nsc.pp.log1p(rna_shared)\nsc.pp.scale(rna_shared)\n# %%\n# plot UMAPs of rna cells based only on rna markers with protein correspondence\nsc.pp.pca(rna_shared)\nsc.pp.neighbors(rna_shared, n_neighbors=15)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_shared = rna_shared.X.copy()\n# %%\n# process protein_shared\nsc.pp.normalize_total(protein_shared, target_sum=target_sum)\nsc.pp.log1p(protein_shared)\nsc.pp.scale(protein_shared)\n# Handle any NaN values that might have been introduced\nif np.isnan(protein_shared.X).any():\n    print(f\"Warning: Found NaN values in protein_shared after normalization, replacing with 0\")\n    protein_shared.X = np.nan_to_num(protein_shared.X, nan=0.0)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_shared = protein_shared.X.copy()\n# %% [markdown]\n# We again apply standard Scanpy preprocessing steps to **all available RNA measurements and protein measurements** (not just the shared ones) to get two arrays, `rna_active` and `protein_active`, which are used for iterative refinement. Again if the input data is already processed, these steps can be skipped.\n# %%\n# process all RNA features\n# Use raw counts for maxfuse processing\nif \"counts\" in rna_adata.layers:\n    rna_adata.X = rna_adata.layers[\"counts\"].copy()\n    print(\"Using raw counts from rna_adata.layers['counts']\")\nsc.pp.normalize_total(rna_adata)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata = rna_adata[:, rna_adata.var.highly_variable].copy()\nsc.pp.scale(rna_adata)\n# %%\n# plot UMAPs of rna cells based on all active rna markers\nsc.pp.neighbors(rna_adata, n_neighbors=15)\n# sc.tl.umap(rna_adata)\n# sc.pl.umap(rna_adata, color=['celltype.l1','celltype.l2'])\n# %%\n# process all protein features\n# Use raw counts for maxfuse processing",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_active",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_active = rna_adata.X\nprotein_active = protein_adata.X\nrna_active = rna_active[:, rna_active.std(axis=0) > 1e-5]\nprotein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\n# %%\n# inspect shape of the four matrices\nprint(rna_active.shape)\nprint(protein_active.shape)\nprint(rna_shared.shape)\nprint(protein_shared.shape)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_active",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_active = protein_adata.X\nrna_active = rna_active[:, rna_active.std(axis=0) > 1e-5]\nprotein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\n# %%\n# inspect shape of the four matrices\nprint(rna_active.shape)\nprint(protein_active.shape)\nprint(rna_shared.shape)\nprint(protein_shared.shape)\n# %% [markdown]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_active",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_active = rna_active[:, rna_active.std(axis=0) > 1e-5]\nprotein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\n# %%\n# inspect shape of the four matrices\nprint(rna_active.shape)\nprint(protein_active.shape)\nprint(rna_shared.shape)\nprint(protein_shared.shape)\n# %% [markdown]\n# ## Fitting MaxFuse",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_active",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\n# %%\n# inspect shape of the four matrices\nprint(rna_active.shape)\nprint(protein_active.shape)\nprint(rna_shared.shape)\nprint(protein_shared.shape)\n# %% [markdown]\n# ## Fitting MaxFuse\n# %% [markdown]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "fusor",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "fusor = mf.model.Fusor(\n    shared_arr1=rna_shared,\n    shared_arr2=protein_shared,\n    active_arr1=rna_active,\n    active_arr2=protein_active,\n    labels1=None,\n    labels2=None,\n)\n# %% [markdown]\n# To reduce computational complexity, we call `split_into_batches` to fit the batched version of MaxFuse.",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "pivot_matching",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "pivot_matching = fusor.get_matching(target=\"pivot\")\n# %%\n# We can inspect the first pivot pair.\n[pivot_matching[0][0], pivot_matching[1][0], pivot_matching[2][0]]\n# %% [markdown]\n# We now compute the cell type level accuracy to evaluate the performance. (This step is not required for actual MaxFuse running)\n# %%\nlv1_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l1_rna, labels2=labels_l1_rna\n)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "lv1_acc",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "lv1_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l1_rna, labels2=labels_l1_rna\n)\nlv2_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l2_rna, labels2=labels_l2_rna\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %% [markdown]\n# We can also compute the confusion matrix to see where the pivot matching goes wrong.\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "lv2_acc",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "lv2_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l2_rna, labels2=labels_l2_rna\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %% [markdown]\n# We can also compute the confusion matrix to see where the pivot matching goes wrong.\n# %%\ncm = confusion_matrix(labels_l1_rna[pivot_matching[0]], labels_l1_rna[pivot_matching[1]])\nConfusionMatrixDisplay(\n    confusion_matrix=np.round((cm.T / np.sum(cm, axis=1)).T * 100),",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cm",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cm = confusion_matrix(labels_l1_rna[pivot_matching[0]], labels_l1_rna[pivot_matching[1]])\nConfusionMatrixDisplay(\n    confusion_matrix=np.round((cm.T / np.sum(cm, axis=1)).T * 100),\n    display_labels=np.unique(labels_l1_rna),\n).plot()\n# %% [markdown]\n# As long as the refined pivots have been obtained, we can get joint embedding of the *full* datasets (active arrays).\n# %%\nrna_cca, protein_cca = fusor.get_embedding(\n    active_arr1=fusor.active_arr1, active_arr2=fusor.active_arr2",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "dim_use",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "dim_use = 15  # dimensions of the CCA embedding to be used for UMAP etc\nmf.metrics.get_foscttm(\n    dist=mf.utils.cdist_correlation(rna_cca[:, :dim_use], protein_cca[:, :dim_use]),\n    true_matching=\"identity\",\n)\n# %% [markdown]\n# We can also plot the UMAP visualizations of the joint embeddings and we can see that: (1) the two datasets mix well; and (2) the cell types are preseved.\n#\n# Empirically, we find *10-20* dimensions of the joint embeddings best represents the data, similar to choosing PCA components to plot UMAPs in the conventional pipelines.\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cca_adata",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cca_adata = ad.AnnData(\n    np.concatenate((rna_cca[:, :dim_use], protein_cca[:, :dim_use]), axis=0), dtype=np.float32\n)\ncca_adata.obs[\"data_type\"] = [\"rna\"] * rna_cca.shape[0] + [\"protein\"] * protein_cca.shape[0]\ncca_adata.obs[\"celltype.l1\"] = list(protein_adata.obs[\"celltype.l1\"]) * 2\ncca_adata.obs[\"celltype.l2\"] = list(protein_adata.obs[\"celltype.l2\"]) * 2\n# %%\ncca_adata.obs[\"celltype.l1\"]\n# %%\nsc.pp.neighbors(cca_adata, n_neighbors=15)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"data_type\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cca_adata.obs[\"data_type\"] = [\"rna\"] * rna_cca.shape[0] + [\"protein\"] * protein_cca.shape[0]\ncca_adata.obs[\"celltype.l1\"] = list(protein_adata.obs[\"celltype.l1\"]) * 2\ncca_adata.obs[\"celltype.l2\"] = list(protein_adata.obs[\"celltype.l2\"]) * 2\n# %%\ncca_adata.obs[\"celltype.l1\"]\n# %%\nsc.pp.neighbors(cca_adata, n_neighbors=15)\nsc.tl.umap(cca_adata)\nsc.pl.umap(cca_adata, color=\"data_type\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cca_adata.obs[\"celltype.l1\"] = list(protein_adata.obs[\"celltype.l1\"]) * 2\ncca_adata.obs[\"celltype.l2\"] = list(protein_adata.obs[\"celltype.l2\"]) * 2\n# %%\ncca_adata.obs[\"celltype.l1\"]\n# %%\nsc.pp.neighbors(cca_adata, n_neighbors=15)\nsc.tl.umap(cca_adata)\nsc.pl.umap(cca_adata, color=\"data_type\")\n# %%\nsc.pl.umap(cca_adata, color=[\"celltype.l1\", \"celltype.l2\"])",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cca_adata.obs[\"celltype.l2\"] = list(protein_adata.obs[\"celltype.l2\"]) * 2\n# %%\ncca_adata.obs[\"celltype.l1\"]\n# %%\nsc.pp.neighbors(cca_adata, n_neighbors=15)\nsc.tl.umap(cca_adata)\nsc.pl.umap(cca_adata, color=\"data_type\")\n# %%\nsc.pl.umap(cca_adata, color=[\"celltype.l1\", \"celltype.l2\"])\n# %% [markdown]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "full_matching",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "full_matching = fusor.get_matching(order=(2, 1), target=\"full_data\")\n# %% [markdown]\n# Since we are doing `order=(2, 1)` here, the matching info is all the cells (10k) in mod 2 (protein) has at least one match cell in the RNA modality. Note that the matched cell in RNA could be duplicated, as different protein cells could be matched to the same RNA cell. For a quick check on matching format:\n# %%\npd.DataFrame(\n    list(zip(full_matching[0], full_matching[1], full_matching[2])),\n    columns=[\"mod1_indx\", \"mod2_indx\", \"score\"],\n)\n# columns: cell idx in mod1, cell idx in mod2, and matching scores\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "lv1_acc",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "lv1_acc = mf.metrics.get_matching_acc(\n    matching=full_matching, labels1=labels_l1_rna, labels2=labels_l1_rna\n)\nlv2_acc = mf.metrics.get_matching_acc(\n    matching=full_matching, labels1=labels_l2_rna, labels2=labels_l2_rna\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %%\n# confusion matrix for full matching\ncm = confusion_matrix(labels_l1_rna[full_matching[0]], labels_l1_rna[full_matching[1]])",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "lv2_acc",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "lv2_acc = mf.metrics.get_matching_acc(\n    matching=full_matching, labels1=labels_l2_rna, labels2=labels_l2_rna\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %%\n# confusion matrix for full matching\ncm = confusion_matrix(labels_l1_rna[full_matching[0]], labels_l1_rna[full_matching[1]])\nConfusionMatrixDisplay(\n    confusion_matrix=np.round((cm.T / np.sum(cm, axis=1)).T * 100),\n    display_labels=np.unique(labels_l1_rna),",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cm",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cm = confusion_matrix(labels_l1_rna[full_matching[0]], labels_l1_rna[full_matching[1]])\nConfusionMatrixDisplay(\n    confusion_matrix=np.round((cm.T / np.sum(cm, axis=1)).T * 100),\n    display_labels=np.unique(labels_l1_rna),\n).plot()\n# %%\n# what is full matching?\ncca_adata.X\n# %%\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_1",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "adata_1 = ad.AnnData(rna_cca)\nadata_2 = ad.AnnData(protein_cca)\n# %%\nadata_1.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l1\"]\n# %%\nadata_2.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l2\"]\n# %%\n# %%\ncca_adata.obs[\"data_type\"]\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_2",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "adata_2 = ad.AnnData(protein_cca)\n# %%\nadata_1.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l1\"]\n# %%\nadata_2.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l2\"]\n# %%\n# %%\ncca_adata.obs[\"data_type\"]\n# %%\ncca_adata.obs[\"cell_types\"] = cca_adata.obs[\"celltype.l1\"]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_1.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "adata_1.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l1\"]\n# %%\nadata_2.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l2\"]\n# %%\n# %%\ncca_adata.obs[\"data_type\"]\n# %%\ncca_adata.obs[\"cell_types\"] = cca_adata.obs[\"celltype.l1\"]\ncca_adata.obs[\"modality\"] = cca_adata.obs[\"data_type\"]\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_2.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "adata_2.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l2\"]\n# %%\n# %%\ncca_adata.obs[\"data_type\"]\n# %%\ncca_adata.obs[\"cell_types\"] = cca_adata.obs[\"celltype.l1\"]\ncca_adata.obs[\"modality\"] = cca_adata.obs[\"data_type\"]\n# %%\n# %%\ncca_adata.obs[\"cell_types\"] = cca_adata.obs[\"celltype.l2\"]",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cca_adata.obs[\"cell_types\"] = cca_adata.obs[\"celltype.l1\"]\ncca_adata.obs[\"modality\"] = cca_adata.obs[\"data_type\"]\n# %%\n# %%\ncca_adata.obs[\"cell_types\"] = cca_adata.obs[\"celltype.l2\"]\ncca_adata.obs[\"modality\"] = cca_adata.obs[\"data_type\"]\n# %%\n# from scib.metrics import ilisi_graph, clisi_graph\n# # neighbors already computed with scanpy\n# sc.pp.neighbors(cca_adata, use_rep=\"X\", n_neighbors=30)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"modality\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cca_adata.obs[\"modality\"] = cca_adata.obs[\"data_type\"]\n# %%\n# %%\ncca_adata.obs[\"cell_types\"] = cca_adata.obs[\"celltype.l2\"]\ncca_adata.obs[\"modality\"] = cca_adata.obs[\"data_type\"]\n# %%\n# from scib.metrics import ilisi_graph, clisi_graph\n# # neighbors already computed with scanpy\n# sc.pp.neighbors(cca_adata, use_rep=\"X\", n_neighbors=30)\n# # compute iLISI (integration) -- requires 'batch_key'",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cca_adata.obs[\"cell_types\"] = cca_adata.obs[\"celltype.l2\"]\ncca_adata.obs[\"modality\"] = cca_adata.obs[\"data_type\"]\n# %%\n# from scib.metrics import ilisi_graph, clisi_graph\n# # neighbors already computed with scanpy\n# sc.pp.neighbors(cca_adata, use_rep=\"X\", n_neighbors=30)\n# # compute iLISI (integration) -- requires 'batch_key'\n# ilisi = ilisi_graph(\n#     cca_adata,\n#     batch_key=\"data_type\",",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"modality\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "cca_adata.obs[\"modality\"] = cca_adata.obs[\"data_type\"]\n# %%\n# from scib.metrics import ilisi_graph, clisi_graph\n# # neighbors already computed with scanpy\n# sc.pp.neighbors(cca_adata, use_rep=\"X\", n_neighbors=30)\n# # compute iLISI (integration) -- requires 'batch_key'\n# ilisi = ilisi_graph(\n#     cca_adata,\n#     batch_key=\"data_type\",\n#     type_=\"knn\"    # <-- required",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"batch_indices\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"batch_indices\"] = 0\nrna_adata.obs[\"n_genes\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"percent_mito\"] = 0  # not available in this data\nrna_adata.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata.obs[\"cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"tissue\"] = \"pbmc\"\nrna_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nrna_adata.obs[\"minor_cell_types\"] = rna_adata.obs[\"celltype.l2\"]\nrna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"n_genes\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"n_genes\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"percent_mito\"] = 0  # not available in this data\nrna_adata.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata.obs[\"cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"tissue\"] = \"pbmc\"\nrna_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nrna_adata.obs[\"minor_cell_types\"] = rna_adata.obs[\"celltype.l2\"]\nrna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"percent_mito\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"percent_mito\"] = 0  # not available in this data\nrna_adata.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata.obs[\"cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"tissue\"] = \"pbmc\"\nrna_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nrna_adata.obs[\"minor_cell_types\"] = rna_adata.obs[\"celltype.l2\"]\nrna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"leiden_subclusters\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata.obs[\"cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"tissue\"] = \"pbmc\"\nrna_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nrna_adata.obs[\"minor_cell_types\"] = rna_adata.obs[\"celltype.l2\"]\nrna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"tissue\"] = \"pbmc\"\nrna_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nrna_adata.obs[\"minor_cell_types\"] = rna_adata.obs[\"celltype.l2\"]\nrna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"tissue\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"tissue\"] = \"pbmc\"\nrna_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nrna_adata.obs[\"minor_cell_types\"] = rna_adata.obs[\"celltype.l2\"]\nrna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields\nrna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"batch\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nrna_adata.obs[\"minor_cell_types\"] = rna_adata.obs[\"celltype.l2\"]\nrna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields\nrna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)\nrna_adata.var[\"mt\"] = False",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"minor_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"minor_cell_types\"] = rna_adata.obs[\"celltype.l2\"]\nrna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields\nrna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)\nrna_adata.var[\"mt\"] = False\nrna_adata.var[\"ribo\"] = False",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"major_cell_types\"] = rna_adata.obs[\"celltype.l1\"]\nrna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields\nrna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)\nrna_adata.var[\"mt\"] = False\nrna_adata.var[\"ribo\"] = False\nrna_adata.var[\"hb\"] = False",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"total_counts\"] = np.array(rna_adata.X.sum(axis=1)).flatten()\nrna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields\nrna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)\nrna_adata.var[\"mt\"] = False\nrna_adata.var[\"ribo\"] = False\nrna_adata.var[\"hb\"] = False\nrna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"n_genes_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"n_genes_by_counts\"] = (rna_adata.X > 0).sum(axis=1)\nrna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields\nrna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)\nrna_adata.var[\"mt\"] = False\nrna_adata.var[\"ribo\"] = False\nrna_adata.var[\"hb\"] = False\nrna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()\nrna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"pct_counts_mt\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"pct_counts_mt\"] = 0\nrna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields\nrna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)\nrna_adata.var[\"mt\"] = False\nrna_adata.var[\"ribo\"] = False\nrna_adata.var[\"hb\"] = False\nrna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()\nrna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)\n# uns fields",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obs[\"index_col\"] = np.arange(rna_adata.n_obs)\n# var fields\nrna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)\nrna_adata.var[\"mt\"] = False\nrna_adata.var[\"ribo\"] = False\nrna_adata.var[\"hb\"] = False\nrna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()\nrna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)\n# uns fields\nrna_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.var[\"n_cells\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.var[\"n_cells\"] = (rna_adata.X > 0).sum(axis=0)\nrna_adata.var[\"mt\"] = False\nrna_adata.var[\"ribo\"] = False\nrna_adata.var[\"hb\"] = False\nrna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()\nrna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)\n# uns fields\nrna_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nrna_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nrna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.var[\"mt\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.var[\"mt\"] = False\nrna_adata.var[\"ribo\"] = False\nrna_adata.var[\"hb\"] = False\nrna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()\nrna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)\n# uns fields\nrna_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nrna_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nrna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.var[\"ribo\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.var[\"ribo\"] = False\nrna_adata.var[\"hb\"] = False\nrna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()\nrna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)\n# uns fields\nrna_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nrna_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nrna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nrna_adata.obsm.clear()",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.var[\"hb\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.var[\"hb\"] = False\nrna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()\nrna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)\n# uns fields\nrna_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nrna_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nrna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nrna_adata.obsm.clear()\nrna_adata.obsm[\"latent\"] = rna_cca_full",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.var[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.var[\"total_counts\"] = np.array(rna_adata.X.sum(axis=0)).flatten()\nrna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)\n# uns fields\nrna_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nrna_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nrna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nrna_adata.obsm.clear()\nrna_adata.obsm[\"latent\"] = rna_cca_full\n# layers",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.var[\"n_cells_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.var[\"n_cells_by_counts\"] = (rna_adata.X > 0).sum(axis=0)\n# uns fields\nrna_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nrna_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nrna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nrna_adata.obsm.clear()\nrna_adata.obsm[\"latent\"] = rna_cca_full\n# layers\nrna_adata.layers[\"counts\"] = rna_adata.X.copy()",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nrna_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nrna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nrna_adata.obsm.clear()\nrna_adata.obsm[\"latent\"] = rna_cca_full\n# layers\nrna_adata.layers[\"counts\"] = rna_adata.X.copy()\nprint(f\"rna_adata shape: {rna_adata.shape}\")\nprint(f\"rna_adata.obs columns: {list(rna_adata.obs.columns)}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.uns[\"processing_stage\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nrna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nrna_adata.obsm.clear()\nrna_adata.obsm[\"latent\"] = rna_cca_full\n# layers\nrna_adata.layers[\"counts\"] = rna_adata.X.copy()\nprint(f\"rna_adata shape: {rna_adata.shape}\")\nprint(f\"rna_adata.obs columns: {list(rna_adata.obs.columns)}\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.uns[\"file_generated_from\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nrna_adata.obsm.clear()\nrna_adata.obsm[\"latent\"] = rna_cca_full\n# layers\nrna_adata.layers[\"counts\"] = rna_adata.X.copy()\nprint(f\"rna_adata shape: {rna_adata.shape}\")\nprint(f\"rna_adata.obs columns: {list(rna_adata.obs.columns)}\")\n# %%\n# Prepare Protein AnnData object",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.obsm[\"latent\"] = rna_cca_full\n# layers\nrna_adata.layers[\"counts\"] = rna_adata.X.copy()\nprint(f\"rna_adata shape: {rna_adata.shape}\")\nprint(f\"rna_adata.obs columns: {list(rna_adata.obs.columns)}\")\n# %%\n# Prepare Protein AnnData object\nprotein_adata.obs[\"batch_indices\"] = 0\nprotein_adata.obs[\"percent_mito\"] = 0\nprotein_adata.obs[\"leiden_subclusters\"] = \"unknown\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata.layers[\"counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_adata.layers[\"counts\"] = rna_adata.X.copy()\nprint(f\"rna_adata shape: {rna_adata.shape}\")\nprint(f\"rna_adata.obs columns: {list(rna_adata.obs.columns)}\")\n# %%\n# Prepare Protein AnnData object\nprotein_adata.obs[\"batch_indices\"] = 0\nprotein_adata.obs[\"percent_mito\"] = 0\nprotein_adata.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"tissue\"] = \"pbmc\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"batch_indices\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"batch_indices\"] = 0\nprotein_adata.obs[\"percent_mito\"] = 0\nprotein_adata.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"tissue\"] = \"pbmc\"\nprotein_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nprotein_adata.obs[\"minor_cell_types\"] = protein_adata.obs[\"celltype.l2\"]\nprotein_adata.obs[\"major_cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"percent_mito\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"percent_mito\"] = 0\nprotein_adata.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"tissue\"] = \"pbmc\"\nprotein_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nprotein_adata.obs[\"minor_cell_types\"] = protein_adata.obs[\"celltype.l2\"]\nprotein_adata.obs[\"major_cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"leiden_subclusters\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"tissue\"] = \"pbmc\"\nprotein_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nprotein_adata.obs[\"minor_cell_types\"] = protein_adata.obs[\"celltype.l2\"]\nprotein_adata.obs[\"major_cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"tissue\"] = \"pbmc\"\nprotein_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nprotein_adata.obs[\"minor_cell_types\"] = protein_adata.obs[\"celltype.l2\"]\nprotein_adata.obs[\"major_cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields\nprotein_adata.var[\"feature_type\"] = \"protein\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"tissue\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"tissue\"] = \"pbmc\"\nprotein_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nprotein_adata.obs[\"minor_cell_types\"] = protein_adata.obs[\"celltype.l2\"]\nprotein_adata.obs[\"major_cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields\nprotein_adata.var[\"feature_type\"] = \"protein\"\n# uns fields",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"batch\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"batch\"] = \"maxfuse_cite_seq\"\nprotein_adata.obs[\"minor_cell_types\"] = protein_adata.obs[\"celltype.l2\"]\nprotein_adata.obs[\"major_cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields\nprotein_adata.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"minor_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"minor_cell_types\"] = protein_adata.obs[\"celltype.l2\"]\nprotein_adata.obs[\"major_cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields\nprotein_adata.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nprotein_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"major_cell_types\"] = protein_adata.obs[\"celltype.l1\"]\nprotein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields\nprotein_adata.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nprotein_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nprotein_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"total_counts\"] = protein_adata.X.sum(axis=1)\nprotein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields\nprotein_adata.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nprotein_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nprotein_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"n_genes_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"n_genes_by_counts\"] = (protein_adata.X > 0).sum(axis=1)\nprotein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields\nprotein_adata.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nprotein_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nprotein_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nprotein_adata.obsm.clear()",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obs[\"index_col\"] = np.arange(protein_adata.n_obs)\n# var fields\nprotein_adata.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nprotein_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nprotein_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nprotein_adata.obsm.clear()\nprotein_adata.obsm[\"latent\"] = protein_cca_full",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.var[\"feature_type\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nprotein_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nprotein_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nprotein_adata.obsm.clear()\nprotein_adata.obsm[\"latent\"] = protein_cca_full\n# layers\nprotein_adata.layers[\"counts\"] = protein_adata.X.copy()",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.uns[\"dataset_name\"] = \"maxfuse_cite_seq\"\nprotein_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nprotein_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nprotein_adata.obsm.clear()\nprotein_adata.obsm[\"latent\"] = protein_cca_full\n# layers\nprotein_adata.layers[\"counts\"] = protein_adata.X.copy()\nprint(f\"protein_adata shape: {protein_adata.shape}\")\nprint(f\"protein_adata.obs columns: {list(protein_adata.obs.columns)}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.uns[\"processing_stage\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nprotein_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nprotein_adata.obsm.clear()\nprotein_adata.obsm[\"latent\"] = protein_cca_full\n# layers\nprotein_adata.layers[\"counts\"] = protein_adata.X.copy()\nprint(f\"protein_adata shape: {protein_adata.shape}\")\nprint(f\"protein_adata.obs columns: {list(protein_adata.obs.columns)}\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.uns[\"file_generated_from\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_cite_seq.py\"\n# obsm fields - clean up and only keep what we need\nprotein_adata.obsm.clear()\nprotein_adata.obsm[\"latent\"] = protein_cca_full\n# layers\nprotein_adata.layers[\"counts\"] = protein_adata.X.copy()\nprint(f\"protein_adata shape: {protein_adata.shape}\")\nprint(f\"protein_adata.obs columns: {list(protein_adata.obs.columns)}\")\n# %%\n# Save the formatted AnnData objects",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.obsm[\"latent\"] = protein_cca_full\n# layers\nprotein_adata.layers[\"counts\"] = protein_adata.X.copy()\nprint(f\"protein_adata shape: {protein_adata.shape}\")\nprint(f\"protein_adata.obs columns: {list(protein_adata.obs.columns)}\")\n# %%\n# Save the formatted AnnData objects\noutput_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata.layers[\"counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_adata.layers[\"counts\"] = protein_adata.X.copy()\nprint(f\"protein_adata shape: {protein_adata.shape}\")\nprint(f\"protein_adata.obs columns: {list(protein_adata.obs.columns)}\")\n# %%\n# Save the formatted AnnData objects\noutput_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/maxfuse_cite_seq/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/maxfuse_cite_seq/7_protein_{timestamp}.h5ad\"",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "output_dir",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "output_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/maxfuse_cite_seq/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/maxfuse_cite_seq/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/maxfuse_cite_seq\", exist_ok=True)\nrna_adata.write(rna_output)\nprotein_adata.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "timestamp",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/maxfuse_cite_seq/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/maxfuse_cite_seq/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/maxfuse_cite_seq\", exist_ok=True)\nrna_adata.write(rna_output)\nprotein_adata.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata}\")\nprint(f\"\\nprotein_adata: {protein_adata}\")",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_output",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "rna_output = f\"{output_dir}/maxfuse_cite_seq/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/maxfuse_cite_seq/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/maxfuse_cite_seq\", exist_ok=True)\nrna_adata.write(rna_output)\nprotein_adata.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata}\")\nprint(f\"\\nprotein_adata: {protein_adata}\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_output",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_cite_seq",
        "description": "model_comparison.model_maxfuse_dataset_cite_seq",
        "peekOfCode": "protein_output = f\"{output_dir}/maxfuse_cite_seq/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/maxfuse_cite_seq\", exist_ok=True)\nrna_adata.write(rna_output)\nprotein_adata.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata}\")\nprint(f\"\\nprotein_adata: {protein_adata}\")\n# %%\n# Display summary of created objects",
        "detail": "model_comparison.model_maxfuse_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "plt.rcParams[\"figure.figsize\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "plt.rcParams[\"figure.figsize\"] = (6, 4)\nif here().parent.name == \"notebooks\":\n    os.chdir(\"../../\")\nROOT = here().parent\nTHIS_DIR = here()\nprint(ROOT)\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nos.chdir(str(ROOT))",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "ROOT = here().parent\nTHIS_DIR = here()\nprint(ROOT)\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nos.chdir(str(ROOT))\n# %%\n# Load the tonsil data directly from h5ad files (matching preprocessing pipeline)\ndataset_name = \"tonsil\"",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "THIS_DIR = here()\nprint(ROOT)\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nos.chdir(str(ROOT))\n# %%\n# Load the tonsil data directly from h5ad files (matching preprocessing pipeline)\ndataset_name = \"tonsil\"\nprint(\"Loading tonsil CODEX + RNA-seq data from h5ad files...\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "dataset_name = \"tonsil\"\nprint(\"Loading tonsil CODEX + RNA-seq data from h5ad files...\")\nrna_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"rna\", exact_step=1, dataset_name=dataset_name\n)\nprotein_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"protein\", exact_step=1, dataset_name=dataset_name\n)\nadata_rna = sc.read(str(rna_file))\nadata_prot = sc.read(str(protein_file))",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_file",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"rna\", exact_step=1, dataset_name=dataset_name\n)\nprotein_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"protein\", exact_step=1, dataset_name=dataset_name\n)\nadata_rna = sc.read(str(rna_file))\nadata_prot = sc.read(str(protein_file))\n# Make variable names unique immediately after loading to avoid warnings\nadata_rna.var_names_make_unique()",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_file",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "protein_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"protein\", exact_step=1, dataset_name=dataset_name\n)\nadata_rna = sc.read(str(rna_file))\nadata_prot = sc.read(str(protein_file))\n# Make variable names unique immediately after loading to avoid warnings\nadata_rna.var_names_make_unique()\nadata_prot.var_names_make_unique()\n# Check what's available in the loaded data\nprint(f\"\\nLoaded data structure:\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna = sc.read(str(rna_file))\nadata_prot = sc.read(str(protein_file))\n# Make variable names unique immediately after loading to avoid warnings\nadata_rna.var_names_make_unique()\nadata_prot.var_names_make_unique()\n# Check what's available in the loaded data\nprint(f\"\\nLoaded data structure:\")\nprint(f\"RNA obsm keys: {list(adata_rna.obsm.keys())}\")\nprint(f\"Protein obsm keys: {list(adata_prot.obsm.keys())}\")\nprint(f\"RNA obs columns sample: {list(adata_rna.obs.columns[:10])}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot = sc.read(str(protein_file))\n# Make variable names unique immediately after loading to avoid warnings\nadata_rna.var_names_make_unique()\nadata_prot.var_names_make_unique()\n# Check what's available in the loaded data\nprint(f\"\\nLoaded data structure:\")\nprint(f\"RNA obsm keys: {list(adata_rna.obsm.keys())}\")\nprint(f\"Protein obsm keys: {list(adata_prot.obsm.keys())}\")\nprint(f\"RNA obs columns sample: {list(adata_rna.obs.columns[:10])}\")\nprint(f\"Protein obs columns sample: {list(adata_prot.obs.columns[:10])}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.obs[\"celltype.l1\"] = adata_rna.obs[\"cell_types\"]\nadata_rna.obs[\"celltype\"] = adata_rna.obs[\"cell_types\"]\nadata_rna.obs[\"celltype.l2\"] = adata_rna.obs.get(\"minor_cell_types\", adata_rna.obs[\"cell_types\"])\nadata_prot.obs[\"celltype.l1\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype.l2\"] = adata_prot.obs.get(\"minor_cell_types\", adata_prot.obs[\"cell_types\"])\n# Extract labels for evaluation\nlabels_l1_rna = adata_rna.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"celltype\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.obs[\"celltype\"] = adata_rna.obs[\"cell_types\"]\nadata_rna.obs[\"celltype.l2\"] = adata_rna.obs.get(\"minor_cell_types\", adata_rna.obs[\"cell_types\"])\nadata_prot.obs[\"celltype.l1\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype.l2\"] = adata_prot.obs.get(\"minor_cell_types\", adata_prot.obs[\"cell_types\"])\n# Extract labels for evaluation\nlabels_l1_rna = adata_rna.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.obs[\"celltype.l2\"] = adata_rna.obs.get(\"minor_cell_types\", adata_rna.obs[\"cell_types\"])\nadata_prot.obs[\"celltype.l1\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype.l2\"] = adata_prot.obs.get(\"minor_cell_types\", adata_prot.obs[\"cell_types\"])\n# Extract labels for evaluation\nlabels_l1_rna = adata_rna.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.obs[\"celltype.l1\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype.l2\"] = adata_prot.obs.get(\"minor_cell_types\", adata_prot.obs[\"cell_types\"])\n# Extract labels for evaluation\nlabels_l1_rna = adata_rna.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_prot.shape[0]} cells\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"celltype\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.obs[\"celltype\"] = adata_prot.obs[\"cell_types\"]\nadata_prot.obs[\"celltype.l2\"] = adata_prot.obs.get(\"minor_cell_types\", adata_prot.obs[\"cell_types\"])\n# Extract labels for evaluation\nlabels_l1_rna = adata_rna.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_prot.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(adata_rna.obs.index[:5])}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.obs[\"celltype.l2\"] = adata_prot.obs.get(\"minor_cell_types\", adata_prot.obs[\"cell_types\"])\n# Extract labels for evaluation\nlabels_l1_rna = adata_rna.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_prot.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(adata_rna.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(adata_prot.obs.index[:5])}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "labels_l1_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "labels_l1_rna = adata_rna.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_prot.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(adata_rna.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(adata_prot.obs.index[:5])}\")\nprint(f\"RNA cell types: {sorted(set(labels_l1_rna))}\")\nprint(f\"Protein cell types: {sorted(set(labels_l1_prot))}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "labels_l2_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "labels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_prot.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(adata_rna.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(adata_prot.obs.index[:5])}\")\nprint(f\"RNA cell types: {sorted(set(labels_l1_rna))}\")\nprint(f\"Protein cell types: {sorted(set(labels_l1_prot))}\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "labels_l1_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "labels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_prot.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(adata_rna.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(adata_prot.obs.index[:5])}\")\nprint(f\"RNA cell types: {sorted(set(labels_l1_rna))}\")\nprint(f\"Protein cell types: {sorted(set(labels_l1_prot))}\")\n# %%\n# Load correspondence file (still from raw_datasets as it's a mapping file)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "labels_l2_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "labels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_prot.shape[0]} cells\")\nprint(f\"RNA cell barcodes sample: {list(adata_rna.obs.index[:5])}\")\nprint(f\"Protein cell barcodes sample: {list(adata_prot.obs.index[:5])}\")\nprint(f\"RNA cell types: {sorted(set(labels_l1_rna))}\")\nprint(f\"Protein cell types: {sorted(set(labels_l1_prot))}\")\n# %%\n# Load correspondence file (still from raw_datasets as it's a mapping file)\nbase_folder = \"ARCADIA/raw_datasets/tonsil\"",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "base_folder",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "base_folder = \"ARCADIA/raw_datasets/tonsil\"\ncorrespondence = pd.read_csv(f\"{base_folder}/protein_gene_conversion.csv\")\ncorrespondence.head()\n# %%\n# Check protein variable names format\nprint(f\"Sample protein var names: {list(adata_prot.var_names[:10])}\")\nprint(f\"Sample RNA var names: {list(adata_rna.var_names[:10])}\")\n# Create a mapping from clean protein names to actual var_names\n# For tonsil CODEX, protein names are typically direct (not ADT_ prefixed)\nprotein_name_mapping = {}",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "correspondence = pd.read_csv(f\"{base_folder}/protein_gene_conversion.csv\")\ncorrespondence.head()\n# %%\n# Check protein variable names format\nprint(f\"Sample protein var names: {list(adata_prot.var_names[:10])}\")\nprint(f\"Sample RNA var names: {list(adata_rna.var_names[:10])}\")\n# Create a mapping from clean protein names to actual var_names\n# For tonsil CODEX, protein names are typically direct (not ADT_ prefixed)\nprotein_name_mapping = {}\nfor var_name in adata_prot.var_names:",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_name_mapping",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "protein_name_mapping = {}\nfor var_name in adata_prot.var_names:\n    # Try to match directly first\n    protein_name_mapping[var_name] = var_name\n    # Also try without any prefixes if they exist\n    clean_name = var_name.split(\"(\")[0].strip()  # Handle cases like 'CD115(CSF-1R)'\n    if clean_name != var_name:\n        protein_name_mapping[clean_name] = var_name\nprint(f\"Created mapping for {len(protein_name_mapping)} proteins\")\nprint(f\"Sample mappings: {list(protein_name_mapping.items())[:5]}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_protein_correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_protein_correspondence = []\n# Create a case-insensitive mapping for RNA gene names\nrna_gene_mapping = {gene.upper(): gene for gene in adata_rna.var_names}\nfor i in range(correspondence.shape[0]):\n    curr_protein_name, curr_rna_names = correspondence.iloc[i]\n    # Try to find the protein in our mapping\n    actual_protein_name = protein_name_mapping.get(curr_protein_name)\n    if actual_protein_name is None:\n        continue\n    if (",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_gene_mapping",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_gene_mapping = {gene.upper(): gene for gene in adata_rna.var_names}\nfor i in range(correspondence.shape[0]):\n    curr_protein_name, curr_rna_names = correspondence.iloc[i]\n    # Try to find the protein in our mapping\n    actual_protein_name = protein_name_mapping.get(curr_protein_name)\n    if actual_protein_name is None:\n        continue\n    if (\n        curr_rna_names.find(\"Ignore\") != -1\n    ):  # some correspondence ignored eg. protein isoform to one gene",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_protein_correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_protein_correspondence = np.array(rna_protein_correspondence)\nprint(f\"Found {len(rna_protein_correspondence)} RNA-protein correspondences\")\n# %%\n# Note: For tonsil dataset, RNA and protein cells are from different samples\n# (not matched by barcode like cite_seq), so we work with all cells from both datasets\nprint(f\"RNA dataset: {adata_rna.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_prot.shape[0]} cells\")\nprint(f\"RNA index sample: {list(adata_rna.obs.index[:5])}\")\nprint(f\"Protein index sample: {list(adata_prot.obs.index[:5])}\")\n# Extract labels for evaluation",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "labels_l1_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "labels_l1_rna = adata_rna.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\n# %%\n# Columns rna_shared and protein_shared are matched.\n# One may encounter \"Variable names are not unique\" warning,\n# this is fine and is because one RNA may encode multiple proteins and vice versa.\nrna_shared = adata_rna[:, rna_protein_correspondence[:, 0]].copy()\nprotein_shared = adata_prot[:, rna_protein_correspondence[:, 1]].copy()",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "labels_l2_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "labels_l2_rna = adata_rna.obs[\"celltype.l2\"].to_numpy()\nlabels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\n# %%\n# Columns rna_shared and protein_shared are matched.\n# One may encounter \"Variable names are not unique\" warning,\n# this is fine and is because one RNA may encode multiple proteins and vice versa.\nrna_shared = adata_rna[:, rna_protein_correspondence[:, 0]].copy()\nprotein_shared = adata_prot[:, rna_protein_correspondence[:, 1]].copy()\n# Use raw counts from layers if they exist (similar to lines 54-61)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "labels_l1_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "labels_l1_prot = adata_prot.obs[\"celltype.l1\"].to_numpy()\nlabels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\n# %%\n# Columns rna_shared and protein_shared are matched.\n# One may encounter \"Variable names are not unique\" warning,\n# this is fine and is because one RNA may encode multiple proteins and vice versa.\nrna_shared = adata_rna[:, rna_protein_correspondence[:, 0]].copy()\nprotein_shared = adata_prot[:, rna_protein_correspondence[:, 1]].copy()\n# Use raw counts from layers if they exist (similar to lines 54-61)\nif \"counts\" in rna_shared.layers:",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "labels_l2_prot",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "labels_l2_prot = adata_prot.obs[\"celltype.l2\"].to_numpy()\n# %%\n# Columns rna_shared and protein_shared are matched.\n# One may encounter \"Variable names are not unique\" warning,\n# this is fine and is because one RNA may encode multiple proteins and vice versa.\nrna_shared = adata_rna[:, rna_protein_correspondence[:, 0]].copy()\nprotein_shared = adata_prot[:, rna_protein_correspondence[:, 1]].copy()\n# Use raw counts from layers if they exist (similar to lines 54-61)\nif \"counts\" in rna_shared.layers:\n    rna_shared.X = rna_shared.layers[\"counts\"].copy()",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_shared = adata_rna[:, rna_protein_correspondence[:, 0]].copy()\nprotein_shared = adata_prot[:, rna_protein_correspondence[:, 1]].copy()\n# Use raw counts from layers if they exist (similar to lines 54-61)\nif \"counts\" in rna_shared.layers:\n    rna_shared.X = rna_shared.layers[\"counts\"].copy()\nif \"counts\" in protein_shared.layers:\n    protein_shared.X = protein_shared.layers[\"counts\"].copy()\n# %%\n# Make sure no column is static, only use protein features\n# that are variable (larger than a certain threshold)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "protein_shared = adata_prot[:, rna_protein_correspondence[:, 1]].copy()\n# Use raw counts from layers if they exist (similar to lines 54-61)\nif \"counts\" in rna_shared.layers:\n    rna_shared.X = rna_shared.layers[\"counts\"].copy()\nif \"counts\" in protein_shared.layers:\n    protein_shared.X = protein_shared.layers[\"counts\"].copy()\n# %%\n# Make sure no column is static, only use protein features\n# that are variable (larger than a certain threshold)\n# mask = (rna_shared.X.std(axis=0) > 0.5) & (protein_shared.X.std(axis=0) > 0.1)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "mask",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "mask = (rna_shared.X.std(axis=0) > 0.3) & (protein_shared.X.std(axis=0) > 0.05)\nrna_shared = rna_shared[:, mask].copy()\nprotein_shared = protein_shared[:, mask].copy()\nprint([rna_shared.shape, protein_shared.shape])\n# %%\n# process rna_shared\n# Note: We don't filter cells here to avoid batch index misalignment issues\n# MaxFuse will handle any zero-count cells internally\nsc.pp.normalize_total(rna_shared)\nsc.pp.log1p(rna_shared)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_shared = rna_shared[:, mask].copy()\nprotein_shared = protein_shared[:, mask].copy()\nprint([rna_shared.shape, protein_shared.shape])\n# %%\n# process rna_shared\n# Note: We don't filter cells here to avoid batch index misalignment issues\n# MaxFuse will handle any zero-count cells internally\nsc.pp.normalize_total(rna_shared)\nsc.pp.log1p(rna_shared)\nsc.pp.scale(rna_shared)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "protein_shared = protein_shared[:, mask].copy()\nprint([rna_shared.shape, protein_shared.shape])\n# %%\n# process rna_shared\n# Note: We don't filter cells here to avoid batch index misalignment issues\n# MaxFuse will handle any zero-count cells internally\nsc.pp.normalize_total(rna_shared)\nsc.pp.log1p(rna_shared)\nsc.pp.scale(rna_shared)\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna = adata_rna[:, adata_rna.var.highly_variable].copy()\nsc.pp.scale(adata_rna)\n# Extract active arrays\nrna_active = adata_rna.X\nprotein_active = adata_prot.X\nrna_active = rna_active[:, rna_active.std(axis=0) > 1e-5]\nprotein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\nprint(rna_active.shape, protein_active.shape, rna_shared.shape, protein_shared.shape)\n# %%\n# Convert shared arrays to numpy",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_active",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_active = adata_rna.X\nprotein_active = adata_prot.X\nrna_active = rna_active[:, rna_active.std(axis=0) > 1e-5]\nprotein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\nprint(rna_active.shape, protein_active.shape, rna_shared.shape, protein_shared.shape)\n# %%\n# Convert shared arrays to numpy\nrna_shared = rna_shared.X.copy()\nprotein_shared = protein_shared.X.copy()\n# Convert to dense if sparse",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_active",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "protein_active = adata_prot.X\nrna_active = rna_active[:, rna_active.std(axis=0) > 1e-5]\nprotein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\nprint(rna_active.shape, protein_active.shape, rna_shared.shape, protein_shared.shape)\n# %%\n# Convert shared arrays to numpy\nrna_shared = rna_shared.X.copy()\nprotein_shared = protein_shared.X.copy()\n# Convert to dense if sparse\nif issparse(rna_shared):",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_active",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_active = rna_active[:, rna_active.std(axis=0) > 1e-5]\nprotein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\nprint(rna_active.shape, protein_active.shape, rna_shared.shape, protein_shared.shape)\n# %%\n# Convert shared arrays to numpy\nrna_shared = rna_shared.X.copy()\nprotein_shared = protein_shared.X.copy()\n# Convert to dense if sparse\nif issparse(rna_shared):\n    rna_shared = rna_shared.toarray()",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_active",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "protein_active = protein_active[:, protein_active.std(axis=0) > 1e-5]\nprint(rna_active.shape, protein_active.shape, rna_shared.shape, protein_shared.shape)\n# %%\n# Convert shared arrays to numpy\nrna_shared = rna_shared.X.copy()\nprotein_shared = protein_shared.X.copy()\n# Convert to dense if sparse\nif issparse(rna_shared):\n    rna_shared = rna_shared.toarray()\nif issparse(protein_shared):",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_shared = rna_shared.X.copy()\nprotein_shared = protein_shared.X.copy()\n# Convert to dense if sparse\nif issparse(rna_shared):\n    rna_shared = rna_shared.toarray()\nif issparse(protein_shared):\n    protein_shared = protein_shared.toarray()\n# Check for and handle inf/NaN values in shared arrays\nif np.any(~np.isfinite(rna_shared)):\n    print(f\"Warning: Found {np.sum(~np.isfinite(rna_shared))} inf/NaN values in rna_shared, replacing with 0\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_shared",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "protein_shared = protein_shared.X.copy()\n# Convert to dense if sparse\nif issparse(rna_shared):\n    rna_shared = rna_shared.toarray()\nif issparse(protein_shared):\n    protein_shared = protein_shared.toarray()\n# Check for and handle inf/NaN values in shared arrays\nif np.any(~np.isfinite(rna_shared)):\n    print(f\"Warning: Found {np.sum(~np.isfinite(rna_shared))} inf/NaN values in rna_shared, replacing with 0\")\n    rna_shared = np.nan_to_num(rna_shared, nan=0.0, posinf=0.0, neginf=0.0)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "fusor",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "fusor = mf.model.Fusor(\n    shared_arr1=rna_shared,\n    shared_arr2=protein_shared,\n    active_arr1=rna_active,\n    active_arr2=protein_active,\n    labels1=None,\n    labels2=None,\n)\n# %%\nfusor.split_into_batches(max_outward_size=8000, matching_ratio=4, metacell_size=2, verbose=True)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "pivot_matching",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "pivot_matching = fusor.get_matching(order=(2, 1), target=\"pivot\")\nlv1_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l1_rna, labels2=labels_l1_prot, order=(2, 1)\n)\nlv2_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l2_rna, labels2=labels_l2_prot, order=(2, 1)\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %%\n# We can inspect the first pivot pair.",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "lv1_acc",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "lv1_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l1_rna, labels2=labels_l1_prot, order=(2, 1)\n)\nlv2_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l2_rna, labels2=labels_l2_prot, order=(2, 1)\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %%\n# We can inspect the first pivot pair.\n[pivot_matching[0][0], pivot_matching[1][0], pivot_matching[2][0]]",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "lv2_acc",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "lv2_acc = mf.metrics.get_matching_acc(\n    matching=pivot_matching, labels1=labels_l2_rna, labels2=labels_l2_prot, order=(2, 1)\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %%\n# We can inspect the first pivot pair.\n[pivot_matching[0][0], pivot_matching[1][0], pivot_matching[2][0]]\n# %%\ncm = confusion_matrix(\n    labels_l1_rna[pivot_matching[0]], labels_l1_prot[pivot_matching[1]]",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "cm",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "cm = confusion_matrix(\n    labels_l1_rna[pivot_matching[0]], labels_l1_prot[pivot_matching[1]]\n)\nConfusionMatrixDisplay(\n    confusion_matrix=np.round((cm.T / np.sum(cm, axis=1)).T * 100),\n    display_labels=np.unique(labels_l1_rna),\n).plot()\n# %%\nfusor.propagate(\n    svd_components1=40,",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "full_matching",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "full_matching = fusor.get_matching(order=(2, 1), target=\"full_data\")\n# %%\npd.DataFrame(\n    list(zip(full_matching[0], full_matching[1], full_matching[2])),\n    columns=[\"mod1_indx\", \"mod2_indx\", \"score\"],\n)\n# %%\n# compute the cell type level matching accuracy, for the full (filtered version) dataset\nlv1_acc = mf.metrics.get_matching_acc(\n    matching=full_matching, labels1=labels_l1_rna, labels2=labels_l1_prot",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "lv1_acc",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "lv1_acc = mf.metrics.get_matching_acc(\n    matching=full_matching, labels1=labels_l1_rna, labels2=labels_l1_prot\n)\nlv2_acc = mf.metrics.get_matching_acc(\n    matching=full_matching, labels1=labels_l2_rna, labels2=labels_l2_prot\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %%\nrna_cca, protein_cca_sub = fusor.get_embedding(\n    active_arr1=fusor.active_arr1,",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "lv2_acc",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "lv2_acc = mf.metrics.get_matching_acc(\n    matching=full_matching, labels1=labels_l2_rna, labels2=labels_l2_prot\n)\nprint(f\"lv1 matching acc: {lv1_acc:.3f},\\nlv2 matching acc: {lv2_acc:.3f}.\")\n# %%\nrna_cca, protein_cca_sub = fusor.get_embedding(\n    active_arr1=fusor.active_arr1,\n    active_arr2=fusor.active_arr2[full_matching[1], :],  # cells in codex remained after filtering\n)\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "subs",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "subs = min(13000, protein_cca_sub.shape[0], adata_rna.shape[0])\nrandix = np.random.choice(protein_cca_sub.shape[0], subs, replace=False)\ndim_use = 15  # dimensions of the CCA embedding to be used for UMAP etc\ncca_adata = ad.AnnData(\n    np.concatenate((rna_cca[:, :dim_use], protein_cca_sub[randix, :dim_use]), axis=0),\n    dtype=np.float32,\n)\ncca_adata.obs[\"data_type\"] = [\"rna\"] * rna_cca.shape[0] + [\"protein\"] * subs\ncca_adata.obs[\"celltype.l1\"] = list(labels_l1_rna) + list(\n    labels_l1_prot[full_matching[1]][randix]",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "randix",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "randix = np.random.choice(protein_cca_sub.shape[0], subs, replace=False)\ndim_use = 15  # dimensions of the CCA embedding to be used for UMAP etc\ncca_adata = ad.AnnData(\n    np.concatenate((rna_cca[:, :dim_use], protein_cca_sub[randix, :dim_use]), axis=0),\n    dtype=np.float32,\n)\ncca_adata.obs[\"data_type\"] = [\"rna\"] * rna_cca.shape[0] + [\"protein\"] * subs\ncca_adata.obs[\"celltype.l1\"] = list(labels_l1_rna) + list(\n    labels_l1_prot[full_matching[1]][randix]\n)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "dim_use",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "dim_use = 15  # dimensions of the CCA embedding to be used for UMAP etc\ncca_adata = ad.AnnData(\n    np.concatenate((rna_cca[:, :dim_use], protein_cca_sub[randix, :dim_use]), axis=0),\n    dtype=np.float32,\n)\ncca_adata.obs[\"data_type\"] = [\"rna\"] * rna_cca.shape[0] + [\"protein\"] * subs\ncca_adata.obs[\"celltype.l1\"] = list(labels_l1_rna) + list(\n    labels_l1_prot[full_matching[1]][randix]\n)\ncca_adata.obs[\"celltype.l2\"] = list(labels_l2_rna) + list(",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "cca_adata",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "cca_adata = ad.AnnData(\n    np.concatenate((rna_cca[:, :dim_use], protein_cca_sub[randix, :dim_use]), axis=0),\n    dtype=np.float32,\n)\ncca_adata.obs[\"data_type\"] = [\"rna\"] * rna_cca.shape[0] + [\"protein\"] * subs\ncca_adata.obs[\"celltype.l1\"] = list(labels_l1_rna) + list(\n    labels_l1_prot[full_matching[1]][randix]\n)\ncca_adata.obs[\"celltype.l2\"] = list(labels_l2_rna) + list(\n    labels_l2_prot[full_matching[1]][randix]",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"data_type\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "cca_adata.obs[\"data_type\"] = [\"rna\"] * rna_cca.shape[0] + [\"protein\"] * subs\ncca_adata.obs[\"celltype.l1\"] = list(labels_l1_rna) + list(\n    labels_l1_prot[full_matching[1]][randix]\n)\ncca_adata.obs[\"celltype.l2\"] = list(labels_l2_rna) + list(\n    labels_l2_prot[full_matching[1]][randix]\n)\ncca_adata.obs[\"cell_type\"] = cca_adata.obs[\"celltype.l1\"]\n# %%\nsc.pp.neighbors(cca_adata, n_neighbors=15)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "cca_adata.obs[\"celltype.l1\"] = list(labels_l1_rna) + list(\n    labels_l1_prot[full_matching[1]][randix]\n)\ncca_adata.obs[\"celltype.l2\"] = list(labels_l2_rna) + list(\n    labels_l2_prot[full_matching[1]][randix]\n)\ncca_adata.obs[\"cell_type\"] = cca_adata.obs[\"celltype.l1\"]\n# %%\nsc.pp.neighbors(cca_adata, n_neighbors=15)\nsc.tl.umap(cca_adata)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "cca_adata.obs[\"celltype.l2\"] = list(labels_l2_rna) + list(\n    labels_l2_prot[full_matching[1]][randix]\n)\ncca_adata.obs[\"cell_type\"] = cca_adata.obs[\"celltype.l1\"]\n# %%\nsc.pp.neighbors(cca_adata, n_neighbors=15)\nsc.tl.umap(cca_adata)\nsc.pl.umap(cca_adata, color=\"data_type\")\n# %%\nsc.pl.umap(cca_adata, color=\"cell_type\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "cca_adata.obs[\"cell_type\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "cca_adata.obs[\"cell_type\"] = cca_adata.obs[\"celltype.l1\"]\n# %%\nsc.pp.neighbors(cca_adata, n_neighbors=15)\nsc.tl.umap(cca_adata)\nsc.pl.umap(cca_adata, color=\"data_type\")\n# %%\nsc.pl.umap(cca_adata, color=\"cell_type\")\n# %%\n# Get full embedding for all cells (not just the subsampled ones used for visualization)\nrna_cca_full, codex_cca_full = fusor.get_embedding(",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"batch\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.obs[\"batch\"] = \"maxfuse_tonsil\"\n# Set minor_cell_types if not already present\nif \"minor_cell_types\" not in adata_rna.obs.columns:\n    adata_rna.obs[\"minor_cell_types\"] = adata_rna.obs[\"celltype.l2\"]\nadata_rna.obs[\"tissue\"] = \"tonsil\"\nadata_rna.obs[\"index_col\"] = np.arange(adata_rna.n_obs)\n# var fields - preserve existing fields from ARCADIA preprocessing\n# Most var fields (n_cells, mt, ribo, hb, total_counts, n_cells_by_counts) are already set during preprocessing\n# uns fields\nadata_rna.uns[\"dataset_name\"] = \"maxfuse_tonsil\"",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"tissue\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.obs[\"tissue\"] = \"tonsil\"\nadata_rna.obs[\"index_col\"] = np.arange(adata_rna.n_obs)\n# var fields - preserve existing fields from ARCADIA preprocessing\n# Most var fields (n_cells, mt, ribo, hb, total_counts, n_cells_by_counts) are already set during preprocessing\n# uns fields\nadata_rna.uns[\"dataset_name\"] = \"maxfuse_tonsil\"\nadata_rna.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nadata_rna.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and only keep what we need\nadata_rna.obsm.clear()",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.obs[\"index_col\"] = np.arange(adata_rna.n_obs)\n# var fields - preserve existing fields from ARCADIA preprocessing\n# Most var fields (n_cells, mt, ribo, hb, total_counts, n_cells_by_counts) are already set during preprocessing\n# uns fields\nadata_rna.uns[\"dataset_name\"] = \"maxfuse_tonsil\"\nadata_rna.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nadata_rna.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and only keep what we need\nadata_rna.obsm.clear()\nadata_rna.obsm[\"latent\"] = rna_cca_full",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.uns[\"dataset_name\"] = \"maxfuse_tonsil\"\nadata_rna.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nadata_rna.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and only keep what we need\nadata_rna.obsm.clear()\nadata_rna.obsm[\"latent\"] = rna_cca_full\n# layers\nadata_rna.layers[\"counts\"] = adata_rna.X.copy()\nprint(f\"adata_rna shape: {adata_rna.shape}\")\nprint(f\"adata_rna.obs columns: {list(adata_rna.obs.columns)}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"processing_stage\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nadata_rna.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and only keep what we need\nadata_rna.obsm.clear()\nadata_rna.obsm[\"latent\"] = rna_cca_full\n# layers\nadata_rna.layers[\"counts\"] = adata_rna.X.copy()\nprint(f\"adata_rna shape: {adata_rna.shape}\")\nprint(f\"adata_rna.obs columns: {list(adata_rna.obs.columns)}\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.uns[\"file_generated_from\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and only keep what we need\nadata_rna.obsm.clear()\nadata_rna.obsm[\"latent\"] = rna_cca_full\n# layers\nadata_rna.layers[\"counts\"] = adata_rna.X.copy()\nprint(f\"adata_rna shape: {adata_rna.shape}\")\nprint(f\"adata_rna.obs columns: {list(adata_rna.obs.columns)}\")\n# %%\n# Prepare Protein AnnData object with spatial coordinates",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.obsm[\"latent\"] = rna_cca_full\n# layers\nadata_rna.layers[\"counts\"] = adata_rna.X.copy()\nprint(f\"adata_rna shape: {adata_rna.shape}\")\nprint(f\"adata_rna.obs columns: {list(adata_rna.obs.columns)}\")\n# %%\n# Prepare Protein AnnData object with spatial coordinates\n# obs fields - only set fields needed for maxfuse compatibility that don't already exist\n# cell_types, major_cell_types, total_counts, X, Y, condition, Image, Sample, n_genes_by_counts are already set\nif \"batch_indices\" not in adata_prot.obs.columns:",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_rna.layers[\"counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_rna.layers[\"counts\"] = adata_rna.X.copy()\nprint(f\"adata_rna shape: {adata_rna.shape}\")\nprint(f\"adata_rna.obs columns: {list(adata_rna.obs.columns)}\")\n# %%\n# Prepare Protein AnnData object with spatial coordinates\n# obs fields - only set fields needed for maxfuse compatibility that don't already exist\n# cell_types, major_cell_types, total_counts, X, Y, condition, Image, Sample, n_genes_by_counts are already set\nif \"batch_indices\" not in adata_prot.obs.columns:\n    adata_prot.obs[\"batch_indices\"] = 0\nif \"percent_mito\" not in adata_prot.obs.columns:",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"batch\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.obs[\"batch\"] = \"maxfuse_tonsil\"\n# Set minor_cell_types if not already present\nif \"minor_cell_types\" not in adata_prot.obs.columns:\n    adata_prot.obs[\"minor_cell_types\"] = adata_prot.obs[\"celltype.l2\"]\nadata_prot.obs[\"tissue\"] = \"tonsil\"\n# total_counts, n_genes_by_counts, log1p fields, X, Y, condition, Image, Sample are already set from preprocessing\nif \"outlier\" not in adata_prot.obs.columns:\n    adata_prot.obs[\"outlier\"] = False\nif \"CN\" not in adata_prot.obs.columns:\n    adata_prot.obs[\"CN\"] = \"CN_unknown\"",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"tissue\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.obs[\"tissue\"] = \"tonsil\"\n# total_counts, n_genes_by_counts, log1p fields, X, Y, condition, Image, Sample are already set from preprocessing\nif \"outlier\" not in adata_prot.obs.columns:\n    adata_prot.obs[\"outlier\"] = False\nif \"CN\" not in adata_prot.obs.columns:\n    adata_prot.obs[\"CN\"] = \"CN_unknown\"\nadata_prot.obs[\"index_col\"] = np.arange(adata_prot.n_obs)\n# var fields - only set if not already present\nif \"feature_type\" not in adata_prot.var.columns:\n    adata_prot.var[\"feature_type\"] = \"protein\"",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.obs[\"index_col\"] = np.arange(adata_prot.n_obs)\n# var fields - only set if not already present\nif \"feature_type\" not in adata_prot.var.columns:\n    adata_prot.var[\"feature_type\"] = \"protein\"\n# uns fields\nadata_prot.uns[\"dataset_name\"] = \"maxfuse_tonsil\"\nadata_prot.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nadata_prot.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and add latent, preserve spatial coordinates\nspatial_coords = adata_prot.obsm.get(\"spatial\", None)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.uns[\"dataset_name\"] = \"maxfuse_tonsil\"\nadata_prot.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nadata_prot.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and add latent, preserve spatial coordinates\nspatial_coords = adata_prot.obsm.get(\"spatial\", None)\nadata_prot.obsm.clear()\nadata_prot.obsm[\"latent\"] = codex_cca_full\nif spatial_coords is not None:\n    adata_prot.obsm[\"spatial\"] = spatial_coords\n    print(\"Preserved spatial coordinates in obsm['spatial']\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"processing_stage\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.uns[\"processing_stage\"] = \"maxfuse_integrated\"\nadata_prot.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and add latent, preserve spatial coordinates\nspatial_coords = adata_prot.obsm.get(\"spatial\", None)\nadata_prot.obsm.clear()\nadata_prot.obsm[\"latent\"] = codex_cca_full\nif spatial_coords is not None:\n    adata_prot.obsm[\"spatial\"] = spatial_coords\n    print(\"Preserved spatial coordinates in obsm['spatial']\")\nprint(f\"adata_prot shape: {adata_prot.shape}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.uns[\"file_generated_from\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.uns[\"file_generated_from\"] = \"model_maxfuse_dataset_tonsil.py\"\n# obsm fields - clear and add latent, preserve spatial coordinates\nspatial_coords = adata_prot.obsm.get(\"spatial\", None)\nadata_prot.obsm.clear()\nadata_prot.obsm[\"latent\"] = codex_cca_full\nif spatial_coords is not None:\n    adata_prot.obsm[\"spatial\"] = spatial_coords\n    print(\"Preserved spatial coordinates in obsm['spatial']\")\nprint(f\"adata_prot shape: {adata_prot.shape}\")\nprint(f\"adata_prot.obs columns: {list(adata_prot.obs.columns)}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "spatial_coords",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "spatial_coords = adata_prot.obsm.get(\"spatial\", None)\nadata_prot.obsm.clear()\nadata_prot.obsm[\"latent\"] = codex_cca_full\nif spatial_coords is not None:\n    adata_prot.obsm[\"spatial\"] = spatial_coords\n    print(\"Preserved spatial coordinates in obsm['spatial']\")\nprint(f\"adata_prot shape: {adata_prot.shape}\")\nprint(f\"adata_prot.obs columns: {list(adata_prot.obs.columns)}\")\n# %%\n# plot spatial coordinates with sc.pl.embedding with celltype as color (if spatial coordinates available)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_prot.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "adata_prot.obsm[\"latent\"] = codex_cca_full\nif spatial_coords is not None:\n    adata_prot.obsm[\"spatial\"] = spatial_coords\n    print(\"Preserved spatial coordinates in obsm['spatial']\")\nprint(f\"adata_prot shape: {adata_prot.shape}\")\nprint(f\"adata_prot.obs columns: {list(adata_prot.obs.columns)}\")\n# %%\n# plot spatial coordinates with sc.pl.embedding with celltype as color (if spatial coordinates available)\nif \"spatial\" in adata_prot.obsm:\n    sc.pl.embedding(adata_prot, \"spatial\", color=\"cell_types\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "output_dir",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "output_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/maxfuse_tonsil/7_rna_{timestamp}.h5ad\"\nprot_output = f\"{output_dir}/maxfuse_tonsil/7_protein_{timestamp}.h5ad\"\nadata_rna.write(rna_output)\nadata_prot.write(prot_output)\nprint(f\"Saved adata_rna to: {rna_output}\")\nprint(f\"Saved adata_prot to: {prot_output}\")\nprint(f\"\\nadata_rna: {adata_rna}\")",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "timestamp",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/maxfuse_tonsil/7_rna_{timestamp}.h5ad\"\nprot_output = f\"{output_dir}/maxfuse_tonsil/7_protein_{timestamp}.h5ad\"\nadata_rna.write(rna_output)\nadata_prot.write(prot_output)\nprint(f\"Saved adata_rna to: {rna_output}\")\nprint(f\"Saved adata_prot to: {prot_output}\")\nprint(f\"\\nadata_rna: {adata_rna}\")\nprint(f\"\\nadata_prot: {adata_prot}\")\n# %%",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_output",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "rna_output = f\"{output_dir}/maxfuse_tonsil/7_rna_{timestamp}.h5ad\"\nprot_output = f\"{output_dir}/maxfuse_tonsil/7_protein_{timestamp}.h5ad\"\nadata_rna.write(rna_output)\nadata_prot.write(prot_output)\nprint(f\"Saved adata_rna to: {rna_output}\")\nprint(f\"Saved adata_prot to: {prot_output}\")\nprint(f\"\\nadata_rna: {adata_rna}\")\nprint(f\"\\nadata_prot: {adata_prot}\")\n# %%\n# Display summary of created objects",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "prot_output",
        "kind": 5,
        "importPath": "model_comparison.model_maxfuse_dataset_tonsil",
        "description": "model_comparison.model_maxfuse_dataset_tonsil",
        "peekOfCode": "prot_output = f\"{output_dir}/maxfuse_tonsil/7_protein_{timestamp}.h5ad\"\nadata_rna.write(rna_output)\nadata_prot.write(prot_output)\nprint(f\"Saved adata_rna to: {rna_output}\")\nprint(f\"Saved adata_prot to: {prot_output}\")\nprint(f\"\\nadata_rna: {adata_rna}\")\nprint(f\"\\nadata_prot: {adata_prot}\")\n# %%\n# Display summary of created objects\nprint(\"=\" * 80)",
        "detail": "model_comparison.model_maxfuse_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "ROOT = here().parent\nTHIS_DIR = here()\nprint(f\"ROOT: {ROOT}\")\nprint(f\"THIS_DIR: {THIS_DIR}\")\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nsys.path.append(str(THIS_DIR / \"scMODAL_main\"))\nos.chdir(str(ROOT))\nprint(f\"Working directory: {os.getcwd()}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "THIS_DIR = here()\nprint(f\"ROOT: {ROOT}\")\nprint(f\"THIS_DIR: {THIS_DIR}\")\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nsys.path.append(str(THIS_DIR / \"scMODAL_main\"))\nos.chdir(str(ROOT))\nprint(f\"Working directory: {os.getcwd()}\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "dataset_name = \"cite_seq\"\nprint(\"Loading CITE-seq spleen lymph node data from h5ad files...\")\nrna_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"rna\", exact_step=1, dataset_name=dataset_name\n)\nprint(f\"RNA file: {str(rna_file)}\")\nprotein_file = get_latest_file(\n    \"ARCADIA/processed_data\",\n    \"protein\",\n    exact_step=1,",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_file",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"rna\", exact_step=1, dataset_name=dataset_name\n)\nprint(f\"RNA file: {str(rna_file)}\")\nprotein_file = get_latest_file(\n    \"ARCADIA/processed_data\",\n    \"protein\",\n    exact_step=1,\n    dataset_name=dataset_name,\n)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_file",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_file = get_latest_file(\n    \"ARCADIA/processed_data\",\n    \"protein\",\n    exact_step=1,\n    dataset_name=dataset_name,\n)\nadata_RNA = sc.read(str(rna_file))\nadata_ADT = sc.read(str(protein_file))\nadata_RNA.X = adata_RNA.layers[\"counts\"].copy()\nadata_ADT.X = adata_ADT.layers[\"counts\"].copy()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_RNA",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_RNA = sc.read(str(rna_file))\nadata_ADT = sc.read(str(protein_file))\nadata_RNA.X = adata_RNA.layers[\"counts\"].copy()\nadata_ADT.X = adata_ADT.layers[\"counts\"].copy()\n# %%\n# Cell type labels\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"cell_types\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"minor_cell_types\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"minor_cell_types\"]",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_ADT",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_ADT = sc.read(str(protein_file))\nadata_RNA.X = adata_RNA.layers[\"counts\"].copy()\nadata_ADT.X = adata_ADT.layers[\"counts\"].copy()\n# %%\n# Cell type labels\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"cell_types\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"minor_cell_types\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"minor_cell_types\"]\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_RNA.X",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_RNA.X = adata_RNA.layers[\"counts\"].copy()\nadata_ADT.X = adata_ADT.layers[\"counts\"].copy()\n# %%\n# Cell type labels\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"cell_types\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"minor_cell_types\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"minor_cell_types\"]\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_ADT.X",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_ADT.X = adata_ADT.layers[\"counts\"].copy()\n# %%\n# Cell type labels\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"cell_types\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"minor_cell_types\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"minor_cell_types\"]\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_RNA.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"cell_types\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"minor_cell_types\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"minor_cell_types\"]\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%\n# Find common cells between RNA and protein datasets\ncommon_cells = adata_RNA.obs.index.intersection(adata_ADT.obs.index)\nprint(f\"Common cells between RNA and protein: {len(common_cells)}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_RNA.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"minor_cell_types\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"minor_cell_types\"]\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%\n# Find common cells between RNA and protein datasets\ncommon_cells = adata_RNA.obs.index.intersection(adata_ADT.obs.index)\nprint(f\"Common cells between RNA and protein: {len(common_cells)}\")\nprint(f\"RNA unique cells: {len(adata_RNA.obs.index) - len(common_cells)}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_ADT.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"minor_cell_types\"]\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%\n# Find common cells between RNA and protein datasets\ncommon_cells = adata_RNA.obs.index.intersection(adata_ADT.obs.index)\nprint(f\"Common cells between RNA and protein: {len(common_cells)}\")\nprint(f\"RNA unique cells: {len(adata_RNA.obs.index) - len(common_cells)}\")\nprint(f\"Protein unique cells: {len(adata_ADT.obs.index) - len(common_cells)}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_ADT.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"minor_cell_types\"]\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%\n# Find common cells between RNA and protein datasets\ncommon_cells = adata_RNA.obs.index.intersection(adata_ADT.obs.index)\nprint(f\"Common cells between RNA and protein: {len(common_cells)}\")\nprint(f\"RNA unique cells: {len(adata_RNA.obs.index) - len(common_cells)}\")\nprint(f\"Protein unique cells: {len(adata_ADT.obs.index) - len(common_cells)}\")\n# Subset both datasets to common cells",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "common_cells",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "common_cells = adata_RNA.obs.index.intersection(adata_ADT.obs.index)\nprint(f\"Common cells between RNA and protein: {len(common_cells)}\")\nprint(f\"RNA unique cells: {len(adata_RNA.obs.index) - len(common_cells)}\")\nprint(f\"Protein unique cells: {len(adata_ADT.obs.index) - len(common_cells)}\")\n# Subset both datasets to common cells\nadata_RNA = adata_RNA[common_cells].copy()\nadata_ADT = adata_ADT[common_cells].copy()\nprint(f\"After filtering to common cells:\")\nprint(f\"RNA dataset: {adata_RNA.shape}\")\nprint(f\"Protein dataset: {adata_ADT.shape}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_RNA",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_RNA = adata_RNA[common_cells].copy()\nadata_ADT = adata_ADT[common_cells].copy()\nprint(f\"After filtering to common cells:\")\nprint(f\"RNA dataset: {adata_RNA.shape}\")\nprint(f\"Protein dataset: {adata_ADT.shape}\")\n# Now subsample if needed (using the same indices for both)\nnum_cells = 1000000000000\nmax_cells = min(num_cells, len(common_cells))\nif len(common_cells) > max_cells:\n    np.random.seed(42)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_ADT",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_ADT = adata_ADT[common_cells].copy()\nprint(f\"After filtering to common cells:\")\nprint(f\"RNA dataset: {adata_RNA.shape}\")\nprint(f\"Protein dataset: {adata_ADT.shape}\")\n# Now subsample if needed (using the same indices for both)\nnum_cells = 1000000000000\nmax_cells = min(num_cells, len(common_cells))\nif len(common_cells) > max_cells:\n    np.random.seed(42)\n    subsample_indices = np.random.choice(len(common_cells), max_cells, replace=False)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "num_cells",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "num_cells = 1000000000000\nmax_cells = min(num_cells, len(common_cells))\nif len(common_cells) > max_cells:\n    np.random.seed(42)\n    subsample_indices = np.random.choice(len(common_cells), max_cells, replace=False)\n    subsample_cells = common_cells[subsample_indices]\n    adata_RNA = adata_RNA[subsample_cells].copy()\n    adata_ADT = adata_ADT[subsample_cells].copy()\n    print(f\"Subsampled to {max_cells} cells\")\n# Verify matching cells",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "max_cells",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "max_cells = min(num_cells, len(common_cells))\nif len(common_cells) > max_cells:\n    np.random.seed(42)\n    subsample_indices = np.random.choice(len(common_cells), max_cells, replace=False)\n    subsample_cells = common_cells[subsample_indices]\n    adata_RNA = adata_RNA[subsample_cells].copy()\n    adata_ADT = adata_ADT[subsample_cells].copy()\n    print(f\"Subsampled to {max_cells} cells\")\n# Verify matching cells\nprint(f\"Final RNA dataset: {adata_RNA.shape[0]} cells\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "data_dir",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "data_dir = \"/workspace/ARCADIA/raw_datasets\"\ncorrespondence = pd.read_csv(f\"{data_dir}/tonsil/protein_gene_conversion.csv\")\ncorrespondence[\"Protein name\"] = correspondence[\"Protein name\"].replace(\n    to_replace={\"CD11a-CD18\": \"CD11a/CD18\", \"CD66a-c-e\": \"CD66a/c/e\"}\n)\nprint(correspondence.head())\n# %%\n# Create protein name mapping\nprotein_name_mapping = {}\nfor var_name in adata_ADT.var_names:",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "correspondence = pd.read_csv(f\"{data_dir}/tonsil/protein_gene_conversion.csv\")\ncorrespondence[\"Protein name\"] = correspondence[\"Protein name\"].replace(\n    to_replace={\"CD11a-CD18\": \"CD11a/CD18\", \"CD66a-c-e\": \"CD66a/c/e\"}\n)\nprint(correspondence.head())\n# %%\n# Create protein name mapping\nprotein_name_mapping = {}\nfor var_name in adata_ADT.var_names:\n    if var_name.startswith(\"ADT_\"):",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_name_mapping",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_name_mapping = {}\nfor var_name in adata_ADT.var_names:\n    if var_name.startswith(\"ADT_\"):\n        parts = var_name.split(\"_\")\n        if len(parts) >= 2:\n            clean_name = parts[1].split(\"(\")[0]\n            protein_name_mapping[clean_name] = var_name\nprint(f\"Created mapping for {len(protein_name_mapping)} proteins\")\n# Create RNA gene mapping (case-insensitive)\nrna_gene_mapping = {gene.upper(): gene for gene in adata_RNA.var_names}",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_gene_mapping",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_gene_mapping = {gene.upper(): gene for gene in adata_RNA.var_names}\nrna_protein_correspondence = []\nfor i in range(correspondence.shape[0]):\n    curr_protein_name, curr_rna_names = correspondence.iloc[i]\n    actual_protein_name = protein_name_mapping.get(curr_protein_name)\n    if actual_protein_name is None:\n        continue\n    if curr_rna_names.find(\"Ignore\") != -1:\n        continue\n    curr_rna_names = curr_rna_names.split(\"/\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_protein_correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_protein_correspondence = []\nfor i in range(correspondence.shape[0]):\n    curr_protein_name, curr_rna_names = correspondence.iloc[i]\n    actual_protein_name = protein_name_mapping.get(curr_protein_name)\n    if actual_protein_name is None:\n        continue\n    if curr_rna_names.find(\"Ignore\") != -1:\n        continue\n    curr_rna_names = curr_rna_names.split(\"/\")\n    for r in curr_rna_names:",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_protein_correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_protein_correspondence = np.array(rna_protein_correspondence)\nprint(f\"Found {len(rna_protein_correspondence)} RNA-protein correspondences\")\n# %%\nRNA_shared = adata_RNA[:, rna_protein_correspondence[:, 0]].copy()\nADT_shared = adata_ADT[:, rna_protein_correspondence[:, 1]].copy()\nRNA_shared.var[\"feature_name\"] = RNA_shared.var.index.values\nADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "RNA_shared",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "RNA_shared = adata_RNA[:, rna_protein_correspondence[:, 0]].copy()\nADT_shared = adata_ADT[:, rna_protein_correspondence[:, 1]].copy()\nRNA_shared.var[\"feature_name\"] = RNA_shared.var.index.values\nADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%\nRNA_unshared = adata_RNA[\n    :, sorted(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n].copy()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "ADT_shared",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "ADT_shared = adata_ADT[:, rna_protein_correspondence[:, 1]].copy()\nRNA_shared.var[\"feature_name\"] = RNA_shared.var.index.values\nADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%\nRNA_unshared = adata_RNA[\n    :, sorted(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n].copy()\nADT_unshared = adata_ADT[",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "RNA_shared.var[\"feature_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "RNA_shared.var[\"feature_name\"] = RNA_shared.var.index.values\nADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%\nRNA_unshared = adata_RNA[\n    :, sorted(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n].copy()\nADT_unshared = adata_ADT[\n    :, sorted(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "ADT_shared.var[\"feature_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "ADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%\nRNA_unshared = adata_RNA[\n    :, sorted(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n].copy()\nADT_unshared = adata_ADT[\n    :, sorted(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))\n].copy()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "RNA_unshared",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "RNA_unshared = adata_RNA[\n    :, sorted(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n].copy()\nADT_unshared = adata_ADT[\n    :, sorted(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))\n].copy()\nprint(f\"RNA_unshared shape: {RNA_unshared.shape}\")\nprint(f\"RNA_unshared: {RNA_unshared}\")\n# Use raw counts for HVG selection (seurat_v3 requires counts)\nif \"counts\" in RNA_unshared.layers:",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "ADT_unshared",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "ADT_unshared = adata_ADT[\n    :, sorted(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))\n].copy()\nprint(f\"RNA_unshared shape: {RNA_unshared.shape}\")\nprint(f\"RNA_unshared: {RNA_unshared}\")\n# Use raw counts for HVG selection (seurat_v3 requires counts)\nif \"counts\" in RNA_unshared.layers:\n    RNA_unshared.X = RNA_unshared.layers[\"counts\"].copy()\n    print(\"Using raw counts from layers['counts'] for HVG selection\")\n# Skip HVG selection if less than 4000 cells",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "RNA_unshared.var[\"feature_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "RNA_unshared.var[\"feature_name\"] = RNA_unshared.var.index.values\nADT_unshared.var[\"feature_name\"] = ADT_unshared.var.index.values\n# %% [markdown]\n# ## Normalization\n# %%\nRNA_counts = RNA_shared.X.sum(axis=1)\nADT_counts = ADT_shared.X.sum(axis=1)\ntarget_sum = np.maximum(np.median(RNA_counts.copy()), 20)\nsc.pp.normalize_total(RNA_shared, target_sum=target_sum)\nsc.pp.log1p(RNA_shared)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "ADT_unshared.var[\"feature_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "ADT_unshared.var[\"feature_name\"] = ADT_unshared.var.index.values\n# %% [markdown]\n# ## Normalization\n# %%\nRNA_counts = RNA_shared.X.sum(axis=1)\nADT_counts = ADT_shared.X.sum(axis=1)\ntarget_sum = np.maximum(np.median(RNA_counts.copy()), 20)\nsc.pp.normalize_total(RNA_shared, target_sum=target_sum)\nsc.pp.log1p(RNA_shared)\nsc.pp.normalize_total(ADT_shared, target_sum=target_sum)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "RNA_counts",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "RNA_counts = RNA_shared.X.sum(axis=1)\nADT_counts = ADT_shared.X.sum(axis=1)\ntarget_sum = np.maximum(np.median(RNA_counts.copy()), 20)\nsc.pp.normalize_total(RNA_shared, target_sum=target_sum)\nsc.pp.log1p(RNA_shared)\nsc.pp.normalize_total(ADT_shared, target_sum=target_sum)\nsc.pp.log1p(ADT_shared)\nsc.pp.normalize_total(RNA_unshared)\nsc.pp.log1p(RNA_unshared)\nsc.pp.normalize_total(ADT_unshared)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "ADT_counts",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "ADT_counts = ADT_shared.X.sum(axis=1)\ntarget_sum = np.maximum(np.median(RNA_counts.copy()), 20)\nsc.pp.normalize_total(RNA_shared, target_sum=target_sum)\nsc.pp.log1p(RNA_shared)\nsc.pp.normalize_total(ADT_shared, target_sum=target_sum)\nsc.pp.log1p(ADT_shared)\nsc.pp.normalize_total(RNA_unshared)\nsc.pp.log1p(RNA_unshared)\nsc.pp.normalize_total(ADT_unshared)\nsc.pp.log1p(ADT_unshared)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "target_sum",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "target_sum = np.maximum(np.median(RNA_counts.copy()), 20)\nsc.pp.normalize_total(RNA_shared, target_sum=target_sum)\nsc.pp.log1p(RNA_shared)\nsc.pp.normalize_total(ADT_shared, target_sum=target_sum)\nsc.pp.log1p(ADT_shared)\nsc.pp.normalize_total(RNA_unshared)\nsc.pp.log1p(RNA_unshared)\nsc.pp.normalize_total(ADT_unshared)\nsc.pp.log1p(ADT_unshared)\nadata1 = ad.concat([RNA_shared, RNA_unshared], axis=1)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata1",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata1 = ad.concat([RNA_shared, RNA_unshared], axis=1)\nadata2 = ad.concat([ADT_shared, ADT_unshared], axis=1)\nsc.pp.scale(adata1, max_value=10)\nsc.pp.scale(adata2, max_value=10)\n# plot a umap of subset of cells from adata1 and adata2\n# %% [markdown]\n# ## Running scMODAL\n# %%\nmodel = scmodal.model.Model(model_path=\"./CITE-seq_PBMC\")  # ,training_steps=100)\nmodel.preprocess(adata1, adata2, shared_gene_num=RNA_shared.shape[1])",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata2",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata2 = ad.concat([ADT_shared, ADT_unshared], axis=1)\nsc.pp.scale(adata1, max_value=10)\nsc.pp.scale(adata2, max_value=10)\n# plot a umap of subset of cells from adata1 and adata2\n# %% [markdown]\n# ## Running scMODAL\n# %%\nmodel = scmodal.model.Model(model_path=\"./CITE-seq_PBMC\")  # ,training_steps=100)\nmodel.preprocess(adata1, adata2, shared_gene_num=RNA_shared.shape[1])\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "model = scmodal.model.Model(model_path=\"./CITE-seq_PBMC\")  # ,training_steps=100)\nmodel.preprocess(adata1, adata2, shared_gene_num=RNA_shared.shape[1])\n# %%\nmodel.train()\nmodel.eval()\n# %%\nadata_integrated = ad.AnnData(X=model.latent)\nadata_integrated.obs = pd.concat([adata_RNA.obs, adata_ADT.obs])\nadata_integrated.obs[\"modality\"] = [\"RNA\"] * adata_RNA.shape[0] + [\"ADT\"] * adata_ADT.shape[0]\nscmodal.utils.compute_umap(adata_integrated)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_integrated",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_integrated = ad.AnnData(X=model.latent)\nadata_integrated.obs = pd.concat([adata_RNA.obs, adata_ADT.obs])\nadata_integrated.obs[\"modality\"] = [\"RNA\"] * adata_RNA.shape[0] + [\"ADT\"] * adata_ADT.shape[0]\nscmodal.utils.compute_umap(adata_integrated)\n# %%\nsc.pl.umap(adata_integrated, color=[\"modality\", \"celltype.l2\"])\n# %%\nadata_integrated\n# %%\n# %% [markdown]",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_integrated.obs",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_integrated.obs = pd.concat([adata_RNA.obs, adata_ADT.obs])\nadata_integrated.obs[\"modality\"] = [\"RNA\"] * adata_RNA.shape[0] + [\"ADT\"] * adata_ADT.shape[0]\nscmodal.utils.compute_umap(adata_integrated)\n# %%\nsc.pl.umap(adata_integrated, color=[\"modality\", \"celltype.l2\"])\n# %%\nadata_integrated\n# %%\n# %% [markdown]\n# ## benchmarking",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "adata_integrated.obs[\"modality\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "adata_integrated.obs[\"modality\"] = [\"RNA\"] * adata_RNA.shape[0] + [\"ADT\"] * adata_ADT.shape[0]\nscmodal.utils.compute_umap(adata_integrated)\n# %%\nsc.pl.umap(adata_integrated, color=[\"modality\", \"celltype.l2\"])\n# %%\nadata_integrated\n# %%\n# %% [markdown]\n# ## benchmarking\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "dist_mtx",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "dist_mtx = cdist(\n    model.latent[adata1.shape[0] :, :],\n    model.latent[: adata1.shape[0], :],\n    metric=\"euclidean\",\n)  # Transfer labels from RNA to ADT\nmatching = dist_mtx.argsort()[:, :1]\ndf1_labels = adata_RNA.obs[\"celltype.l1\"].values\ndf2_labels = adata_ADT.obs[\"celltype.l1\"].values\nprint(\n    \"Label transfer accuracy for L1: \",",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "matching",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "matching = dist_mtx.argsort()[:, :1]\ndf1_labels = adata_RNA.obs[\"celltype.l1\"].values\ndf2_labels = adata_ADT.obs[\"celltype.l1\"].values\nprint(\n    \"Label transfer accuracy for L1: \",\n    np.sum(df1_labels == df2_labels[matching.reshape(-1)]) / adata_RNA.shape[0],\n)\n# %%\ndist_mtx = cdist(\n    model.latent[adata1.shape[0] :, :],",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "df1_labels",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "df1_labels = adata_RNA.obs[\"celltype.l1\"].values\ndf2_labels = adata_ADT.obs[\"celltype.l1\"].values\nprint(\n    \"Label transfer accuracy for L1: \",\n    np.sum(df1_labels == df2_labels[matching.reshape(-1)]) / adata_RNA.shape[0],\n)\n# %%\ndist_mtx = cdist(\n    model.latent[adata1.shape[0] :, :],\n    model.latent[: adata1.shape[0], :],",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "df2_labels",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "df2_labels = adata_ADT.obs[\"celltype.l1\"].values\nprint(\n    \"Label transfer accuracy for L1: \",\n    np.sum(df1_labels == df2_labels[matching.reshape(-1)]) / adata_RNA.shape[0],\n)\n# %%\ndist_mtx = cdist(\n    model.latent[adata1.shape[0] :, :],\n    model.latent[: adata1.shape[0], :],\n    metric=\"euclidean\",",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "dist_mtx",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "dist_mtx = cdist(\n    model.latent[adata1.shape[0] :, :],\n    model.latent[: adata1.shape[0], :],\n    metric=\"euclidean\",\n)\nmatching = dist_mtx.argsort()[:, :1]\ndf1_labels = adata_RNA.obs[\"celltype.l2\"].values\ndf2_labels = adata_ADT.obs[\"celltype.l2\"].values\nprint(\n    \"Label transfer accuracy for L2: \",",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "matching",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "matching = dist_mtx.argsort()[:, :1]\ndf1_labels = adata_RNA.obs[\"celltype.l2\"].values\ndf2_labels = adata_ADT.obs[\"celltype.l2\"].values\nprint(\n    \"Label transfer accuracy for L2: \",\n    np.sum(df1_labels == df2_labels[matching.reshape(-1)]) / adata_RNA.shape[0],\n)\n# %%\nadata_integrated.obs[\"modality\"].value_counts()\n# %% [markdown]",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "df1_labels",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "df1_labels = adata_RNA.obs[\"celltype.l2\"].values\ndf2_labels = adata_ADT.obs[\"celltype.l2\"].values\nprint(\n    \"Label transfer accuracy for L2: \",\n    np.sum(df1_labels == df2_labels[matching.reshape(-1)]) / adata_RNA.shape[0],\n)\n# %%\nadata_integrated.obs[\"modality\"].value_counts()\n# %% [markdown]\n# ## Visualize latent space",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "df2_labels",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "df2_labels = adata_ADT.obs[\"celltype.l2\"].values\nprint(\n    \"Label transfer accuracy for L2: \",\n    np.sum(df1_labels == df2_labels[matching.reshape(-1)]) / adata_RNA.shape[0],\n)\n# %%\nadata_integrated.obs[\"modality\"].value_counts()\n# %% [markdown]\n# ## Visualize latent space\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "dim_use",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "dim_use = min(15, model.latent.shape[1])  # use first 15 dimensions or all if less\nlatent_adata = ad.AnnData(\n    np.concatenate(\n        (model.latent[: adata1.shape[0], :dim_use], model.latent[adata1.shape[0] :, :dim_use]),\n        axis=0,\n    ),\n    dtype=np.float32,\n)\nlatent_adata.obs[\"data_type\"] = [\"RNA\"] * adata_RNA.shape[0] + [\"Protein\"] * adata_ADT.shape[0]\nlatent_adata.obs[\"celltype.l1\"] = list(adata_RNA.obs[\"celltype.l1\"]) + list(",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "latent_adata",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "latent_adata = ad.AnnData(\n    np.concatenate(\n        (model.latent[: adata1.shape[0], :dim_use], model.latent[adata1.shape[0] :, :dim_use]),\n        axis=0,\n    ),\n    dtype=np.float32,\n)\nlatent_adata.obs[\"data_type\"] = [\"RNA\"] * adata_RNA.shape[0] + [\"Protein\"] * adata_ADT.shape[0]\nlatent_adata.obs[\"celltype.l1\"] = list(adata_RNA.obs[\"celltype.l1\"]) + list(\n    adata_ADT.obs[\"celltype.l1\"]",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "latent_adata.obs[\"data_type\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "latent_adata.obs[\"data_type\"] = [\"RNA\"] * adata_RNA.shape[0] + [\"Protein\"] * adata_ADT.shape[0]\nlatent_adata.obs[\"celltype.l1\"] = list(adata_RNA.obs[\"celltype.l1\"]) + list(\n    adata_ADT.obs[\"celltype.l1\"]\n)\nlatent_adata.obs[\"celltype.l2\"] = list(adata_RNA.obs[\"celltype.l2\"]) + list(\n    adata_ADT.obs[\"celltype.l2\"]\n)\n# %%\n# Compute UMAP on latent space\nsc.pp.neighbors(latent_adata, n_neighbors=15)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "latent_adata.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "latent_adata.obs[\"celltype.l1\"] = list(adata_RNA.obs[\"celltype.l1\"]) + list(\n    adata_ADT.obs[\"celltype.l1\"]\n)\nlatent_adata.obs[\"celltype.l2\"] = list(adata_RNA.obs[\"celltype.l2\"]) + list(\n    adata_ADT.obs[\"celltype.l2\"]\n)\n# %%\n# Compute UMAP on latent space\nsc.pp.neighbors(latent_adata, n_neighbors=15)\nsc.tl.umap(latent_adata)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "latent_adata.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "latent_adata.obs[\"celltype.l2\"] = list(adata_RNA.obs[\"celltype.l2\"]) + list(\n    adata_ADT.obs[\"celltype.l2\"]\n)\n# %%\n# Compute UMAP on latent space\nsc.pp.neighbors(latent_adata, n_neighbors=15)\nsc.tl.umap(latent_adata)\nsc.pl.umap(latent_adata, color=\"data_type\", title=\"scMODAL Latent Space - Modality\")\n# %%\n# Plot by cell types",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_latent",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_latent = model.latent[: adata1.shape[0], :]\nprotein_latent = model.latent[adata1.shape[0] :, :]\n# %%\n# Create RNA AnnData with original data and latent embedding\nrna_adata_output = ad.AnnData(X=adata_RNA.X.copy())\nrna_adata_output.obs = adata_RNA.obs.copy()\nrna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_latent",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_latent = model.latent[adata1.shape[0] :, :]\n# %%\n# Create RNA AnnData with original data and latent embedding\nrna_adata_output = ad.AnnData(X=adata_RNA.X.copy())\nrna_adata_output.obs = adata_RNA.obs.copy()\nrna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output = ad.AnnData(X=adata_RNA.X.copy())\nrna_adata_output.obs = adata_RNA.obs.copy()\nrna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"tissue\"] = \"pbmc\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs = adata_RNA.obs.copy()\nrna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"tissue\"] = \"pbmc\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"tissue\"] = \"pbmc\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"batch_indices\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"tissue\"] = \"pbmc\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"n_genes\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"tissue\"] = \"pbmc\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"percent_mito\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"tissue\"] = \"pbmc\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"leiden_subclusters\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"tissue\"] = \"pbmc\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"tissue\"] = \"pbmc\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"tissue\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"tissue\"] = \"pbmc\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"batch\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"minor_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype.l2\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype.l1\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"n_genes_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"pct_counts_mt\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"n_cells\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"mt\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"ribo\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"hb\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"n_cells_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.uns[\"processing_stage\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.uns[\"file_generated_from\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")\n# %%\n# Create Protein AnnData with original data and latent embedding",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")\n# %%\n# Create Protein AnnData with original data and latent embedding\nprotein_adata_output = ad.AnnData(X=adata_ADT.X.copy())\nprotein_adata_output.obs = adata_ADT.obs.copy()\nprotein_adata_output.var = adata_ADT.var.copy()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.layers[\"counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")\n# %%\n# Create Protein AnnData with original data and latent embedding\nprotein_adata_output = ad.AnnData(X=adata_ADT.X.copy())\nprotein_adata_output.obs = adata_ADT.obs.copy()\nprotein_adata_output.var = adata_ADT.var.copy()\nprotein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output = ad.AnnData(X=adata_ADT.X.copy())\nprotein_adata_output.obs = adata_ADT.obs.copy()\nprotein_adata_output.var = adata_ADT.var.copy()\nprotein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"tissue\"] = \"pbmc\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs = adata_ADT.obs.copy()\nprotein_adata_output.var = adata_ADT.var.copy()\nprotein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"tissue\"] = \"pbmc\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.var",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.var = adata_ADT.var.copy()\nprotein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"tissue\"] = \"pbmc\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"batch_indices\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"tissue\"] = \"pbmc\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"percent_mito\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"tissue\"] = \"pbmc\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"leiden_subclusters\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"tissue\"] = \"pbmc\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"tissue\"] = \"pbmc\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"tissue\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"tissue\"] = \"pbmc\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"batch\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"batch\"] = \"scmodal_cite_seq\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"minor_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype.l2\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype.l1\"]\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"n_genes_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nprotein_adata_output.obsm.clear()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.var[\"feature_type\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.uns[\"dataset_name\"] = \"scmodal_cite_seq\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.uns[\"processing_stage\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.uns[\"file_generated_from\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.uns[\"file_generated_from\"] = \"scmodal_cite_seq.py\"\n# obsm fields - clear and add latent\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")\n# %%\n# Save the formatted AnnData objects",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.obsm[\"latent\"] = protein_latent\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")\n# %%\n# Save the formatted AnnData objects\noutput_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.layers[\"counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")\n# %%\n# Save the formatted AnnData objects\noutput_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/scmodal_cite_seq/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/scmodal_cite_seq/7_protein_{timestamp}.h5ad\"",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "output_dir",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "output_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/scmodal_cite_seq/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/scmodal_cite_seq/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/scmodal_cite_seq\", exist_ok=True)\nrna_adata_output.write(rna_output)\nprotein_adata_output.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "timestamp",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/scmodal_cite_seq/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/scmodal_cite_seq/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/scmodal_cite_seq\", exist_ok=True)\nrna_adata_output.write(rna_output)\nprotein_adata_output.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata_output}\")\nprint(f\"\\nprotein_adata: {protein_adata_output}\")",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "rna_output",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "rna_output = f\"{output_dir}/scmodal_cite_seq/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/scmodal_cite_seq/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/scmodal_cite_seq\", exist_ok=True)\nrna_adata_output.write(rna_output)\nprotein_adata_output.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata_output}\")\nprint(f\"\\nprotein_adata: {protein_adata_output}\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "protein_output",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_cite_seq",
        "description": "model_comparison.model_scmodal_dataset_cite_seq",
        "peekOfCode": "protein_output = f\"{output_dir}/scmodal_cite_seq/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/scmodal_cite_seq\", exist_ok=True)\nrna_adata_output.write(rna_output)\nprotein_adata_output.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata_output}\")\nprint(f\"\\nprotein_adata: {protein_adata_output}\")\n# %%\n# Display summary",
        "detail": "model_comparison.model_scmodal_dataset_cite_seq",
        "documentation": {}
    },
    {
        "label": "plt.rcParams[\"figure.figsize\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "plt.rcParams[\"figure.figsize\"] = (6, 4)\nwarnings.filterwarnings(\"ignore\")\nif here().parent.name == \"notebooks\":\n    os.chdir(\"../../\")\nROOT = here().parent\nTHIS_DIR = here()\nprint(f\"ROOT: {ROOT}\")\nprint(f\"THIS_DIR: {THIS_DIR}\")\n# Update sys.path and cwd\nsys.path.append(str(ROOT))",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "ROOT = here().parent\nTHIS_DIR = here()\nprint(f\"ROOT: {ROOT}\")\nprint(f\"THIS_DIR: {THIS_DIR}\")\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nsys.path.append(str(THIS_DIR / \"scMODAL_main\"))\nos.chdir(str(ROOT))\nprint(f\"Working directory: {os.getcwd()}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "THIS_DIR",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "THIS_DIR = here()\nprint(f\"ROOT: {ROOT}\")\nprint(f\"THIS_DIR: {THIS_DIR}\")\n# Update sys.path and cwd\nsys.path.append(str(ROOT))\nsys.path.append(str(THIS_DIR))\nsys.path.append(str(THIS_DIR / \"scMODAL_main\"))\nos.chdir(str(ROOT))\nprint(f\"Working directory: {os.getcwd()}\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "dataset_name",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "dataset_name = \"tonsil\"\nprint(\"Loading tonsil CODEX + RNA-seq data from h5ad files...\")\nrna_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"rna\", exact_step=1, dataset_name=dataset_name\n)\nprint(f\"RNA file: {str(rna_file)}\")\nprotein_file = get_latest_file(\n    \"ARCADIA/processed_data\",\n    \"protein\",\n    exact_step=1,",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_file",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_file = get_latest_file(\n    \"ARCADIA/processed_data\", \"rna\", exact_step=1, dataset_name=dataset_name\n)\nprint(f\"RNA file: {str(rna_file)}\")\nprotein_file = get_latest_file(\n    \"ARCADIA/processed_data\",\n    \"protein\",\n    exact_step=1,\n    dataset_name=dataset_name,\n)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_file",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_file = get_latest_file(\n    \"ARCADIA/processed_data\",\n    \"protein\",\n    exact_step=1,\n    dataset_name=dataset_name,\n)\nprint(f\"Protein file: {str(protein_file)}\")\nadata_RNA = sc.read(str(rna_file))\nadata_ADT = sc.read(str(protein_file))\n# Use raw counts from layers",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_RNA",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_RNA = sc.read(str(rna_file))\nadata_ADT = sc.read(str(protein_file))\n# Use raw counts from layers\nif \"counts\" in adata_RNA.layers:\n    adata_RNA.X = adata_RNA.layers[\"counts\"].copy()\n    print(\"Using raw counts from adata_RNA.layers['counts']\")\nif \"counts\" in adata_ADT.layers:\n    adata_ADT.X = adata_ADT.layers[\"counts\"].copy()\n    print(\"Using raw counts from adata_ADT.layers['counts']\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_ADT",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_ADT = sc.read(str(protein_file))\n# Use raw counts from layers\nif \"counts\" in adata_RNA.layers:\n    adata_RNA.X = adata_RNA.layers[\"counts\"].copy()\n    print(\"Using raw counts from adata_RNA.layers['counts']\")\nif \"counts\" in adata_ADT.layers:\n    adata_ADT.X = adata_ADT.layers[\"counts\"].copy()\n    print(\"Using raw counts from adata_ADT.layers['counts']\")\n# %%\n# Cell type labels - already in obs from preprocessing",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_RNA.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"cell_types\"]\nadata_RNA.obs[\"celltype\"] = adata_RNA.obs[\"cell_types\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs.get(\"minor_cell_types\", adata_RNA.obs[\"cell_types\"])\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs.get(\"minor_cell_types\", adata_ADT.obs[\"cell_types\"])\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# Add celltype.l1 and celltype.l2 for consistency\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"celltype\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_RNA.obs[\"celltype\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_RNA.obs[\"celltype\"] = adata_RNA.obs[\"cell_types\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs.get(\"minor_cell_types\", adata_RNA.obs[\"cell_types\"])\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs.get(\"minor_cell_types\", adata_ADT.obs[\"cell_types\"])\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# Add celltype.l1 and celltype.l2 for consistency\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"celltype\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"celltype\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_RNA.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs.get(\"minor_cell_types\", adata_RNA.obs[\"cell_types\"])\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs.get(\"minor_cell_types\", adata_ADT.obs[\"cell_types\"])\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# Add celltype.l1 and celltype.l2 for consistency\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"celltype\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"celltype\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_ADT.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs.get(\"minor_cell_types\", adata_ADT.obs[\"cell_types\"])\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# Add celltype.l1 and celltype.l2 for consistency\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"celltype\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"celltype\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_ADT.obs[\"celltype\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_ADT.obs[\"celltype\"] = adata_ADT.obs[\"cell_types\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs.get(\"minor_cell_types\", adata_ADT.obs[\"cell_types\"])\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# Add celltype.l1 and celltype.l2 for consistency\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"celltype\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"celltype\"]\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_ADT.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs.get(\"minor_cell_types\", adata_ADT.obs[\"cell_types\"])\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# Add celltype.l1 and celltype.l2 for consistency\nadata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"celltype\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"celltype\"]\n# %%\n# Note: For tonsil dataset, RNA and protein cells are from different samples",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_RNA.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_RNA.obs[\"celltype.l1\"] = adata_RNA.obs[\"celltype\"]\nadata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"celltype\"]\n# %%\n# Note: For tonsil dataset, RNA and protein cells are from different samples\n# (not matched by barcode like cite_seq), so we work with all cells from both datasets\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_RNA.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_RNA.obs[\"celltype.l2\"] = adata_RNA.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"celltype\"]\n# %%\n# Note: For tonsil dataset, RNA and protein cells are from different samples\n# (not matched by barcode like cite_seq), so we work with all cells from both datasets\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%\n# Build RNA-protein correspondence (similar to MaxFuse script)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_ADT.obs[\"celltype.l1\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_ADT.obs[\"celltype.l1\"] = adata_ADT.obs[\"celltype\"]\nadata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"celltype\"]\n# %%\n# Note: For tonsil dataset, RNA and protein cells are from different samples\n# (not matched by barcode like cite_seq), so we work with all cells from both datasets\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%\n# Build RNA-protein correspondence (similar to MaxFuse script)\n# Create mapping dictionaries for case-insensitive matching",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_ADT.obs[\"celltype.l2\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_ADT.obs[\"celltype.l2\"] = adata_ADT.obs[\"celltype\"]\n# %%\n# Note: For tonsil dataset, RNA and protein cells are from different samples\n# (not matched by barcode like cite_seq), so we work with all cells from both datasets\nprint(f\"RNA dataset: {adata_RNA.shape[0]} cells\")\nprint(f\"Protein dataset: {adata_ADT.shape[0]} cells\")\n# %%\n# Build RNA-protein correspondence (similar to MaxFuse script)\n# Create mapping dictionaries for case-insensitive matching\nrna_gene_mapping = {gene.upper(): gene for gene in adata_RNA.var_names}",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_gene_mapping",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_gene_mapping = {gene.upper(): gene for gene in adata_RNA.var_names}\nprotein_name_mapping = {prot.upper(): prot for prot in adata_ADT.var_names}\n# Load correspondence file if it exists, otherwise use direct matching\ncorrespondence_file = \"ARCADIA/raw_datasets/tonsil/protein_gene_conversion.csv\"\nrna_protein_correspondence = []\nif os.path.exists(correspondence_file):\n    correspondence = pd.read_csv(correspondence_file)\n    correspondence[\"Protein name\"] = correspondence[\"Protein name\"].replace(\n        to_replace={\"CD11a-CD18\": \"CD11a/CD18\", \"CD66a-c-e\": \"CD66a/c/e\"}\n    )",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_name_mapping",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_name_mapping = {prot.upper(): prot for prot in adata_ADT.var_names}\n# Load correspondence file if it exists, otherwise use direct matching\ncorrespondence_file = \"ARCADIA/raw_datasets/tonsil/protein_gene_conversion.csv\"\nrna_protein_correspondence = []\nif os.path.exists(correspondence_file):\n    correspondence = pd.read_csv(correspondence_file)\n    correspondence[\"Protein name\"] = correspondence[\"Protein name\"].replace(\n        to_replace={\"CD11a-CD18\": \"CD11a/CD18\", \"CD66a-c-e\": \"CD66a/c/e\"}\n    )\n    print(f\"Loaded correspondence file: {correspondence_file}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "correspondence_file",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "correspondence_file = \"ARCADIA/raw_datasets/tonsil/protein_gene_conversion.csv\"\nrna_protein_correspondence = []\nif os.path.exists(correspondence_file):\n    correspondence = pd.read_csv(correspondence_file)\n    correspondence[\"Protein name\"] = correspondence[\"Protein name\"].replace(\n        to_replace={\"CD11a-CD18\": \"CD11a/CD18\", \"CD66a-c-e\": \"CD66a/c/e\"}\n    )\n    print(f\"Loaded correspondence file: {correspondence_file}\")\n    print(correspondence.head())\n    for i in range(correspondence.shape[0]):",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_protein_correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_protein_correspondence = []\nif os.path.exists(correspondence_file):\n    correspondence = pd.read_csv(correspondence_file)\n    correspondence[\"Protein name\"] = correspondence[\"Protein name\"].replace(\n        to_replace={\"CD11a-CD18\": \"CD11a/CD18\", \"CD66a-c-e\": \"CD66a/c/e\"}\n    )\n    print(f\"Loaded correspondence file: {correspondence_file}\")\n    print(correspondence.head())\n    for i in range(correspondence.shape[0]):\n        curr_protein_name, curr_rna_names = correspondence.iloc[i]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_protein_correspondence",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_protein_correspondence = np.array(rna_protein_correspondence)\nprint(f\"Found {len(rna_protein_correspondence)} RNA-protein correspondences\")\n# %%\n# Create shared features datasets\nRNA_shared = adata_RNA[:, rna_protein_correspondence[:, 0]].copy()\nADT_shared = adata_ADT[:, rna_protein_correspondence[:, 1]].copy()\nRNA_shared.var[\"feature_name\"] = RNA_shared.var.index.values\nADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "RNA_shared",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "RNA_shared = adata_RNA[:, rna_protein_correspondence[:, 0]].copy()\nADT_shared = adata_ADT[:, rna_protein_correspondence[:, 1]].copy()\nRNA_shared.var[\"feature_name\"] = RNA_shared.var.index.values\nADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%\n# Create unshared features datasets\nrna_unshared_genes = list(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n# adt_unshared_proteins = list(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "ADT_shared",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "ADT_shared = adata_ADT[:, rna_protein_correspondence[:, 1]].copy()\nRNA_shared.var[\"feature_name\"] = RNA_shared.var.index.values\nADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%\n# Create unshared features datasets\nrna_unshared_genes = list(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n# adt_unshared_proteins = list(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))\nRNA_unshared = adata_RNA[:, sorted(rna_unshared_genes)].copy()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "RNA_shared.var[\"feature_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "RNA_shared.var[\"feature_name\"] = RNA_shared.var.index.values\nADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%\n# Create unshared features datasets\nrna_unshared_genes = list(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n# adt_unshared_proteins = list(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))\nRNA_unshared = adata_RNA[:, sorted(rna_unshared_genes)].copy()\n# ADT_unshared = adata_ADT[:, sorted(adt_unshared_proteins)].copy()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "ADT_shared.var[\"feature_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "ADT_shared.var[\"feature_name\"] = ADT_shared.var.index.values\nRNA_shared.var_names_make_unique()\nADT_shared.var_names_make_unique()\n# %%\n# Create unshared features datasets\nrna_unshared_genes = list(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n# adt_unshared_proteins = list(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))\nRNA_unshared = adata_RNA[:, sorted(rna_unshared_genes)].copy()\n# ADT_unshared = adata_ADT[:, sorted(adt_unshared_proteins)].copy()\n# Select highly variable genes for RNA unshared",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_unshared_genes",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_unshared_genes = list(set(adata_RNA.var.index) - set(rna_protein_correspondence[:, 0]))\n# adt_unshared_proteins = list(set(adata_ADT.var.index) - set(rna_protein_correspondence[:, 1]))\nRNA_unshared = adata_RNA[:, sorted(rna_unshared_genes)].copy()\n# ADT_unshared = adata_ADT[:, sorted(adt_unshared_proteins)].copy()\n# Select highly variable genes for RNA unshared\n# Convert sparse to dense if needed\nif issparse(RNA_unshared.X):\n    RNA_unshared.X = RNA_unshared.X.toarray()\n# Use raw counts for HVG selection (seurat_v3 requires counts)\nif \"counts\" in RNA_unshared.layers:",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "RNA_unshared",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "RNA_unshared = adata_RNA[:, sorted(rna_unshared_genes)].copy()\n# ADT_unshared = adata_ADT[:, sorted(adt_unshared_proteins)].copy()\n# Select highly variable genes for RNA unshared\n# Convert sparse to dense if needed\nif issparse(RNA_unshared.X):\n    RNA_unshared.X = RNA_unshared.X.toarray()\n# Use raw counts for HVG selection (seurat_v3 requires counts)\nif \"counts\" in RNA_unshared.layers:\n    RNA_unshared.X = RNA_unshared.layers[\"counts\"].copy()\n    print(\"Using raw counts from layers['counts'] for HVG selection\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "n_top_genes",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "n_top_genes = min(1000, RNA_unshared.n_vars)\nif RNA_unshared.n_obs >= 500:\n    try:\n        sc.pp.highly_variable_genes(RNA_unshared, flavor=\"seurat_v3\", n_top_genes=n_top_genes)\n    except (ValueError, RuntimeError) as e:\n        print(f\"Warning: seurat_v3 failed ({e}), falling back to seurat flavor\")\n        sc.pp.highly_variable_genes(RNA_unshared, flavor=\"seurat\", n_top_genes=n_top_genes)\nelse:\n    print(f\"Warning: Only {RNA_unshared.n_obs} cells, using seurat flavor instead of seurat_v3\")\n    sc.pp.highly_variable_genes(RNA_unshared, flavor=\"seurat\", n_top_genes=n_top_genes)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "RNA_unshared",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "RNA_unshared = RNA_unshared[:, RNA_unshared.var.highly_variable].copy()\nRNA_unshared.var[\"feature_name\"] = RNA_unshared.var.index.values\n# %%\n# Convert sparse matrices to dense for scMODAL\nif issparse(RNA_shared.X):\n    RNA_shared.X = RNA_shared.X.toarray()\nif issparse(ADT_shared.X):\n    ADT_shared.X = ADT_shared.X.toarray()\nif issparse(RNA_unshared.X):\n    RNA_unshared.X = RNA_unshared.X.toarray()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "RNA_unshared.var[\"feature_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "RNA_unshared.var[\"feature_name\"] = RNA_unshared.var.index.values\n# %%\n# Convert sparse matrices to dense for scMODAL\nif issparse(RNA_shared.X):\n    RNA_shared.X = RNA_shared.X.toarray()\nif issparse(ADT_shared.X):\n    ADT_shared.X = ADT_shared.X.toarray()\nif issparse(RNA_unshared.X):\n    RNA_unshared.X = RNA_unshared.X.toarray()\nprint(f\"RNA_shared shape: {RNA_shared.shape}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "target_sum",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "target_sum = np.median((np.exp(ADT_shared.X) - 1).sum(axis=1))\n# Normalize RNA_shared to match CODEX distribution\nsc.pp.normalize_total(RNA_shared, target_sum=target_sum)\nsc.pp.log1p(RNA_shared)\n# Normalize unshared features\nsc.pp.normalize_total(RNA_unshared)\nsc.pp.log1p(RNA_unshared)\n# Concatenate shared and unshared features\nadata1 = ad.concat([RNA_shared, RNA_unshared], axis=1)\nadata1.obs[\"celltype\"] = RNA_shared.obs[\"celltype\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata1",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata1 = ad.concat([RNA_shared, RNA_unshared], axis=1)\nadata1.obs[\"celltype\"] = RNA_shared.obs[\"celltype\"]\n# CODEX data do not contain unlinked features with RNA data\nadata2 = ADT_shared.copy()\nadata2.obs[\"celltype\"] = ADT_shared.obs[\"celltype\"]\n# Scale\nsc.pp.scale(adata1, max_value=10)\nsc.pp.scale(adata2, max_value=10)\nprint(f\"adata1 (RNA) shape: {adata1.shape}\")\nprint(f\"adata2 (ADT) shape: {adata2.shape}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata1.obs[\"celltype\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata1.obs[\"celltype\"] = RNA_shared.obs[\"celltype\"]\n# CODEX data do not contain unlinked features with RNA data\nadata2 = ADT_shared.copy()\nadata2.obs[\"celltype\"] = ADT_shared.obs[\"celltype\"]\n# Scale\nsc.pp.scale(adata1, max_value=10)\nsc.pp.scale(adata2, max_value=10)\nprint(f\"adata1 (RNA) shape: {adata1.shape}\")\nprint(f\"adata2 (ADT) shape: {adata2.shape}\")\n# %% [markdown]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata2",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata2 = ADT_shared.copy()\nadata2.obs[\"celltype\"] = ADT_shared.obs[\"celltype\"]\n# Scale\nsc.pp.scale(adata1, max_value=10)\nsc.pp.scale(adata2, max_value=10)\nprint(f\"adata1 (RNA) shape: {adata1.shape}\")\nprint(f\"adata2 (ADT) shape: {adata2.shape}\")\n# %% [markdown]\n# ## Running scMODAL\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata2.obs[\"celltype\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata2.obs[\"celltype\"] = ADT_shared.obs[\"celltype\"]\n# Scale\nsc.pp.scale(adata1, max_value=10)\nsc.pp.scale(adata2, max_value=10)\nprint(f\"adata1 (RNA) shape: {adata1.shape}\")\nprint(f\"adata2 (ADT) shape: {adata2.shape}\")\n# %% [markdown]\n# ## Running scMODAL\n# %%\n# Train model following original tutorial approach with explicit hyperparameters",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "model = scmodal.model.Model(\n    training_steps=10000, lambdaMNN=5, lambdaGAN=0.5, model_path=\"./scMODAL_tonsil\"\n)\n# Use integrate_datasets_feats with paired MNN inputs for shared features\nmodel.integrate_datasets_feats(\n    input_feats=[adata2.X, adata1.X],\n    paired_input_MNN=[[adata2.X[:, : RNA_shared.shape[1]], adata1.X[:, : RNA_shared.shape[1]]]],\n)\n# %%\n# Create integrated AnnData",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_integrated",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_integrated = ad.AnnData(X=model.latent)\nadata_integrated.obs = pd.concat([adata_ADT.obs, adata_RNA.obs])\nadata_integrated.obs[\"modality\"] = [\"CODEX\"] * adata_ADT.shape[0] + [\"RNA\"] * adata_RNA.shape[0]\nscmodal.utils.compute_umap(adata_integrated)\n# %%\nsc.pl.umap(adata_integrated, color=[\"modality\", \"celltype\"])\n# %%\nsc.pl.umap(adata_integrated[adata_integrated.obs[\"modality\"] == \"RNA\"], color=[\"celltype\"])\nsc.pl.umap(adata_integrated[adata_integrated.obs[\"modality\"] == \"CODEX\"], color=[\"celltype\"])\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_integrated.obs",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_integrated.obs = pd.concat([adata_ADT.obs, adata_RNA.obs])\nadata_integrated.obs[\"modality\"] = [\"CODEX\"] * adata_ADT.shape[0] + [\"RNA\"] * adata_RNA.shape[0]\nscmodal.utils.compute_umap(adata_integrated)\n# %%\nsc.pl.umap(adata_integrated, color=[\"modality\", \"celltype\"])\n# %%\nsc.pl.umap(adata_integrated[adata_integrated.obs[\"modality\"] == \"RNA\"], color=[\"celltype\"])\nsc.pl.umap(adata_integrated[adata_integrated.obs[\"modality\"] == \"CODEX\"], color=[\"celltype\"])\n# %%\nprint(adata_integrated)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "adata_integrated.obs[\"modality\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "adata_integrated.obs[\"modality\"] = [\"CODEX\"] * adata_ADT.shape[0] + [\"RNA\"] * adata_RNA.shape[0]\nscmodal.utils.compute_umap(adata_integrated)\n# %%\nsc.pl.umap(adata_integrated, color=[\"modality\", \"celltype\"])\n# %%\nsc.pl.umap(adata_integrated[adata_integrated.obs[\"modality\"] == \"RNA\"], color=[\"celltype\"])\nsc.pl.umap(adata_integrated[adata_integrated.obs[\"modality\"] == \"CODEX\"], color=[\"celltype\"])\n# %%\nprint(adata_integrated)\n# %% [markdown]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "dist_mtx",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "dist_mtx = cdist(\n    model.latent[: adata2.shape[0], :],  # CODEX\n    model.latent[adata2.shape[0] : (adata1.shape[0] + adata2.shape[0]), :],  # RNA\n    metric=\"euclidean\",\n)\nmatching = dist_mtx.argsort()[:, :1]\ncodex_labels = adata_ADT.obs[\"celltype\"].values\nrna_labels = adata_RNA.obs[\"celltype\"].values\nprint(\n    \"Label transfer accuracy (RNA->CODEX): \",",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "matching",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "matching = dist_mtx.argsort()[:, :1]\ncodex_labels = adata_ADT.obs[\"celltype\"].values\nrna_labels = adata_RNA.obs[\"celltype\"].values\nprint(\n    \"Label transfer accuracy (RNA->CODEX): \",\n    np.sum(codex_labels == rna_labels[matching.reshape(-1)]) / adata_ADT.shape[0],\n)\n# %%\nadata_integrated.obs[\"modality\"].value_counts()\n# %% [markdown]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "codex_labels",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "codex_labels = adata_ADT.obs[\"celltype\"].values\nrna_labels = adata_RNA.obs[\"celltype\"].values\nprint(\n    \"Label transfer accuracy (RNA->CODEX): \",\n    np.sum(codex_labels == rna_labels[matching.reshape(-1)]) / adata_ADT.shape[0],\n)\n# %%\nadata_integrated.obs[\"modality\"].value_counts()\n# %% [markdown]\n# ## Visualize latent space",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_labels",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_labels = adata_RNA.obs[\"celltype\"].values\nprint(\n    \"Label transfer accuracy (RNA->CODEX): \",\n    np.sum(codex_labels == rna_labels[matching.reshape(-1)]) / adata_ADT.shape[0],\n)\n# %%\nadata_integrated.obs[\"modality\"].value_counts()\n# %% [markdown]\n# ## Visualize latent space\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "dim_use",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "dim_use = min(15, model.latent.shape[1])  # use first 15 dimensions or all if less\nlatent_adata = ad.AnnData(\n    np.concatenate(\n        (\n            model.latent[: adata2.shape[0], :dim_use],\n            model.latent[adata2.shape[0] :, :dim_use],\n        ),\n        axis=0,\n    ),\n    dtype=np.float32,",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "latent_adata",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "latent_adata = ad.AnnData(\n    np.concatenate(\n        (\n            model.latent[: adata2.shape[0], :dim_use],\n            model.latent[adata2.shape[0] :, :dim_use],\n        ),\n        axis=0,\n    ),\n    dtype=np.float32,\n)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "latent_adata.obs[\"data_type\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "latent_adata.obs[\"data_type\"] = [\"CODEX\"] * adata_ADT.shape[0] + [\"RNA\"] * adata_RNA.shape[0]\nlatent_adata.obs[\"celltype\"] = list(adata_ADT.obs[\"celltype\"]) + list(adata_RNA.obs[\"celltype\"])\n# %%\n# Compute UMAP on latent space\nsc.pp.neighbors(latent_adata, n_neighbors=15)\nsc.tl.umap(latent_adata)\nsc.pl.umap(latent_adata, color=\"data_type\", title=\"scMODAL Latent Space - Modality (Tonsil)\")\n# %%\n# Plot by cell types\nsc.pl.umap(latent_adata, color=\"celltype\", title=\"scMODAL Latent Space - Cell Types (Tonsil)\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "latent_adata.obs[\"celltype\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "latent_adata.obs[\"celltype\"] = list(adata_ADT.obs[\"celltype\"]) + list(adata_RNA.obs[\"celltype\"])\n# %%\n# Compute UMAP on latent space\nsc.pp.neighbors(latent_adata, n_neighbors=15)\nsc.tl.umap(latent_adata)\nsc.pl.umap(latent_adata, color=\"data_type\", title=\"scMODAL Latent Space - Modality (Tonsil)\")\n# %%\n# Plot by cell types\nsc.pl.umap(latent_adata, color=\"celltype\", title=\"scMODAL Latent Space - Cell Types (Tonsil)\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_latent",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_latent = model.latent[: adata2.shape[0], :]\nrna_latent = model.latent[adata2.shape[0] :, :]\n# %%\n# Create RNA AnnData with original data and latent embedding\nif issparse(adata_RNA.X):\n    adata_RNA.X = adata_RNA.X.toarray()\nrna_adata_output = ad.AnnData(X=adata_RNA.X.copy())\nrna_adata_output.obs = adata_RNA.obs.copy()\nrna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_latent",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_latent = model.latent[adata2.shape[0] :, :]\n# %%\n# Create RNA AnnData with original data and latent embedding\nif issparse(adata_RNA.X):\n    adata_RNA.X = adata_RNA.X.toarray()\nrna_adata_output = ad.AnnData(X=adata_RNA.X.copy())\nrna_adata_output.obs = adata_RNA.obs.copy()\nrna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output = ad.AnnData(X=adata_RNA.X.copy())\nrna_adata_output.obs = adata_RNA.obs.copy()\nrna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"tissue\"] = \"tonsil\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs = adata_RNA.obs.copy()\nrna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"tissue\"] = \"tonsil\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.var = adata_RNA.var.copy()\n# Add metadata fields\nrna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"tissue\"] = \"tonsil\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"batch_indices\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"batch_indices\"] = 0\nrna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"tissue\"] = \"tonsil\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"n_genes\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"n_genes\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"tissue\"] = \"tonsil\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"percent_mito\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"percent_mito\"] = 0\nrna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"tissue\"] = \"tonsil\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"leiden_subclusters\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nrna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"tissue\"] = \"tonsil\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"tissue\"] = \"tonsil\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"tissue\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"tissue\"] = \"tonsil\"\nrna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"batch\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nrna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"minor_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"minor_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"major_cell_types\"] = rna_adata_output.obs[\"celltype\"]\nrna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=1)).flatten()\nrna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"n_genes_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"n_genes_by_counts\"] = (rna_adata_output.X > 0).sum(axis=1)\nrna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"pct_counts_mt\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"pct_counts_mt\"] = 0\nrna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obs[\"index_col\"] = np.arange(rna_adata_output.n_obs)\n# var fields\nrna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"n_cells\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.var[\"n_cells\"] = (rna_adata_output.X > 0).sum(axis=0)\nrna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"mt\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.var[\"mt\"] = False\nrna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"ribo\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.var[\"ribo\"] = False\nrna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"hb\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.var[\"hb\"] = False\nrna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.var[\"total_counts\"] = np.array(rna_adata_output.X.sum(axis=0)).flatten()\nrna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.var[\"n_cells_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.var[\"n_cells_by_counts\"] = (rna_adata_output.X > 0).sum(axis=0)\n# uns fields\nrna_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nrna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.uns[\"processing_stage\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nrna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.uns[\"file_generated_from\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent\nrna_adata_output.obsm.clear()\nrna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")\n# %%\n# Create Protein AnnData with original data and latent embedding",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.obsm[\"latent\"] = rna_latent\n# layers\nrna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")\n# %%\n# Create Protein AnnData with original data and latent embedding\nif issparse(adata_ADT.X):\n    adata_ADT.X = adata_ADT.X.toarray()\nprotein_adata_output = ad.AnnData(X=adata_ADT.X.copy())",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_adata_output.layers[\"counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_adata_output.layers[\"counts\"] = rna_adata_output.X.copy()\nprint(f\"rna_adata_output shape: {rna_adata_output.shape}\")\nprint(f\"rna_adata_output.obs columns: {list(rna_adata_output.obs.columns)}\")\n# %%\n# Create Protein AnnData with original data and latent embedding\nif issparse(adata_ADT.X):\n    adata_ADT.X = adata_ADT.X.toarray()\nprotein_adata_output = ad.AnnData(X=adata_ADT.X.copy())\nprotein_adata_output.obs = adata_ADT.obs.copy()\nprotein_adata_output.var = adata_ADT.var.copy()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output = ad.AnnData(X=adata_ADT.X.copy())\nprotein_adata_output.obs = adata_ADT.obs.copy()\nprotein_adata_output.var = adata_ADT.var.copy()\nprotein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"tissue\"] = \"tonsil\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs = adata_ADT.obs.copy()\nprotein_adata_output.var = adata_ADT.var.copy()\nprotein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"tissue\"] = \"tonsil\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.var",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.var = adata_ADT.var.copy()\nprotein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"tissue\"] = \"tonsil\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"batch_indices\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"batch_indices\"] = 0\nprotein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"tissue\"] = \"tonsil\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates\nprotein_adata_output.obs[\"condition\"] = \"tonsil\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"percent_mito\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"percent_mito\"] = 0\nprotein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"tissue\"] = \"tonsil\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates\nprotein_adata_output.obs[\"condition\"] = \"tonsil\"\nprotein_adata_output.obs[\"Image\"] = \"tonsil_image\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"leiden_subclusters\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"leiden_subclusters\"] = \"unknown\"\nprotein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"tissue\"] = \"tonsil\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates\nprotein_adata_output.obs[\"condition\"] = \"tonsil\"\nprotein_adata_output.obs[\"Image\"] = \"tonsil_image\"\nprotein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"tissue\"] = \"tonsil\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates\nprotein_adata_output.obs[\"condition\"] = \"tonsil\"\nprotein_adata_output.obs[\"Image\"] = \"tonsil_image\"\nprotein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"tissue\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"tissue\"] = \"tonsil\"\nprotein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates\nprotein_adata_output.obs[\"condition\"] = \"tonsil\"\nprotein_adata_output.obs[\"Image\"] = \"tonsil_image\"\nprotein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"outlier\"] = False",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"batch\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"batch\"] = \"scmodal_tonsil\"\nprotein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates\nprotein_adata_output.obs[\"condition\"] = \"tonsil\"\nprotein_adata_output.obs[\"Image\"] = \"tonsil_image\"\nprotein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"outlier\"] = False\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"minor_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"minor_cell_types\"] = protein_adata_output.obs[\"celltype\"]\nprotein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates\nprotein_adata_output.obs[\"condition\"] = \"tonsil\"\nprotein_adata_output.obs[\"Image\"] = \"tonsil_image\"\nprotein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"outlier\"] = False\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"major_cell_types\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"major_cell_types\"] = protein_adata_output.obs[\"celltype\"]\n# Add spatial coordinates\nprotein_adata_output.obs[\"condition\"] = \"tonsil\"\nprotein_adata_output.obs[\"Image\"] = \"tonsil_image\"\nprotein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"outlier\"] = False\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(\n    protein_adata_output.obs[\"n_genes_by_counts\"]",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"condition\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"condition\"] = \"tonsil\"\nprotein_adata_output.obs[\"Image\"] = \"tonsil_image\"\nprotein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"outlier\"] = False\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(\n    protein_adata_output.obs[\"n_genes_by_counts\"]\n)\nprotein_adata_output.obs[\"log1p_total_counts\"] = np.log1p(protein_adata_output.obs[\"total_counts\"])",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"Image\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"Image\"] = \"tonsil_image\"\nprotein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"outlier\"] = False\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(\n    protein_adata_output.obs[\"n_genes_by_counts\"]\n)\nprotein_adata_output.obs[\"log1p_total_counts\"] = np.log1p(protein_adata_output.obs[\"total_counts\"])\nprotein_adata_output.obs[\"CN\"] = \"CN_unknown\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"Sample\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"Sample\"] = \"tonsil_sample\"\nprotein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"outlier\"] = False\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(\n    protein_adata_output.obs[\"n_genes_by_counts\"]\n)\nprotein_adata_output.obs[\"log1p_total_counts\"] = np.log1p(protein_adata_output.obs[\"total_counts\"])\nprotein_adata_output.obs[\"CN\"] = \"CN_unknown\"\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"total_counts\"] = protein_adata_output.X.sum(axis=1)\nprotein_adata_output.obs[\"outlier\"] = False\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(\n    protein_adata_output.obs[\"n_genes_by_counts\"]\n)\nprotein_adata_output.obs[\"log1p_total_counts\"] = np.log1p(protein_adata_output.obs[\"total_counts\"])\nprotein_adata_output.obs[\"CN\"] = \"CN_unknown\"\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"outlier\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"outlier\"] = False\nprotein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(\n    protein_adata_output.obs[\"n_genes_by_counts\"]\n)\nprotein_adata_output.obs[\"log1p_total_counts\"] = np.log1p(protein_adata_output.obs[\"total_counts\"])\nprotein_adata_output.obs[\"CN\"] = \"CN_unknown\"\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"n_genes_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"n_genes_by_counts\"] = (protein_adata_output.X > 0).sum(axis=1)\nprotein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(\n    protein_adata_output.obs[\"n_genes_by_counts\"]\n)\nprotein_adata_output.obs[\"log1p_total_counts\"] = np.log1p(protein_adata_output.obs[\"total_counts\"])\nprotein_adata_output.obs[\"CN\"] = \"CN_unknown\"\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"log1p_n_genes_by_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"log1p_n_genes_by_counts\"] = np.log1p(\n    protein_adata_output.obs[\"n_genes_by_counts\"]\n)\nprotein_adata_output.obs[\"log1p_total_counts\"] = np.log1p(protein_adata_output.obs[\"total_counts\"])\nprotein_adata_output.obs[\"CN\"] = \"CN_unknown\"\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"log1p_total_counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"log1p_total_counts\"] = np.log1p(protein_adata_output.obs[\"total_counts\"])\nprotein_adata_output.obs[\"CN\"] = \"CN_unknown\"\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent, keep spatial",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"CN\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"CN\"] = \"CN_unknown\"\nprotein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent, keep spatial\nprotein_adata_output.obsm.clear()",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obs[\"index_col\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obs[\"index_col\"] = np.arange(protein_adata_output.n_obs)\n# var fields\nprotein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent, keep spatial\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.var[\"feature_type\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.var[\"feature_type\"] = \"protein\"\n# uns fields\nprotein_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent, keep spatial\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent\nprotein_adata_output.obsm[\"spatial\"] = adata_ADT.obsm[\"spatial\"].copy()\n# layers",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.uns[\"dataset_name\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.uns[\"dataset_name\"] = \"scmodal_tonsil\"\nprotein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent, keep spatial\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent\nprotein_adata_output.obsm[\"spatial\"] = adata_ADT.obsm[\"spatial\"].copy()\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.uns[\"processing_stage\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.uns[\"processing_stage\"] = \"scmodal_integrated\"\nprotein_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent, keep spatial\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent\nprotein_adata_output.obsm[\"spatial\"] = adata_ADT.obsm[\"spatial\"].copy()\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.uns[\"file_generated_from\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.uns[\"file_generated_from\"] = \"model_scmodal_dataset_tonsil.py\"\n# obsm fields - clear and add latent, keep spatial\nprotein_adata_output.obsm.clear()\nprotein_adata_output.obsm[\"latent\"] = protein_latent\nprotein_adata_output.obsm[\"spatial\"] = adata_ADT.obsm[\"spatial\"].copy()\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obsm[\"latent\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obsm[\"latent\"] = protein_latent\nprotein_adata_output.obsm[\"spatial\"] = adata_ADT.obsm[\"spatial\"].copy()\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")\n# %%\n# Visualize spatial coordinates with cell types\nsc.pl.embedding(protein_adata_output, \"spatial\", color=\"cell_types\")\n# Save the formatted AnnData objects",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.obsm[\"spatial\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.obsm[\"spatial\"] = adata_ADT.obsm[\"spatial\"].copy()\n# layers\nprotein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")\n# %%\n# Visualize spatial coordinates with cell types\nsc.pl.embedding(protein_adata_output, \"spatial\", color=\"cell_types\")\n# Save the formatted AnnData objects\noutput_dir = \"model_comparison/outputs\"",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_adata_output.layers[\"counts\"]",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_adata_output.layers[\"counts\"] = protein_adata_output.X.copy()\nprint(f\"protein_adata_output shape: {protein_adata_output.shape}\")\nprint(f\"protein_adata_output.obs columns: {list(protein_adata_output.obs.columns)}\")\n# %%\n# Visualize spatial coordinates with cell types\nsc.pl.embedding(protein_adata_output, \"spatial\", color=\"cell_types\")\n# Save the formatted AnnData objects\noutput_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "output_dir",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "output_dir = \"model_comparison/outputs\"\nos.makedirs(output_dir, exist_ok=True)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/scmodal_tonsil/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/scmodal_tonsil/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/scmodal_tonsil\", exist_ok=True)\nrna_adata_output.write(rna_output)\nprotein_adata_output.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "timestamp",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\nrna_output = f\"{output_dir}/scmodal_tonsil/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/scmodal_tonsil/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/scmodal_tonsil\", exist_ok=True)\nrna_adata_output.write(rna_output)\nprotein_adata_output.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata_output}\")\nprint(f\"\\nprotein_adata: {protein_adata_output}\")",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "rna_output",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "rna_output = f\"{output_dir}/scmodal_tonsil/7_rna_{timestamp}.h5ad\"\nprotein_output = f\"{output_dir}/scmodal_tonsil/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/scmodal_tonsil\", exist_ok=True)\nrna_adata_output.write(rna_output)\nprotein_adata_output.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata_output}\")\nprint(f\"\\nprotein_adata: {protein_adata_output}\")\n# %%",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "protein_output",
        "kind": 5,
        "importPath": "model_comparison.model_scmodal_dataset_tonsil",
        "description": "model_comparison.model_scmodal_dataset_tonsil",
        "peekOfCode": "protein_output = f\"{output_dir}/scmodal_tonsil/7_protein_{timestamp}.h5ad\"\nos.makedirs(f\"{output_dir}/scmodal_tonsil\", exist_ok=True)\nrna_adata_output.write(rna_output)\nprotein_adata_output.write(protein_output)\nprint(f\"Saved rna_adata to: {rna_output}\")\nprint(f\"Saved protein_adata to: {protein_output}\")\nprint(f\"\\nrna_adata: {rna_adata_output}\")\nprint(f\"\\nprotein_adata: {protein_adata_output}\")\n# %%\n# Display summary",
        "detail": "model_comparison.model_scmodal_dataset_tonsil",
        "documentation": {}
    },
    {
        "label": "compute_confusion_matrix",
        "kind": 2,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "def compute_confusion_matrix(rna_adata, prot_adata, normalize='columns', latent_key=None):\n    \"\"\"\n    Compute confusion matrix for cell type matching between RNA and protein modalities.\n    Args:   \n        rna_adata: AnnData object with RNA data (must have latent representation and cell_types)\n        prot_adata: AnnData object with protein data (must have latent representation and cell_types)\n        normalize: 'columns' to normalize by columns (percentage), None for raw counts\n        latent_key: Key in obsm containing latent representation (e.g., 'X_scVI', 'latent', None to use X)\n    Returns:\n        pd.DataFrame: Confusion matrix (normalized percentages if normalize='columns')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "ct_cf_plot",
        "kind": 2,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "def ct_cf_plot(cm, method_str, f1_score, save_path):\n    # Check if confusion matrix has correct shape\n    if cm.shape[1] == 1:\n        print(f\"Confusion matrix for {method_str} is not in matrix format (shape: {cm.shape})\")\n        return\n    # Expected cell types for cite_seq dataset\n    expected_cell_types = ['B cells','CD4 T','CD8 T','GD/NK T','cDCs']\n    # Ensure all expected cell types are present in rows and columns\n    for ct in expected_cell_types:\n        if ct not in cm.index:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "ct_cf_plot_tonsil",
        "kind": 2,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "def ct_cf_plot_tonsil(cm, method_str, f1_score, save_path):\n    # Check if confusion matrix has correct shape\n    if cm.shape[1] == 1:\n        print(f\"Confusion matrix for {method_str} (tonsil) is not in matrix format (shape: {cm.shape})\")\n        return\n    if cm.shape[0] != 6 or cm.shape[1] != 6:\n        raise ValueError(f\"Confusion matrix for {method_str} (tonsil) has unexpected shape {cm.shape}, expected (6, 6)\")\n    cm.columns = ['B-CD22-CD40', 'B-Ki67', 'CD4 T', 'CD8 T', 'DC', 'Plasma']\n    cm.index = ['B-CD22-CD40', 'B-Ki67', 'CD4 T', 'CD8 T', 'DC', 'Plasma']\n    row_colors = [to_rgb(tonsil_palette[x]) for x in cm.index]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "arcadia_src",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "arcadia_src = script_dir / \"ARCADIA\" / \"src\"\nif str(arcadia_src) not in sys.path:\n    sys.path.insert(0, str(arcadia_src))\nimport pandas as pd\nimport numpy as np\nimport anndata as ad\nimport scanpy as sc\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scipy.stats",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "matplotlib.rcParams['pdf.fonttype']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "matplotlib.rcParams['pdf.fonttype'] = 42\nmatplotlib.rcParams['ps.fonttype'] = 42\nsns.set_style(\"ticks\")\nfrom arcadia.utils.args import find_checkpoint_from_experiment_name\nfrom arcadia.analysis.post_hoc_utils import load_checkpoint_data\nfrom arcadia.analysis.comparison_utils import align_data\nfrom arcadia.training.metrics import calc_dist\nimport os\nimport glob\n# Change to ARCADIA directory for MLflow tracking",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "matplotlib.rcParams['ps.fonttype']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "matplotlib.rcParams['ps.fonttype'] = 42\nsns.set_style(\"ticks\")\nfrom arcadia.utils.args import find_checkpoint_from_experiment_name\nfrom arcadia.analysis.post_hoc_utils import load_checkpoint_data\nfrom arcadia.analysis.comparison_utils import align_data\nfrom arcadia.training.metrics import calc_dist\nimport os\nimport glob\n# Change to ARCADIA directory for MLflow tracking\n# Handle both script and notebook execution",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "arcadia_dir",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "arcadia_dir = script_dir / \"ARCADIA\"\noriginal_cwd = os.getcwd()\nos.chdir(arcadia_dir)\n# Load cite_seq data from latest MLflow checkpoint\ncheckpoint_path, _, _ = find_checkpoint_from_experiment_name(\"cite_seq\")\nsynthetic_rna, synthetic_protein = load_checkpoint_data(Path(checkpoint_path))\n# Restore original directory\nos.chdir(original_cwd)\nprint('synthetic_protein')\nprint(synthetic_protein)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "original_cwd",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "original_cwd = os.getcwd()\nos.chdir(arcadia_dir)\n# Load cite_seq data from latest MLflow checkpoint\ncheckpoint_path, _, _ = find_checkpoint_from_experiment_name(\"cite_seq\")\nsynthetic_rna, synthetic_protein = load_checkpoint_data(Path(checkpoint_path))\n# Restore original directory\nos.chdir(original_cwd)\nprint('synthetic_protein')\nprint(synthetic_protein)\nprint('synthetic_rna')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_protein_scVI",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_protein_scVI = tonsil_protein.obsm['X_scVI'].copy()\ntonsil_rna_scVI = tonsil_rna.obsm['X_scVI'].copy()\nprint(tonsil_protein_scVI.shape)\nprint(tonsil_rna_scVI.shape)\n# In[ ]:\n# Extract CN assignments from loaded checkpoint data (already in obs)\ntonsil_protein_CN_assignments = pd.DataFrame({'CN': tonsil_protein.obs['CN']}, index=tonsil_protein.obs_names)\ntonsil_rna_CN_assignments = pd.DataFrame({'CN': tonsil_rna.obs['CN']}, index=tonsil_rna.obs_names)\nsynthetic_protein_CN_assignments = pd.DataFrame({'CN': synthetic_protein.obs['CN']}, index=synthetic_protein.obs_names)\nsynthetic_rna_CN_assignments = pd.DataFrame({'CN': synthetic_rna.obs['CN']}, index=synthetic_rna.obs_names)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_rna_scVI",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_rna_scVI = tonsil_rna.obsm['X_scVI'].copy()\nprint(tonsil_protein_scVI.shape)\nprint(tonsil_rna_scVI.shape)\n# In[ ]:\n# Extract CN assignments from loaded checkpoint data (already in obs)\ntonsil_protein_CN_assignments = pd.DataFrame({'CN': tonsil_protein.obs['CN']}, index=tonsil_protein.obs_names)\ntonsil_rna_CN_assignments = pd.DataFrame({'CN': tonsil_rna.obs['CN']}, index=tonsil_rna.obs_names)\nsynthetic_protein_CN_assignments = pd.DataFrame({'CN': synthetic_protein.obs['CN']}, index=synthetic_protein.obs_names)\nsynthetic_rna_CN_assignments = pd.DataFrame({'CN': synthetic_rna.obs['CN']}, index=synthetic_rna.obs_names)\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_protein_CN_assignments",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_protein_CN_assignments = pd.DataFrame({'CN': tonsil_protein.obs['CN']}, index=tonsil_protein.obs_names)\ntonsil_rna_CN_assignments = pd.DataFrame({'CN': tonsil_rna.obs['CN']}, index=tonsil_rna.obs_names)\nsynthetic_protein_CN_assignments = pd.DataFrame({'CN': synthetic_protein.obs['CN']}, index=synthetic_protein.obs_names)\nsynthetic_rna_CN_assignments = pd.DataFrame({'CN': synthetic_rna.obs['CN']}, index=synthetic_rna.obs_names)\n# In[ ]:\nsc.settings.figdir = 'fig_khh'\nsc.set_figure_params(figsize = (6,6), dpi_save = 300, format = 'pdf', transparent = True)\n# ## dummy dot plots\n# In[ ]:\nnp.random.seed(42)  # reproducible",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_rna_CN_assignments",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_rna_CN_assignments = pd.DataFrame({'CN': tonsil_rna.obs['CN']}, index=tonsil_rna.obs_names)\nsynthetic_protein_CN_assignments = pd.DataFrame({'CN': synthetic_protein.obs['CN']}, index=synthetic_protein.obs_names)\nsynthetic_rna_CN_assignments = pd.DataFrame({'CN': synthetic_rna.obs['CN']}, index=synthetic_rna.obs_names)\n# In[ ]:\nsc.settings.figdir = 'fig_khh'\nsc.set_figure_params(figsize = (6,6), dpi_save = 300, format = 'pdf', transparent = True)\n# ## dummy dot plots\n# In[ ]:\nnp.random.seed(42)  # reproducible",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_protein_CN_assignments",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_protein_CN_assignments = pd.DataFrame({'CN': synthetic_protein.obs['CN']}, index=synthetic_protein.obs_names)\nsynthetic_rna_CN_assignments = pd.DataFrame({'CN': synthetic_rna.obs['CN']}, index=synthetic_rna.obs_names)\n# In[ ]:\nsc.settings.figdir = 'fig_khh'\nsc.set_figure_params(figsize = (6,6), dpi_save = 300, format = 'pdf', transparent = True)\n# ## dummy dot plots\n# In[ ]:\nnp.random.seed(42)  # reproducible\n# Cell and gene labels\ncells = [f\"Cell_{i:02d}\" for i in range(1, 21)]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_rna_CN_assignments",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_rna_CN_assignments = pd.DataFrame({'CN': synthetic_rna.obs['CN']}, index=synthetic_rna.obs_names)\n# In[ ]:\nsc.settings.figdir = 'fig_khh'\nsc.set_figure_params(figsize = (6,6), dpi_save = 300, format = 'pdf', transparent = True)\n# ## dummy dot plots\n# In[ ]:\nnp.random.seed(42)  # reproducible\n# Cell and gene labels\ncells = [f\"Cell_{i:02d}\" for i in range(1, 21)]\ngenes = [\"Gene A\", \"Gene B\", \"Gene C\", \"Gene D\", \"Gene E\", \"Gene F\"]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "sc.settings.figdir",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "sc.settings.figdir = 'fig_khh'\nsc.set_figure_params(figsize = (6,6), dpi_save = 300, format = 'pdf', transparent = True)\n# ## dummy dot plots\n# In[ ]:\nnp.random.seed(42)  # reproducible\n# Cell and gene labels\ncells = [f\"Cell_{i:02d}\" for i in range(1, 21)]\ngenes = [\"Gene A\", \"Gene B\", \"Gene C\", \"Gene D\", \"Gene E\", \"Gene F\"]\n# Initialize dataframe\nexpr = pd.DataFrame(index=cells, columns=genes, dtype=float)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "sc.set_figure_params(figsize",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "sc.set_figure_params(figsize = (6,6), dpi_save = 300, format = 'pdf', transparent = True)\n# ## dummy dot plots\n# In[ ]:\nnp.random.seed(42)  # reproducible\n# Cell and gene labels\ncells = [f\"Cell_{i:02d}\" for i in range(1, 21)]\ngenes = [\"Gene A\", \"Gene B\", \"Gene C\", \"Gene D\", \"Gene E\", \"Gene F\"]\n# Initialize dataframe\nexpr = pd.DataFrame(index=cells, columns=genes, dtype=float)\n# First 10 cells: high in first three genes, low in last three",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cells",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cells = [f\"Cell_{i:02d}\" for i in range(1, 21)]\ngenes = [\"Gene A\", \"Gene B\", \"Gene C\", \"Gene D\", \"Gene E\", \"Gene F\"]\n# Initialize dataframe\nexpr = pd.DataFrame(index=cells, columns=genes, dtype=float)\n# First 10 cells: high in first three genes, low in last three\nexpr.iloc[:10, 0:3] = np.random.uniform(0.8, 1.0, size=(10, 3))\nexpr.iloc[:10, 3:6] = np.random.uniform(0.1, 0.3, size=(10, 3))\n# Second 10 cells: low in first two genes, high in last four\nexpr.iloc[10:, 0:2] = np.random.uniform(0.1, 0.3, size=(10, 2))\nexpr.iloc[10:, 2:6] = np.random.uniform(0.8, 1.0, size=(10, 4))",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "genes",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "genes = [\"Gene A\", \"Gene B\", \"Gene C\", \"Gene D\", \"Gene E\", \"Gene F\"]\n# Initialize dataframe\nexpr = pd.DataFrame(index=cells, columns=genes, dtype=float)\n# First 10 cells: high in first three genes, low in last three\nexpr.iloc[:10, 0:3] = np.random.uniform(0.8, 1.0, size=(10, 3))\nexpr.iloc[:10, 3:6] = np.random.uniform(0.1, 0.3, size=(10, 3))\n# Second 10 cells: low in first two genes, high in last four\nexpr.iloc[10:, 0:2] = np.random.uniform(0.1, 0.3, size=(10, 2))\nexpr.iloc[10:, 2:6] = np.random.uniform(0.8, 1.0, size=(10, 4))\n# Mapping dataframe",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "expr",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "expr = pd.DataFrame(index=cells, columns=genes, dtype=float)\n# First 10 cells: high in first three genes, low in last three\nexpr.iloc[:10, 0:3] = np.random.uniform(0.8, 1.0, size=(10, 3))\nexpr.iloc[:10, 3:6] = np.random.uniform(0.1, 0.3, size=(10, 3))\n# Second 10 cells: low in first two genes, high in last four\nexpr.iloc[10:, 0:2] = np.random.uniform(0.1, 0.3, size=(10, 2))\nexpr.iloc[10:, 2:6] = np.random.uniform(0.8, 1.0, size=(10, 4))\n# Mapping dataframe\ngroups = pd.DataFrame(\n    {\"Group\": [\"CN_1\"] * 10 + [\"CN_2\"] * 10},",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "groups",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "groups = pd.DataFrame(\n    {\"Group\": [\"CN_1\"] * 10 + [\"CN_2\"] * 10},\n    index=cells\n)\n# Inject sparsity\nexpr.iloc[[11,13,15,17],[1]] = 0\nexpr.iloc[[11,13,15,17],[2]] = 0\nexpr.iloc[[1,3,5,7],[3]] = 0\nexpr.iloc[[1,3,5,7],[4]] = 0\ndummy_ad = ad.AnnData(expr, obs=groups)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "expr.iloc[[11,13,15,17],[1]]",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "expr.iloc[[11,13,15,17],[1]] = 0\nexpr.iloc[[11,13,15,17],[2]] = 0\nexpr.iloc[[1,3,5,7],[3]] = 0\nexpr.iloc[[1,3,5,7],[4]] = 0\ndummy_ad = ad.AnnData(expr, obs=groups)\n# In[ ]:\ndummy_dict = {'DE in CN_1': ['Gene A', 'Gene B', 'Gene C'], \n            'DE in CN_2': ['Gene D', 'Gene E','Gene F']}\ndummy_list = ['Gene A', 'Gene B', 'Gene C', 'Gene D', 'Gene E','Gene F']\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Blues', save='_dummy_dotplot_blues.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "expr.iloc[[11,13,15,17],[2]]",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "expr.iloc[[11,13,15,17],[2]] = 0\nexpr.iloc[[1,3,5,7],[3]] = 0\nexpr.iloc[[1,3,5,7],[4]] = 0\ndummy_ad = ad.AnnData(expr, obs=groups)\n# In[ ]:\ndummy_dict = {'DE in CN_1': ['Gene A', 'Gene B', 'Gene C'], \n            'DE in CN_2': ['Gene D', 'Gene E','Gene F']}\ndummy_list = ['Gene A', 'Gene B', 'Gene C', 'Gene D', 'Gene E','Gene F']\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Blues', save='_dummy_dotplot_blues.pdf')\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Greens', save='_dummy_dotplot_greens.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "expr.iloc[[1,3,5,7],[3]]",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "expr.iloc[[1,3,5,7],[3]] = 0\nexpr.iloc[[1,3,5,7],[4]] = 0\ndummy_ad = ad.AnnData(expr, obs=groups)\n# In[ ]:\ndummy_dict = {'DE in CN_1': ['Gene A', 'Gene B', 'Gene C'], \n            'DE in CN_2': ['Gene D', 'Gene E','Gene F']}\ndummy_list = ['Gene A', 'Gene B', 'Gene C', 'Gene D', 'Gene E','Gene F']\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Blues', save='_dummy_dotplot_blues.pdf')\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Greens', save='_dummy_dotplot_greens.pdf')\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "expr.iloc[[1,3,5,7],[4]]",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "expr.iloc[[1,3,5,7],[4]] = 0\ndummy_ad = ad.AnnData(expr, obs=groups)\n# In[ ]:\ndummy_dict = {'DE in CN_1': ['Gene A', 'Gene B', 'Gene C'], \n            'DE in CN_2': ['Gene D', 'Gene E','Gene F']}\ndummy_list = ['Gene A', 'Gene B', 'Gene C', 'Gene D', 'Gene E','Gene F']\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Blues', save='_dummy_dotplot_blues.pdf')\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Greens', save='_dummy_dotplot_greens.pdf')\n# In[ ]:\n# create dummy heatmap legend bar",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "dummy_ad",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "dummy_ad = ad.AnnData(expr, obs=groups)\n# In[ ]:\ndummy_dict = {'DE in CN_1': ['Gene A', 'Gene B', 'Gene C'], \n            'DE in CN_2': ['Gene D', 'Gene E','Gene F']}\ndummy_list = ['Gene A', 'Gene B', 'Gene C', 'Gene D', 'Gene E','Gene F']\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Blues', save='_dummy_dotplot_blues.pdf')\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Greens', save='_dummy_dotplot_greens.pdf')\n# In[ ]:\n# create dummy heatmap legend bar\nimport matplotlib.pyplot as plt",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "dummy_dict",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "dummy_dict = {'DE in CN_1': ['Gene A', 'Gene B', 'Gene C'], \n            'DE in CN_2': ['Gene D', 'Gene E','Gene F']}\ndummy_list = ['Gene A', 'Gene B', 'Gene C', 'Gene D', 'Gene E','Gene F']\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Blues', save='_dummy_dotplot_blues.pdf')\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Greens', save='_dummy_dotplot_greens.pdf')\n# In[ ]:\n# create dummy heatmap legend bar\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LinearSegmentedColormap, TwoSlopeNorm\n# 1) Define greenwhiteblue colormap",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "dummy_list",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "dummy_list = ['Gene A', 'Gene B', 'Gene C', 'Gene D', 'Gene E','Gene F']\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Blues', save='_dummy_dotplot_blues.pdf')\nsc.pl.dotplot(dummy_ad, groupby='Group', var_names=dummy_list, figsize=(4, 1), cmap='Greens', save='_dummy_dotplot_greens.pdf')\n# In[ ]:\n# create dummy heatmap legend bar\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LinearSegmentedColormap, TwoSlopeNorm\n# 1) Define greenwhiteblue colormap\ncmap_gwb = LinearSegmentedColormap.from_list(\n    \"gwb\", [\"#1b9e77\", \"#ffffff\", \"#377eb8\"]  # green, white, blue",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cmap_gwb",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cmap_gwb = LinearSegmentedColormap.from_list(\n    \"gwb\", [\"#1b9e77\", \"#ffffff\", \"#377eb8\"]  # green, white, blue\n)\n# 2) Example data centered at 0\nx = np.linspace(-1, 1, 200)\ny = np.linspace(-1, 1, 200)\nZ = np.outer(x, y)\n# 3) Normalize so white sits at 0\nnorm = TwoSlopeNorm(vmin=Z.min(), vcenter=0.0, vmax=Z.max())\nsns.heatmap(Z, cmap=cmap_gwb, norm=norm, cbar=True)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "x = np.linspace(-1, 1, 200)\ny = np.linspace(-1, 1, 200)\nZ = np.outer(x, y)\n# 3) Normalize so white sits at 0\nnorm = TwoSlopeNorm(vmin=Z.min(), vcenter=0.0, vmax=Z.max())\nsns.heatmap(Z, cmap=cmap_gwb, norm=norm, cbar=True)\nplt.savefig('fig_khh/dummy_heatmap_legend_bar.pdf')\n# ## main figure plots\n# In[ ]:\nsynthetic_protein.obs['spatial_grid_index'] = synthetic_protein.obs['spatial_grid_index'].map({i: f'CN_{i}' for i in [0,1,2,3]})",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "y = np.linspace(-1, 1, 200)\nZ = np.outer(x, y)\n# 3) Normalize so white sits at 0\nnorm = TwoSlopeNorm(vmin=Z.min(), vcenter=0.0, vmax=Z.max())\nsns.heatmap(Z, cmap=cmap_gwb, norm=norm, cbar=True)\nplt.savefig('fig_khh/dummy_heatmap_legend_bar.pdf')\n# ## main figure plots\n# In[ ]:\nsynthetic_protein.obs['spatial_grid_index'] = synthetic_protein.obs['spatial_grid_index'].map({i: f'CN_{i}' for i in [0,1,2,3]})\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "Z",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "Z = np.outer(x, y)\n# 3) Normalize so white sits at 0\nnorm = TwoSlopeNorm(vmin=Z.min(), vcenter=0.0, vmax=Z.max())\nsns.heatmap(Z, cmap=cmap_gwb, norm=norm, cbar=True)\nplt.savefig('fig_khh/dummy_heatmap_legend_bar.pdf')\n# ## main figure plots\n# In[ ]:\nsynthetic_protein.obs['spatial_grid_index'] = synthetic_protein.obs['spatial_grid_index'].map({i: f'CN_{i}' for i in [0,1,2,3]})\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "norm",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "norm = TwoSlopeNorm(vmin=Z.min(), vcenter=0.0, vmax=Z.max())\nsns.heatmap(Z, cmap=cmap_gwb, norm=norm, cbar=True)\nplt.savefig('fig_khh/dummy_heatmap_legend_bar.pdf')\n# ## main figure plots\n# In[ ]:\nsynthetic_protein.obs['spatial_grid_index'] = synthetic_protein.obs['spatial_grid_index'].map({i: f'CN_{i}' for i in [0,1,2,3]})\n# In[ ]:\n# order is ['B cells', 'CD4 T', 'CD8 T', 'T cells', 'cDCs']\nsynthetic_protein.obs['major_cell_types'] = synthetic_protein.obs['major_cell_types'].replace('T cells', 'GD/NK T')\nsynthetic_rna.obs['major_cell_types'] = synthetic_rna.obs['major_cell_types'].replace('T cells', 'GD/NK T')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_protein.obs['spatial_grid_index']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_protein.obs['spatial_grid_index'] = synthetic_protein.obs['spatial_grid_index'].map({i: f'CN_{i}' for i in [0,1,2,3]})\n# In[ ]:\n# order is ['B cells', 'CD4 T', 'CD8 T', 'T cells', 'cDCs']\nsynthetic_protein.obs['major_cell_types'] = synthetic_protein.obs['major_cell_types'].replace('T cells', 'GD/NK T')\nsynthetic_rna.obs['major_cell_types'] = synthetic_rna.obs['major_cell_types'].replace('T cells', 'GD/NK T')\n# In[ ]:\norder = ['Mature B','Transitional B','Ifit3-high B','MZ B',] + \\\n        ['CD4 T','Ifit3-high CD4 T','Activated CD4 T',] + \\\n        ['CD8 T','CD122+ CD8 T','Ifit3-high CD8 T',] + \\\n        ['NKT','GD T',] + \\",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_protein.obs['major_cell_types']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_protein.obs['major_cell_types'] = synthetic_protein.obs['major_cell_types'].replace('T cells', 'GD/NK T')\nsynthetic_rna.obs['major_cell_types'] = synthetic_rna.obs['major_cell_types'].replace('T cells', 'GD/NK T')\n# In[ ]:\norder = ['Mature B','Transitional B','Ifit3-high B','MZ B',] + \\\n        ['CD4 T','Ifit3-high CD4 T','Activated CD4 T',] + \\\n        ['CD8 T','CD122+ CD8 T','Ifit3-high CD8 T',] + \\\n        ['NKT','GD T',] + \\\n        ['cDC1s','cDC2s','Migratory DCs']\nsynthetic_protein.obs['minor_cell_types'] = pd.Categorical(synthetic_protein.obs['minor_cell_types'], categories=order)\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_rna.obs['major_cell_types']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_rna.obs['major_cell_types'] = synthetic_rna.obs['major_cell_types'].replace('T cells', 'GD/NK T')\n# In[ ]:\norder = ['Mature B','Transitional B','Ifit3-high B','MZ B',] + \\\n        ['CD4 T','Ifit3-high CD4 T','Activated CD4 T',] + \\\n        ['CD8 T','CD122+ CD8 T','Ifit3-high CD8 T',] + \\\n        ['NKT','GD T',] + \\\n        ['cDC1s','cDC2s','Migratory DCs']\nsynthetic_protein.obs['minor_cell_types'] = pd.Categorical(synthetic_protein.obs['minor_cell_types'], categories=order)\n# In[ ]:\n# order is ['B-CD22-CD40', 'B-Ki67', 'Plasma', 'CD4 T', 'CD8 T', 'DC']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "order",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "order = ['Mature B','Transitional B','Ifit3-high B','MZ B',] + \\\n        ['CD4 T','Ifit3-high CD4 T','Activated CD4 T',] + \\\n        ['CD8 T','CD122+ CD8 T','Ifit3-high CD8 T',] + \\\n        ['NKT','GD T',] + \\\n        ['cDC1s','cDC2s','Migratory DCs']\nsynthetic_protein.obs['minor_cell_types'] = pd.Categorical(synthetic_protein.obs['minor_cell_types'], categories=order)\n# In[ ]:\n# order is ['B-CD22-CD40', 'B-Ki67', 'Plasma', 'CD4 T', 'CD8 T', 'DC']\ntonsil_protein.obs['cell_types'] = pd.Categorical(tonsil_protein.obs['cell_types'], \n                    categories=['B-CD22-CD40', 'B-Ki67', 'Plasma', 'CD4 T', 'CD8 T', 'DC'])",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_protein.obs['minor_cell_types']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_protein.obs['minor_cell_types'] = pd.Categorical(synthetic_protein.obs['minor_cell_types'], categories=order)\n# In[ ]:\n# order is ['B-CD22-CD40', 'B-Ki67', 'Plasma', 'CD4 T', 'CD8 T', 'DC']\ntonsil_protein.obs['cell_types'] = pd.Categorical(tonsil_protein.obs['cell_types'], \n                    categories=['B-CD22-CD40', 'B-Ki67', 'Plasma', 'CD4 T', 'CD8 T', 'DC'])\n# In[ ]:\nsynthetic_palette = { \n    'Protein': '#a17bb9', # light purple\n    'RNA': '#a0522d', # orangish-brownish\n    'B cells': '#2ecc71', # green",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_protein.obs['cell_types']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_protein.obs['cell_types'] = pd.Categorical(tonsil_protein.obs['cell_types'], \n                    categories=['B-CD22-CD40', 'B-Ki67', 'Plasma', 'CD4 T', 'CD8 T', 'DC'])\n# In[ ]:\nsynthetic_palette = { \n    'Protein': '#a17bb9', # light purple\n    'RNA': '#a0522d', # orangish-brownish\n    'B cells': '#2ecc71', # green\n    'CD4 T': '#e67e22', # orange\n    'CD8 T': '#3498db', # blue\n    'GD/NK T': '#9b59b6', # purple # note that \"T cells\" was renamed to this category",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_palette",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_palette = { \n    'Protein': '#a17bb9', # light purple\n    'RNA': '#a0522d', # orangish-brownish\n    'B cells': '#2ecc71', # green\n    'CD4 T': '#e67e22', # orange\n    'CD8 T': '#3498db', # blue\n    'GD/NK T': '#9b59b6', # purple # note that \"T cells\" was renamed to this category\n    'cDCs': '#e74c3c', # red\n    # family color is green \n    'Mature B': '#2ecc71', # bright green",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_palette",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_palette = {\n    'CODEX': '#a17bb9', # light purple\n    'scRNA-seq': '#a0522d', # orangish-brownish\n    # B cell family color is green \n    'B-CD22-CD40': '#996633', # light brown\n    'B-Ki67': '#8B0000', # dark red\n    'Plasma': '#58d68d', # light green\n    'CD4 T': '#e67e22', # orange\n    'CD8 T': '#3498db', # blue\n    'DC': '#9b59b6', # purple",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "all_tonsil_cns",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "all_tonsil_cns = set(tonsil_protein.obs['CN'].unique()) | set(tonsil_rna.obs['CN'].unique())\nmissing_cns = all_tonsil_cns - set(tonsil_palette.keys())\nif missing_cns:\n    # Generate colors for missing CNs using matplotlib colormap\n    import matplotlib.cm as cm\n    n_missing = len(missing_cns)\n    colors = cm.get_cmap('tab20')(np.linspace(0, 1, n_missing))\n    for i, cn in enumerate(sorted(missing_cns)):\n        tonsil_palette[cn] = matplotlib.colors.to_hex(colors[i])\nsc.pl.embedding(tonsil_protein, 'spatial', color=['CN','cell_types'], ",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "missing_cns",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "missing_cns = all_tonsil_cns - set(tonsil_palette.keys())\nif missing_cns:\n    # Generate colors for missing CNs using matplotlib colormap\n    import matplotlib.cm as cm\n    n_missing = len(missing_cns)\n    colors = cm.get_cmap('tab20')(np.linspace(0, 1, n_missing))\n    for i, cn in enumerate(sorted(missing_cns)):\n        tonsil_palette[cn] = matplotlib.colors.to_hex(colors[i])\nsc.pl.embedding(tonsil_protein, 'spatial', color=['CN','cell_types'], \n                    palette = tonsil_palette, s=10, save='_tonsil_protein.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_protein.obs['CN_csv']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_protein.obs['CN_csv'] = synthetic_protein_CN_assignments.loc[synthetic_protein.obs_names, 'CN']\nsynthetic_protein.obs['CN_csv'] = synthetic_protein.obs['CN_csv'].replace({\n    'CN_0': 'CN_0',\n    'CN_1': 'CN_3',\n    'CN_2': 'CN_2',\n    'CN_3': 'CN_1',\n})\nsc.pl.embedding(synthetic_protein, 'spatial', color=['spatial_grid_index','CN_csv'], s=30)\n# In[ ]:\nsynthetic_rna.obs['CN'] = synthetic_rna_CN_assignments.loc[synthetic_rna.obs_names, 'CN']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_protein.obs['CN_csv']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_protein.obs['CN_csv'] = synthetic_protein.obs['CN_csv'].replace({\n    'CN_0': 'CN_0',\n    'CN_1': 'CN_3',\n    'CN_2': 'CN_2',\n    'CN_3': 'CN_1',\n})\nsc.pl.embedding(synthetic_protein, 'spatial', color=['spatial_grid_index','CN_csv'], s=30)\n# In[ ]:\nsynthetic_rna.obs['CN'] = synthetic_rna_CN_assignments.loc[synthetic_rna.obs_names, 'CN']\nsynthetic_rna.obs['CN'] = synthetic_rna.obs['CN'].replace({",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_rna.obs['CN']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_rna.obs['CN'] = synthetic_rna_CN_assignments.loc[synthetic_rna.obs_names, 'CN']\nsynthetic_rna.obs['CN'] = synthetic_rna.obs['CN'].replace({\n    'CN_0': 'CN_0',\n    'CN_1': 'CN_3',\n    'CN_2': 'CN_2',\n    'CN_3': 'CN_1',\n})\nsc.pl.embedding(synthetic_rna, 'original_umap', color=['CN'], \n                    palette = synthetic_palette, s=10, save='_synthetic_rna_CN.pdf')\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_rna.obs['CN']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_rna.obs['CN'] = synthetic_rna.obs['CN'].replace({\n    'CN_0': 'CN_0',\n    'CN_1': 'CN_3',\n    'CN_2': 'CN_2',\n    'CN_3': 'CN_1',\n})\nsc.pl.embedding(synthetic_rna, 'original_umap', color=['CN'], \n                    palette = synthetic_palette, s=10, save='_synthetic_rna_CN.pdf')\n# In[ ]:\nadata_protein_df = synthetic_protein.obs.copy()",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_protein_df",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_protein_df = synthetic_protein.obs.copy()\nadata_protein_df['CN'] = adata_protein_df['spatial_grid_index']\nfor z in range(synthetic_protein.obsm['X_scVI'].shape[1]):\n    adata_protein_df[f'z{z}'] = synthetic_protein.obsm['X_scVI'][:, z]\nadata_protein_df['modality'] = 'Protein'\nadata_rna_df = synthetic_rna.obs.copy()\nz_keys = []\nfor z in range(synthetic_rna.obsm['X_scVI'].shape[1]):\n    adata_rna_df[f'z{z}'] = synthetic_rna.obsm['X_scVI'][:, z]\n    z_keys.append(f'z{z}')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_protein_df['CN']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_protein_df['CN'] = adata_protein_df['spatial_grid_index']\nfor z in range(synthetic_protein.obsm['X_scVI'].shape[1]):\n    adata_protein_df[f'z{z}'] = synthetic_protein.obsm['X_scVI'][:, z]\nadata_protein_df['modality'] = 'Protein'\nadata_rna_df = synthetic_rna.obs.copy()\nz_keys = []\nfor z in range(synthetic_rna.obsm['X_scVI'].shape[1]):\n    adata_rna_df[f'z{z}'] = synthetic_rna.obsm['X_scVI'][:, z]\n    z_keys.append(f'z{z}')\nadata_rna_df['modality'] = 'RNA'",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_protein_df['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_protein_df['modality'] = 'Protein'\nadata_rna_df = synthetic_rna.obs.copy()\nz_keys = []\nfor z in range(synthetic_rna.obsm['X_scVI'].shape[1]):\n    adata_rna_df[f'z{z}'] = synthetic_rna.obsm['X_scVI'][:, z]\n    z_keys.append(f'z{z}')\nadata_rna_df['modality'] = 'RNA'\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\nsynthetic_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\nsynthetic_merged.obsm['X_scVI'] = synthetic_merged.X.copy()",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_rna_df",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_rna_df = synthetic_rna.obs.copy()\nz_keys = []\nfor z in range(synthetic_rna.obsm['X_scVI'].shape[1]):\n    adata_rna_df[f'z{z}'] = synthetic_rna.obsm['X_scVI'][:, z]\n    z_keys.append(f'z{z}')\nadata_rna_df['modality'] = 'RNA'\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\nsynthetic_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\nsynthetic_merged.obsm['X_scVI'] = synthetic_merged.X.copy()\nsynthetic_merged",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "z_keys",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "z_keys = []\nfor z in range(synthetic_rna.obsm['X_scVI'].shape[1]):\n    adata_rna_df[f'z{z}'] = synthetic_rna.obsm['X_scVI'][:, z]\n    z_keys.append(f'z{z}')\nadata_rna_df['modality'] = 'RNA'\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\nsynthetic_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\nsynthetic_merged.obsm['X_scVI'] = synthetic_merged.X.copy()\nsynthetic_merged\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_rna_df['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_rna_df['modality'] = 'RNA'\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\nsynthetic_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\nsynthetic_merged.obsm['X_scVI'] = synthetic_merged.X.copy()\nsynthetic_merged\n# In[ ]:\nsc.pp.neighbors(synthetic_merged, use_rep='X_scVI')\nsc.tl.umap(synthetic_merged, min_dist=0.3)\n# In[ ]:\nsc.pl.umap(synthetic_merged, color=['modality','major_cell_types','minor_cell_types','CN'], ",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_merged_df",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\nsynthetic_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\nsynthetic_merged.obsm['X_scVI'] = synthetic_merged.X.copy()\nsynthetic_merged\n# In[ ]:\nsc.pp.neighbors(synthetic_merged, use_rep='X_scVI')\nsc.tl.umap(synthetic_merged, min_dist=0.3)\n# In[ ]:\nsc.pl.umap(synthetic_merged, color=['modality','major_cell_types','minor_cell_types','CN'], \n           palette=synthetic_palette, s=10, wspace=0.2, save='_synthetic_merged.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\nsynthetic_merged.obsm['X_scVI'] = synthetic_merged.X.copy()\nsynthetic_merged\n# In[ ]:\nsc.pp.neighbors(synthetic_merged, use_rep='X_scVI')\nsc.tl.umap(synthetic_merged, min_dist=0.3)\n# In[ ]:\nsc.pl.umap(synthetic_merged, color=['modality','major_cell_types','minor_cell_types','CN'], \n           palette=synthetic_palette, s=10, wspace=0.2, save='_synthetic_merged.pdf')\n# ### make confusion matrices",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged.obsm['X_scVI']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged.obsm['X_scVI'] = synthetic_merged.X.copy()\nsynthetic_merged\n# In[ ]:\nsc.pp.neighbors(synthetic_merged, use_rep='X_scVI')\nsc.tl.umap(synthetic_merged, min_dist=0.3)\n# In[ ]:\nsc.pl.umap(synthetic_merged, color=['modality','major_cell_types','minor_cell_types','CN'], \n           palette=synthetic_palette, s=10, wspace=0.2, save='_synthetic_merged.pdf')\n# ### make confusion matrices",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cm_arcadia_cite_seq",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cm_arcadia_cite_seq = compute_confusion_matrix(synthetic_rna, synthetic_protein)\n# Plot all cell types confusion matrix (if matrix format)\nif cm_arcadia_cite_seq.shape[1] > 1:\n    with plt.rc_context({'figure.figsize': (4, 4)}):\n        sns.heatmap(cm_arcadia_cite_seq, annot=cm_arcadia_cite_seq.round(1).astype(str) + \"%\", fmt='', cmap='Blues', cbar=False, square=True)\n        plt.xlabel('Predicted')\n        plt.ylabel('Ground Truth')\n        plt.title('CN Assignment Accuracy (All Cell Types)')\n        plt.savefig('fig_khh/CN_confusion_matrix_all.pdf')\n        plt.clf()",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "bcells_mask",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "bcells_mask = synthetic_rna.obs['cell_types'].str.contains('B', case=False, na=False).values\nif bcells_mask.sum() > 0:\n    cm_bcells = compute_confusion_matrix(synthetic_rna[bcells_mask], synthetic_protein[bcells_mask])\n    f1_score = 'XX%'\n    if cm_bcells.shape[1] > 1:\n        with plt.rc_context({'figure.figsize': (4, 4)}):\n            sns.heatmap(cm_bcells, annot=cm_bcells.round(1).astype(str) + \"%\", fmt='', cmap='Blues', cbar=False, square=True)\n            plt.xlabel('Predicted')\n            plt.ylabel('Ground Truth')\n            plt.title('B Cell CN Assignment, F1 Score: ' + f1_score)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cm_arcadia_tonsil",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cm_arcadia_tonsil = compute_confusion_matrix(tonsil_rna, tonsil_protein)\nct_cf_plot_tonsil(cm_arcadia_tonsil, 'ARCADIA', 'XX%', 'fig_khh/tonsil_confusion_matrix_arcadia.pdf')\n# MaxFuse tonsil confusion matrix will be computed after loading MaxFuse tonsil adata objects (see below)\n# scMODAL tonsil confusion matrix will be computed after loading scMODAL tonsil adata objects (see below)\n# ### visualize other integration embeddings - semi-synthetic\n# In[ ]:\nsynthetic_merged_copy = synthetic_merged.copy()\nsc.pl.umap(synthetic_merged_copy, color='minor_cell_types', palette=synthetic_palette, s=15,\n            save='_synthetic_merged_minor_cell_types.pdf')\nsc.pl.umap(synthetic_merged_copy, color='matched_archetype_weight', cmap='viridis', s=15, vmin=0.3, vmax=0.9,",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_copy = synthetic_merged.copy()\nsc.pl.umap(synthetic_merged_copy, color='minor_cell_types', palette=synthetic_palette, s=15,\n            save='_synthetic_merged_minor_cell_types.pdf')\nsc.pl.umap(synthetic_merged_copy, color='matched_archetype_weight', cmap='viridis', s=15, vmin=0.3, vmax=0.9,\n            mask_obs=(synthetic_merged_copy.obs['modality'] == 'RNA'),\n            save='_synthetic_merged_matched_archetype_weight_RNA.pdf')\nsynthetic_merged_copy = synthetic_merged.copy()\nsc.pl.umap(synthetic_merged_copy, color='matched_archetype_weight', cmap='viridis', s=15, vmin=0.3, vmax=0.9,\n            mask_obs=(synthetic_merged_copy.obs['modality'] == 'Protein'),\n            save='_synthetic_merged_matched_archetype_weight_Protein.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_copy = synthetic_merged.copy()\nsc.pl.umap(synthetic_merged_copy, color='matched_archetype_weight', cmap='viridis', s=15, vmin=0.3, vmax=0.9,\n            mask_obs=(synthetic_merged_copy.obs['modality'] == 'Protein'),\n            save='_synthetic_merged_matched_archetype_weight_Protein.pdf')\n# synthetic_merged.obs.columns\n# In[ ]:\nrandom_indices = np.random.permutation(list(range(synthetic_merged_copy.shape[0])))\nsc.pl.umap(synthetic_merged_copy[random_indices], color='modality', palette=synthetic_palette, s=15,\n            save='_synthetic_merged_modality.pdf')\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "random_indices",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "random_indices = np.random.permutation(list(range(synthetic_merged_copy.shape[0])))\nsc.pl.umap(synthetic_merged_copy[random_indices], color='modality', palette=synthetic_palette, s=15,\n            save='_synthetic_merged_modality.pdf')\n# In[ ]:\nsc.pl.umap(synthetic_merged_copy[random_indices], color='CN', palette=synthetic_palette, s=15,\n            save='_synthetic_merged_CN.pdf')\n# In[ ]:\nsynthetic_merged.obs_names = synthetic_merged.obs_names + synthetic_merged.obs['modality'].astype(str)\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged.obs_names",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged.obs_names = synthetic_merged.obs_names + synthetic_merged.obs['modality'].astype(str)\n# In[ ]:\n# Load scMODAL adata objects and extract UMAP from obsm['X_umap']\nscmodal_rna = None\nscmodal_protein = None\nscmodal_rna_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*rna*.h5ad')\nscmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*protein*.h5ad') + \\\n                        glob.glob('model_comparison/outputs/scmodal_cite_seq/*prot*.h5ad')\nif not scmodal_rna_files:\n    raise FileNotFoundError(\"scMODAL RNA output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_rna",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_rna = None\nscmodal_protein = None\nscmodal_rna_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*rna*.h5ad')\nscmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*protein*.h5ad') + \\\n                        glob.glob('model_comparison/outputs/scmodal_cite_seq/*prot*.h5ad')\nif not scmodal_rna_files:\n    raise FileNotFoundError(\"scMODAL RNA output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")\nif not scmodal_protein_files:\n    raise FileNotFoundError(\"scMODAL protein output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")\n# Load the most recent files",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_protein",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_protein = None\nscmodal_rna_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*rna*.h5ad')\nscmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*protein*.h5ad') + \\\n                        glob.glob('model_comparison/outputs/scmodal_cite_seq/*prot*.h5ad')\nif not scmodal_rna_files:\n    raise FileNotFoundError(\"scMODAL RNA output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")\nif not scmodal_protein_files:\n    raise FileNotFoundError(\"scMODAL protein output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")\n# Load the most recent files\nscmodal_rna_file = max(scmodal_rna_files, key=os.path.getmtime)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_rna_files",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_rna_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*rna*.h5ad')\nscmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*protein*.h5ad') + \\\n                        glob.glob('model_comparison/outputs/scmodal_cite_seq/*prot*.h5ad')\nif not scmodal_rna_files:\n    raise FileNotFoundError(\"scMODAL RNA output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")\nif not scmodal_protein_files:\n    raise FileNotFoundError(\"scMODAL protein output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")\n# Load the most recent files\nscmodal_rna_file = max(scmodal_rna_files, key=os.path.getmtime)\nscmodal_protein_file = max(scmodal_protein_files, key=os.path.getmtime)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_protein_files",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_cite_seq/*protein*.h5ad') + \\\n                        glob.glob('model_comparison/outputs/scmodal_cite_seq/*prot*.h5ad')\nif not scmodal_rna_files:\n    raise FileNotFoundError(\"scMODAL RNA output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")\nif not scmodal_protein_files:\n    raise FileNotFoundError(\"scMODAL protein output files not found in 'model_comparison/outputs/scmodal_cite_seq/'\")\n# Load the most recent files\nscmodal_rna_file = max(scmodal_rna_files, key=os.path.getmtime)\nscmodal_protein_file = max(scmodal_protein_files, key=os.path.getmtime)\nscmodal_rna = sc.read_h5ad(scmodal_rna_file)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_rna_file",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_rna_file = max(scmodal_rna_files, key=os.path.getmtime)\nscmodal_protein_file = max(scmodal_protein_files, key=os.path.getmtime)\nscmodal_rna = sc.read_h5ad(scmodal_rna_file)\nscmodal_protein = sc.read_h5ad(scmodal_protein_file)\n# Align scMODAL data with ARCADIA data using the same logic as compare_results.py\nprint(\"Aligning scMODAL data with ARCADIA data...\")\nsynthetic_rna_aligned, scmodal_rna_aligned, _ = align_data(synthetic_rna, scmodal_rna, \"rna\", \"scmodal\")\nsynthetic_protein_aligned, scmodal_protein_aligned, _ = align_data(synthetic_protein, scmodal_protein, \"protein\", \"scmodal\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in scmodal_rna_aligned.obsm:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_protein_file",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_protein_file = max(scmodal_protein_files, key=os.path.getmtime)\nscmodal_rna = sc.read_h5ad(scmodal_rna_file)\nscmodal_protein = sc.read_h5ad(scmodal_protein_file)\n# Align scMODAL data with ARCADIA data using the same logic as compare_results.py\nprint(\"Aligning scMODAL data with ARCADIA data...\")\nsynthetic_rna_aligned, scmodal_rna_aligned, _ = align_data(synthetic_rna, scmodal_rna, \"rna\", \"scmodal\")\nsynthetic_protein_aligned, scmodal_protein_aligned, _ = align_data(synthetic_protein, scmodal_protein, \"protein\", \"scmodal\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in scmodal_rna_aligned.obsm:\n    if 'latent' in scmodal_rna_aligned.obsm:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_rna",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_rna = sc.read_h5ad(scmodal_rna_file)\nscmodal_protein = sc.read_h5ad(scmodal_protein_file)\n# Align scMODAL data with ARCADIA data using the same logic as compare_results.py\nprint(\"Aligning scMODAL data with ARCADIA data...\")\nsynthetic_rna_aligned, scmodal_rna_aligned, _ = align_data(synthetic_rna, scmodal_rna, \"rna\", \"scmodal\")\nsynthetic_protein_aligned, scmodal_protein_aligned, _ = align_data(synthetic_protein, scmodal_protein, \"protein\", \"scmodal\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in scmodal_rna_aligned.obsm:\n    if 'latent' in scmodal_rna_aligned.obsm:\n        print(\"Computing UMAP for scMODAL RNA from latent representation...\")",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_protein",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_protein = sc.read_h5ad(scmodal_protein_file)\n# Align scMODAL data with ARCADIA data using the same logic as compare_results.py\nprint(\"Aligning scMODAL data with ARCADIA data...\")\nsynthetic_rna_aligned, scmodal_rna_aligned, _ = align_data(synthetic_rna, scmodal_rna, \"rna\", \"scmodal\")\nsynthetic_protein_aligned, scmodal_protein_aligned, _ = align_data(synthetic_protein, scmodal_protein, \"protein\", \"scmodal\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in scmodal_rna_aligned.obsm:\n    if 'latent' in scmodal_rna_aligned.obsm:\n        print(\"Computing UMAP for scMODAL RNA from latent representation...\")\n        scmodal_rna_aligned.obsm['X_latent'] = scmodal_rna_aligned.obsm['latent']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_rna_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_rna_aligned.obs['modality'] = 'RNA'\nscmodal_protein_aligned.obs['modality'] = 'Protein'\nscmodal_merged = sc.concat([scmodal_rna_aligned, scmodal_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nscmodal_merged.obs_names = scmodal_merged.obs_names + scmodal_merged.obs['modality'].astype(str)\n# Create aligned synthetic_merged for embeddings (already aligned, so obs_names should match)\nsynthetic_rna_aligned.obs['modality'] = 'RNA'\nsynthetic_protein_aligned.obs['modality'] = 'Protein'\nsynthetic_merged_aligned = sc.concat([synthetic_rna_aligned, synthetic_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nsynthetic_merged_aligned.obs_names = synthetic_merged_aligned.obs_names + synthetic_merged_aligned.obs['modality'].astype(str)\n# Now they should have matching obs_names, so we can directly assign UMAP",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_protein_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_protein_aligned.obs['modality'] = 'Protein'\nscmodal_merged = sc.concat([scmodal_rna_aligned, scmodal_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nscmodal_merged.obs_names = scmodal_merged.obs_names + scmodal_merged.obs['modality'].astype(str)\n# Create aligned synthetic_merged for embeddings (already aligned, so obs_names should match)\nsynthetic_rna_aligned.obs['modality'] = 'RNA'\nsynthetic_protein_aligned.obs['modality'] = 'Protein'\nsynthetic_merged_aligned = sc.concat([synthetic_rna_aligned, synthetic_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nsynthetic_merged_aligned.obs_names = synthetic_merged_aligned.obs_names + synthetic_merged_aligned.obs['modality'].astype(str)\n# Now they should have matching obs_names, so we can directly assign UMAP\nsynthetic_merged_other_embeddings = synthetic_merged.copy()",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_merged",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_merged = sc.concat([scmodal_rna_aligned, scmodal_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nscmodal_merged.obs_names = scmodal_merged.obs_names + scmodal_merged.obs['modality'].astype(str)\n# Create aligned synthetic_merged for embeddings (already aligned, so obs_names should match)\nsynthetic_rna_aligned.obs['modality'] = 'RNA'\nsynthetic_protein_aligned.obs['modality'] = 'Protein'\nsynthetic_merged_aligned = sc.concat([synthetic_rna_aligned, synthetic_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nsynthetic_merged_aligned.obs_names = synthetic_merged_aligned.obs_names + synthetic_merged_aligned.obs['modality'].astype(str)\n# Now they should have matching obs_names, so we can directly assign UMAP\nsynthetic_merged_other_embeddings = synthetic_merged.copy()\n# Find common names between aligned data and original synthetic_merged",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_merged.obs_names",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_merged.obs_names = scmodal_merged.obs_names + scmodal_merged.obs['modality'].astype(str)\n# Create aligned synthetic_merged for embeddings (already aligned, so obs_names should match)\nsynthetic_rna_aligned.obs['modality'] = 'RNA'\nsynthetic_protein_aligned.obs['modality'] = 'Protein'\nsynthetic_merged_aligned = sc.concat([synthetic_rna_aligned, synthetic_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nsynthetic_merged_aligned.obs_names = synthetic_merged_aligned.obs_names + synthetic_merged_aligned.obs['modality'].astype(str)\n# Now they should have matching obs_names, so we can directly assign UMAP\nsynthetic_merged_other_embeddings = synthetic_merged.copy()\n# Find common names between aligned data and original synthetic_merged\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(scmodal_merged.obs_names)]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_rna_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_rna_aligned.obs['modality'] = 'RNA'\nsynthetic_protein_aligned.obs['modality'] = 'Protein'\nsynthetic_merged_aligned = sc.concat([synthetic_rna_aligned, synthetic_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nsynthetic_merged_aligned.obs_names = synthetic_merged_aligned.obs_names + synthetic_merged_aligned.obs['modality'].astype(str)\n# Now they should have matching obs_names, so we can directly assign UMAP\nsynthetic_merged_other_embeddings = synthetic_merged.copy()\n# Find common names between aligned data and original synthetic_merged\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(scmodal_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nscmodal_merged_subset = scmodal_merged[scmodal_merged.obs_names.isin(common_names)]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_protein_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_protein_aligned.obs['modality'] = 'Protein'\nsynthetic_merged_aligned = sc.concat([synthetic_rna_aligned, synthetic_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nsynthetic_merged_aligned.obs_names = synthetic_merged_aligned.obs_names + synthetic_merged_aligned.obs['modality'].astype(str)\n# Now they should have matching obs_names, so we can directly assign UMAP\nsynthetic_merged_other_embeddings = synthetic_merged.copy()\n# Find common names between aligned data and original synthetic_merged\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(scmodal_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nscmodal_merged_subset = scmodal_merged[scmodal_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_aligned",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_aligned = sc.concat([synthetic_rna_aligned, synthetic_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nsynthetic_merged_aligned.obs_names = synthetic_merged_aligned.obs_names + synthetic_merged_aligned.obs['modality'].astype(str)\n# Now they should have matching obs_names, so we can directly assign UMAP\nsynthetic_merged_other_embeddings = synthetic_merged.copy()\n# Find common names between aligned data and original synthetic_merged\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(scmodal_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nscmodal_merged_subset = scmodal_merged[scmodal_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nscmodal_merged_subset = scmodal_merged_subset[synthetic_merged_other_embeddings.obs_names]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_aligned.obs_names",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_aligned.obs_names = synthetic_merged_aligned.obs_names + synthetic_merged_aligned.obs['modality'].astype(str)\n# Now they should have matching obs_names, so we can directly assign UMAP\nsynthetic_merged_other_embeddings = synthetic_merged.copy()\n# Find common names between aligned data and original synthetic_merged\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(scmodal_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nscmodal_merged_subset = scmodal_merged[scmodal_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nscmodal_merged_subset = scmodal_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_scmodal'] = scmodal_merged_subset.obsm['X_umap']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_other_embeddings",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_other_embeddings = synthetic_merged.copy()\n# Find common names between aligned data and original synthetic_merged\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(scmodal_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nscmodal_merged_subset = scmodal_merged[scmodal_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nscmodal_merged_subset = scmodal_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_scmodal'] = scmodal_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_scmodal = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "common_names",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "common_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(scmodal_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nscmodal_merged_subset = scmodal_merged[scmodal_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nscmodal_merged_subset = scmodal_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_scmodal'] = scmodal_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_scmodal = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_scmodal], 'scmodal', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_scmodal.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_other_embeddings",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nscmodal_merged_subset = scmodal_merged[scmodal_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nscmodal_merged_subset = scmodal_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_scmodal'] = scmodal_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_scmodal = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_scmodal], 'scmodal', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_scmodal.pdf')\n# Compute scMODAL cite_seq confusion matrix (using aligned data)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_merged_subset",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_merged_subset = scmodal_merged[scmodal_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nscmodal_merged_subset = scmodal_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_scmodal'] = scmodal_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_scmodal = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_scmodal], 'scmodal', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_scmodal.pdf')\n# Compute scMODAL cite_seq confusion matrix (using aligned data)\nprint(\"Computing scMODAL cite_seq confusion matrix...\")",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "scmodal_merged_subset",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "scmodal_merged_subset = scmodal_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_scmodal'] = scmodal_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_scmodal = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_scmodal], 'scmodal', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_scmodal.pdf')\n# Compute scMODAL cite_seq confusion matrix (using aligned data)\nprint(\"Computing scMODAL cite_seq confusion matrix...\")\ncm_scmodal_cite_seq = compute_confusion_matrix(scmodal_rna_aligned, scmodal_protein_aligned)\nct_cf_plot(cm_scmodal_cite_seq, 'scModal', 'XX%', 'fig_khh/synthetic_confusion_matrix_scmodal.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_other_embeddings.obsm['X_scmodal']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_other_embeddings.obsm['X_scmodal'] = scmodal_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_scmodal = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_scmodal], 'scmodal', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_scmodal.pdf')\n# Compute scMODAL cite_seq confusion matrix (using aligned data)\nprint(\"Computing scMODAL cite_seq confusion matrix...\")\ncm_scmodal_cite_seq = compute_confusion_matrix(scmodal_rna_aligned, scmodal_protein_aligned)\nct_cf_plot(cm_scmodal_cite_seq, 'scModal', 'XX%', 'fig_khh/synthetic_confusion_matrix_scmodal.pdf')\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "random_indices_scmodal",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "random_indices_scmodal = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_scmodal], 'scmodal', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_scmodal.pdf')\n# Compute scMODAL cite_seq confusion matrix (using aligned data)\nprint(\"Computing scMODAL cite_seq confusion matrix...\")\ncm_scmodal_cite_seq = compute_confusion_matrix(scmodal_rna_aligned, scmodal_protein_aligned)\nct_cf_plot(cm_scmodal_cite_seq, 'scModal', 'XX%', 'fig_khh/synthetic_confusion_matrix_scmodal.pdf')\n# In[ ]:\n# Load MaxFuse adata objects and extract UMAP from obsm['X_umap']\nmaxfuse_rna_files = glob.glob('model_comparison/outputs/maxfuse_cite_seq/*rna*.h5ad')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cm_scmodal_cite_seq",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cm_scmodal_cite_seq = compute_confusion_matrix(scmodal_rna_aligned, scmodal_protein_aligned)\nct_cf_plot(cm_scmodal_cite_seq, 'scModal', 'XX%', 'fig_khh/synthetic_confusion_matrix_scmodal.pdf')\n# In[ ]:\n# Load MaxFuse adata objects and extract UMAP from obsm['X_umap']\nmaxfuse_rna_files = glob.glob('model_comparison/outputs/maxfuse_cite_seq/*rna*.h5ad')\nmaxfuse_protein_files = glob.glob('model_comparison/outputs/maxfuse_cite_seq/*protein*.h5ad') + \\\n                       glob.glob('model_comparison/outputs/maxfuse_cite_seq/*prot*.h5ad')\nif not maxfuse_rna_files:\n    raise FileNotFoundError(\"MaxFuse RNA output files not found in 'model_comparison/outputs/maxfuse_cite_seq/'\")\nif not maxfuse_protein_files:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_rna_files",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_rna_files = glob.glob('model_comparison/outputs/maxfuse_cite_seq/*rna*.h5ad')\nmaxfuse_protein_files = glob.glob('model_comparison/outputs/maxfuse_cite_seq/*protein*.h5ad') + \\\n                       glob.glob('model_comparison/outputs/maxfuse_cite_seq/*prot*.h5ad')\nif not maxfuse_rna_files:\n    raise FileNotFoundError(\"MaxFuse RNA output files not found in 'model_comparison/outputs/maxfuse_cite_seq/'\")\nif not maxfuse_protein_files:\n    raise FileNotFoundError(\"MaxFuse protein output files not found in 'model_comparison/outputs/maxfuse_cite_seq/'\")\nif synthetic_merged_other_embeddings is None:\n    raise ValueError(\"synthetic_merged_other_embeddings is None - scMODAL data must be loaded first\")\n# Load the most recent files",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_protein_files",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_protein_files = glob.glob('model_comparison/outputs/maxfuse_cite_seq/*protein*.h5ad') + \\\n                       glob.glob('model_comparison/outputs/maxfuse_cite_seq/*prot*.h5ad')\nif not maxfuse_rna_files:\n    raise FileNotFoundError(\"MaxFuse RNA output files not found in 'model_comparison/outputs/maxfuse_cite_seq/'\")\nif not maxfuse_protein_files:\n    raise FileNotFoundError(\"MaxFuse protein output files not found in 'model_comparison/outputs/maxfuse_cite_seq/'\")\nif synthetic_merged_other_embeddings is None:\n    raise ValueError(\"synthetic_merged_other_embeddings is None - scMODAL data must be loaded first\")\n# Load the most recent files\nmaxfuse_rna_file = max(maxfuse_rna_files, key=os.path.getmtime)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_rna_file",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_rna_file = max(maxfuse_rna_files, key=os.path.getmtime)\nmaxfuse_protein_file = max(maxfuse_protein_files, key=os.path.getmtime)\nmaxfuse_rna = sc.read_h5ad(maxfuse_rna_file)\nmaxfuse_protein = sc.read_h5ad(maxfuse_protein_file)\n# Align MaxFuse data with ARCADIA data using the same logic as compare_results.py\nprint(\"Aligning MaxFuse data with ARCADIA data...\")\nsynthetic_rna_aligned_mf, maxfuse_rna_aligned, _ = align_data(synthetic_rna, maxfuse_rna, \"rna\", \"maxfuse\")\nsynthetic_protein_aligned_mf, maxfuse_protein_aligned, _ = align_data(synthetic_protein, maxfuse_protein, \"protein\", \"maxfuse\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in maxfuse_rna_aligned.obsm:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_protein_file",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_protein_file = max(maxfuse_protein_files, key=os.path.getmtime)\nmaxfuse_rna = sc.read_h5ad(maxfuse_rna_file)\nmaxfuse_protein = sc.read_h5ad(maxfuse_protein_file)\n# Align MaxFuse data with ARCADIA data using the same logic as compare_results.py\nprint(\"Aligning MaxFuse data with ARCADIA data...\")\nsynthetic_rna_aligned_mf, maxfuse_rna_aligned, _ = align_data(synthetic_rna, maxfuse_rna, \"rna\", \"maxfuse\")\nsynthetic_protein_aligned_mf, maxfuse_protein_aligned, _ = align_data(synthetic_protein, maxfuse_protein, \"protein\", \"maxfuse\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in maxfuse_rna_aligned.obsm:\n    if 'latent' in maxfuse_rna_aligned.obsm:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_rna",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_rna = sc.read_h5ad(maxfuse_rna_file)\nmaxfuse_protein = sc.read_h5ad(maxfuse_protein_file)\n# Align MaxFuse data with ARCADIA data using the same logic as compare_results.py\nprint(\"Aligning MaxFuse data with ARCADIA data...\")\nsynthetic_rna_aligned_mf, maxfuse_rna_aligned, _ = align_data(synthetic_rna, maxfuse_rna, \"rna\", \"maxfuse\")\nsynthetic_protein_aligned_mf, maxfuse_protein_aligned, _ = align_data(synthetic_protein, maxfuse_protein, \"protein\", \"maxfuse\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in maxfuse_rna_aligned.obsm:\n    if 'latent' in maxfuse_rna_aligned.obsm:\n        print(\"Computing UMAP for MaxFuse RNA from latent representation...\")",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_protein",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_protein = sc.read_h5ad(maxfuse_protein_file)\n# Align MaxFuse data with ARCADIA data using the same logic as compare_results.py\nprint(\"Aligning MaxFuse data with ARCADIA data...\")\nsynthetic_rna_aligned_mf, maxfuse_rna_aligned, _ = align_data(synthetic_rna, maxfuse_rna, \"rna\", \"maxfuse\")\nsynthetic_protein_aligned_mf, maxfuse_protein_aligned, _ = align_data(synthetic_protein, maxfuse_protein, \"protein\", \"maxfuse\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in maxfuse_rna_aligned.obsm:\n    if 'latent' in maxfuse_rna_aligned.obsm:\n        print(\"Computing UMAP for MaxFuse RNA from latent representation...\")\n        maxfuse_rna_aligned.obsm['X_latent'] = maxfuse_rna_aligned.obsm['latent']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_rna_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_rna_aligned.obs['modality'] = 'RNA'\nmaxfuse_protein_aligned.obs['modality'] = 'Protein'\nmaxfuse_merged = sc.concat([maxfuse_rna_aligned, maxfuse_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nmaxfuse_merged.obs_names = maxfuse_merged.obs_names + maxfuse_merged.obs['modality'].astype(str)\n# Match with synthetic_merged_other_embeddings by obs_names (should already be aligned)\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(maxfuse_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nmaxfuse_merged_subset = maxfuse_merged[maxfuse_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nmaxfuse_merged_subset = maxfuse_merged_subset[synthetic_merged_other_embeddings.obs_names]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_protein_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_protein_aligned.obs['modality'] = 'Protein'\nmaxfuse_merged = sc.concat([maxfuse_rna_aligned, maxfuse_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nmaxfuse_merged.obs_names = maxfuse_merged.obs_names + maxfuse_merged.obs['modality'].astype(str)\n# Match with synthetic_merged_other_embeddings by obs_names (should already be aligned)\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(maxfuse_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nmaxfuse_merged_subset = maxfuse_merged[maxfuse_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nmaxfuse_merged_subset = maxfuse_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_maxfuse'] = maxfuse_merged_subset.obsm['X_umap']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_merged",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_merged = sc.concat([maxfuse_rna_aligned, maxfuse_protein_aligned], join='outer', label='modality', keys=['RNA', 'Protein'])\nmaxfuse_merged.obs_names = maxfuse_merged.obs_names + maxfuse_merged.obs['modality'].astype(str)\n# Match with synthetic_merged_other_embeddings by obs_names (should already be aligned)\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(maxfuse_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nmaxfuse_merged_subset = maxfuse_merged[maxfuse_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nmaxfuse_merged_subset = maxfuse_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_maxfuse'] = maxfuse_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_merged.obs_names",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_merged.obs_names = maxfuse_merged.obs_names + maxfuse_merged.obs['modality'].astype(str)\n# Match with synthetic_merged_other_embeddings by obs_names (should already be aligned)\ncommon_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(maxfuse_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nmaxfuse_merged_subset = maxfuse_merged[maxfuse_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nmaxfuse_merged_subset = maxfuse_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_maxfuse'] = maxfuse_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_maxfuse = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "common_names",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "common_names = synthetic_merged_other_embeddings.obs_names[synthetic_merged_other_embeddings.obs_names.isin(maxfuse_merged.obs_names)]\nsynthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nmaxfuse_merged_subset = maxfuse_merged[maxfuse_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nmaxfuse_merged_subset = maxfuse_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_maxfuse'] = maxfuse_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_maxfuse = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_maxfuse], 'maxfuse', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_maxfuse.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_other_embeddings",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_other_embeddings = synthetic_merged_other_embeddings[synthetic_merged_other_embeddings.obs_names.isin(common_names)]\nmaxfuse_merged_subset = maxfuse_merged[maxfuse_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nmaxfuse_merged_subset = maxfuse_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_maxfuse'] = maxfuse_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_maxfuse = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_maxfuse], 'maxfuse', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_maxfuse.pdf')\n# Compute MaxFuse cite_seq confusion matrix (using aligned data)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_merged_subset",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_merged_subset = maxfuse_merged[maxfuse_merged.obs_names.isin(common_names)]\n# Align by obs_names (should already be aligned, but ensure order matches)\nmaxfuse_merged_subset = maxfuse_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_maxfuse'] = maxfuse_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_maxfuse = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_maxfuse], 'maxfuse', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_maxfuse.pdf')\n# Compute MaxFuse cite_seq confusion matrix (using aligned data)\nprint(\"Computing MaxFuse cite_seq confusion matrix...\")",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "maxfuse_merged_subset",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "maxfuse_merged_subset = maxfuse_merged_subset[synthetic_merged_other_embeddings.obs_names]\nsynthetic_merged_other_embeddings.obsm['X_maxfuse'] = maxfuse_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_maxfuse = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_maxfuse], 'maxfuse', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_maxfuse.pdf')\n# Compute MaxFuse cite_seq confusion matrix (using aligned data)\nprint(\"Computing MaxFuse cite_seq confusion matrix...\")\ncm_maxfuse_cite_seq = compute_confusion_matrix(maxfuse_rna_aligned, maxfuse_protein_aligned)\nct_cf_plot(cm_maxfuse_cite_seq, 'MaxFuse', 'XX%', 'fig_khh/synthetic_confusion_matrix_maxfuse.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "synthetic_merged_other_embeddings.obsm['X_maxfuse']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "synthetic_merged_other_embeddings.obsm['X_maxfuse'] = maxfuse_merged_subset.obsm['X_umap']\n# Recompute random_indices after filtering\nrandom_indices_maxfuse = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_maxfuse], 'maxfuse', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_maxfuse.pdf')\n# Compute MaxFuse cite_seq confusion matrix (using aligned data)\nprint(\"Computing MaxFuse cite_seq confusion matrix...\")\ncm_maxfuse_cite_seq = compute_confusion_matrix(maxfuse_rna_aligned, maxfuse_protein_aligned)\nct_cf_plot(cm_maxfuse_cite_seq, 'MaxFuse', 'XX%', 'fig_khh/synthetic_confusion_matrix_maxfuse.pdf')\n# ### visualize entangled Z embedding - tonsil data",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "random_indices_maxfuse",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "random_indices_maxfuse = np.random.permutation(list(range(synthetic_merged_other_embeddings.shape[0])))\nsc.pl.embedding(synthetic_merged_other_embeddings[random_indices_maxfuse], 'maxfuse', color=['modality','major_cell_types','minor_cell_types','CN'], \n                palette=synthetic_palette, s=10, save='_synthetic_merged_maxfuse.pdf')\n# Compute MaxFuse cite_seq confusion matrix (using aligned data)\nprint(\"Computing MaxFuse cite_seq confusion matrix...\")\ncm_maxfuse_cite_seq = compute_confusion_matrix(maxfuse_rna_aligned, maxfuse_protein_aligned)\nct_cf_plot(cm_maxfuse_cite_seq, 'MaxFuse', 'XX%', 'fig_khh/synthetic_confusion_matrix_maxfuse.pdf')\n# ### visualize entangled Z embedding - tonsil data\n# In[ ]:\nrs = np.random.RandomState(42)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cm_maxfuse_cite_seq",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cm_maxfuse_cite_seq = compute_confusion_matrix(maxfuse_rna_aligned, maxfuse_protein_aligned)\nct_cf_plot(cm_maxfuse_cite_seq, 'MaxFuse', 'XX%', 'fig_khh/synthetic_confusion_matrix_maxfuse.pdf')\n# ### visualize entangled Z embedding - tonsil data\n# In[ ]:\nrs = np.random.RandomState(42)\nunique_labels = adata_protein_df.index.unique()\nlabel_pick = pd.Series(rs.rand(len(unique_labels)) < 0.20, index=unique_labels)\nmask = adata_protein_df.index.to_series().map(label_pick).to_numpy()\n# In[ ]:\nprint(tonsil_protein_scVI.shape)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "rs",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "rs = np.random.RandomState(42)\nunique_labels = adata_protein_df.index.unique()\nlabel_pick = pd.Series(rs.rand(len(unique_labels)) < 0.20, index=unique_labels)\nmask = adata_protein_df.index.to_series().map(label_pick).to_numpy()\n# In[ ]:\nprint(tonsil_protein_scVI.shape)\nprint(tonsil_rna_scVI.shape)\n# In[ ]:\nadata_protein_df = tonsil_protein.obs.copy()\nadata_protein_df['modality'] = 'CODEX'",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "unique_labels",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "unique_labels = adata_protein_df.index.unique()\nlabel_pick = pd.Series(rs.rand(len(unique_labels)) < 0.20, index=unique_labels)\nmask = adata_protein_df.index.to_series().map(label_pick).to_numpy()\n# In[ ]:\nprint(tonsil_protein_scVI.shape)\nprint(tonsil_rna_scVI.shape)\n# In[ ]:\nadata_protein_df = tonsil_protein.obs.copy()\nadata_protein_df['modality'] = 'CODEX'\nadata_rna_df = tonsil_rna.obs.copy()",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "label_pick",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "label_pick = pd.Series(rs.rand(len(unique_labels)) < 0.20, index=unique_labels)\nmask = adata_protein_df.index.to_series().map(label_pick).to_numpy()\n# In[ ]:\nprint(tonsil_protein_scVI.shape)\nprint(tonsil_rna_scVI.shape)\n# In[ ]:\nadata_protein_df = tonsil_protein.obs.copy()\nadata_protein_df['modality'] = 'CODEX'\nadata_rna_df = tonsil_rna.obs.copy()\nz_keys = []",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "mask",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "mask = adata_protein_df.index.to_series().map(label_pick).to_numpy()\n# In[ ]:\nprint(tonsil_protein_scVI.shape)\nprint(tonsil_rna_scVI.shape)\n# In[ ]:\nadata_protein_df = tonsil_protein.obs.copy()\nadata_protein_df['modality'] = 'CODEX'\nadata_rna_df = tonsil_rna.obs.copy()\nz_keys = []\nfor z in range(60):",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_protein_df",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_protein_df = tonsil_protein.obs.copy()\nadata_protein_df['modality'] = 'CODEX'\nadata_rna_df = tonsil_rna.obs.copy()\nz_keys = []\nfor z in range(60):\n    z_keys.append(f'z{z}')\nadata_rna_df['modality'] = 'scRNA-seq'\nadata_protein_df[z_keys] = tonsil_protein_scVI\nadata_rna_df[z_keys] = tonsil_rna_scVI\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_protein_df['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_protein_df['modality'] = 'CODEX'\nadata_rna_df = tonsil_rna.obs.copy()\nz_keys = []\nfor z in range(60):\n    z_keys.append(f'z{z}')\nadata_rna_df['modality'] = 'scRNA-seq'\nadata_protein_df[z_keys] = tonsil_protein_scVI\nadata_rna_df[z_keys] = tonsil_rna_scVI\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\ntonsil_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_rna_df",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_rna_df = tonsil_rna.obs.copy()\nz_keys = []\nfor z in range(60):\n    z_keys.append(f'z{z}')\nadata_rna_df['modality'] = 'scRNA-seq'\nadata_protein_df[z_keys] = tonsil_protein_scVI\nadata_rna_df[z_keys] = tonsil_rna_scVI\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\ntonsil_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\ntonsil_merged.obsm['X_scVI'] = tonsil_merged.X.copy()",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "z_keys",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "z_keys = []\nfor z in range(60):\n    z_keys.append(f'z{z}')\nadata_rna_df['modality'] = 'scRNA-seq'\nadata_protein_df[z_keys] = tonsil_protein_scVI\nadata_rna_df[z_keys] = tonsil_rna_scVI\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\ntonsil_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\ntonsil_merged.obsm['X_scVI'] = tonsil_merged.X.copy()\nprint(tonsil_merged.shape)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_rna_df['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_rna_df['modality'] = 'scRNA-seq'\nadata_protein_df[z_keys] = tonsil_protein_scVI\nadata_rna_df[z_keys] = tonsil_rna_scVI\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\ntonsil_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\ntonsil_merged.obsm['X_scVI'] = tonsil_merged.X.copy()\nprint(tonsil_merged.shape)\nadata_merged_df_subsampled = pd.concat([adata_protein_df.loc[mask,:], adata_rna_df], axis=0)\ntonsil_merged_subsampled = ad.AnnData(adata_merged_df_subsampled[z_keys], obs=adata_merged_df_subsampled.copy())\ntonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_protein_df[z_keys]",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_protein_df[z_keys] = tonsil_protein_scVI\nadata_rna_df[z_keys] = tonsil_rna_scVI\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\ntonsil_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\ntonsil_merged.obsm['X_scVI'] = tonsil_merged.X.copy()\nprint(tonsil_merged.shape)\nadata_merged_df_subsampled = pd.concat([adata_protein_df.loc[mask,:], adata_rna_df], axis=0)\ntonsil_merged_subsampled = ad.AnnData(adata_merged_df_subsampled[z_keys], obs=adata_merged_df_subsampled.copy())\ntonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()\nprint(tonsil_merged_subsampled.shape)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_rna_df[z_keys]",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_rna_df[z_keys] = tonsil_rna_scVI\nadata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\ntonsil_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\ntonsil_merged.obsm['X_scVI'] = tonsil_merged.X.copy()\nprint(tonsil_merged.shape)\nadata_merged_df_subsampled = pd.concat([adata_protein_df.loc[mask,:], adata_rna_df], axis=0)\ntonsil_merged_subsampled = ad.AnnData(adata_merged_df_subsampled[z_keys], obs=adata_merged_df_subsampled.copy())\ntonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()\nprint(tonsil_merged_subsampled.shape)\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_merged_df",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_merged_df = pd.concat([adata_protein_df, adata_rna_df], axis=0)\ntonsil_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\ntonsil_merged.obsm['X_scVI'] = tonsil_merged.X.copy()\nprint(tonsil_merged.shape)\nadata_merged_df_subsampled = pd.concat([adata_protein_df.loc[mask,:], adata_rna_df], axis=0)\ntonsil_merged_subsampled = ad.AnnData(adata_merged_df_subsampled[z_keys], obs=adata_merged_df_subsampled.copy())\ntonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()\nprint(tonsil_merged_subsampled.shape)\n# In[ ]:\nprint(tonsil_merged.obs.value_counts(['modality']))",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged = ad.AnnData(adata_merged_df[z_keys], obs=adata_merged_df.copy())\ntonsil_merged.obsm['X_scVI'] = tonsil_merged.X.copy()\nprint(tonsil_merged.shape)\nadata_merged_df_subsampled = pd.concat([adata_protein_df.loc[mask,:], adata_rna_df], axis=0)\ntonsil_merged_subsampled = ad.AnnData(adata_merged_df_subsampled[z_keys], obs=adata_merged_df_subsampled.copy())\ntonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()\nprint(tonsil_merged_subsampled.shape)\n# In[ ]:\nprint(tonsil_merged.obs.value_counts(['modality']))\nprint(tonsil_merged_subsampled.obs.value_counts(['modality']))",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged.obsm['X_scVI']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged.obsm['X_scVI'] = tonsil_merged.X.copy()\nprint(tonsil_merged.shape)\nadata_merged_df_subsampled = pd.concat([adata_protein_df.loc[mask,:], adata_rna_df], axis=0)\ntonsil_merged_subsampled = ad.AnnData(adata_merged_df_subsampled[z_keys], obs=adata_merged_df_subsampled.copy())\ntonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()\nprint(tonsil_merged_subsampled.shape)\n# In[ ]:\nprint(tonsil_merged.obs.value_counts(['modality']))\nprint(tonsil_merged_subsampled.obs.value_counts(['modality']))\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "adata_merged_df_subsampled",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "adata_merged_df_subsampled = pd.concat([adata_protein_df.loc[mask,:], adata_rna_df], axis=0)\ntonsil_merged_subsampled = ad.AnnData(adata_merged_df_subsampled[z_keys], obs=adata_merged_df_subsampled.copy())\ntonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()\nprint(tonsil_merged_subsampled.shape)\n# In[ ]:\nprint(tonsil_merged.obs.value_counts(['modality']))\nprint(tonsil_merged_subsampled.obs.value_counts(['modality']))\n# In[ ]:\nsc.pp.neighbors(tonsil_merged, use_rep='X_scVI')\nsc.tl.umap(tonsil_merged, min_dist=0.3)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged_subsampled",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged_subsampled = ad.AnnData(adata_merged_df_subsampled[z_keys], obs=adata_merged_df_subsampled.copy())\ntonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()\nprint(tonsil_merged_subsampled.shape)\n# In[ ]:\nprint(tonsil_merged.obs.value_counts(['modality']))\nprint(tonsil_merged_subsampled.obs.value_counts(['modality']))\n# In[ ]:\nsc.pp.neighbors(tonsil_merged, use_rep='X_scVI')\nsc.tl.umap(tonsil_merged, min_dist=0.3)\nsc.pl.umap(tonsil_merged, color=['modality','cell_types'])",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged_subsampled.obsm['X_scVI']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged_subsampled.obsm['X_scVI'] = tonsil_merged_subsampled.X.copy()\nprint(tonsil_merged_subsampled.shape)\n# In[ ]:\nprint(tonsil_merged.obs.value_counts(['modality']))\nprint(tonsil_merged_subsampled.obs.value_counts(['modality']))\n# In[ ]:\nsc.pp.neighbors(tonsil_merged, use_rep='X_scVI')\nsc.tl.umap(tonsil_merged, min_dist=0.3)\nsc.pl.umap(tonsil_merged, color=['modality','cell_types'])\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_CN_assignments",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_CN_assignments = pd.concat([tonsil_protein_CN_assignments, tonsil_rna_CN_assignments], axis=0)\ntonsil_CN_assignments.index = tonsil_CN_assignments.index.astype(str)\n# In[ ]:\ntonsil_merged_subsampled.obs['CN'] = tonsil_CN_assignments.loc[tonsil_merged_subsampled.obs_names.values, 'CN']\n# In[ ]:\nsc.pl.umap(tonsil_merged_subsampled, color=['modality','cell_types','CN'], \n           palette=tonsil_palette, s=10, wspace=0.2, save='_tonsil_merged_subsampled.pdf')\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_CN_assignments.index",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_CN_assignments.index = tonsil_CN_assignments.index.astype(str)\n# In[ ]:\ntonsil_merged_subsampled.obs['CN'] = tonsil_CN_assignments.loc[tonsil_merged_subsampled.obs_names.values, 'CN']\n# In[ ]:\nsc.pl.umap(tonsil_merged_subsampled, color=['modality','cell_types','CN'], \n           palette=tonsil_palette, s=10, wspace=0.2, save='_tonsil_merged_subsampled.pdf')\n# In[ ]:\nsc.pl.umap(tonsil_merged_subsampled[tonsil_merged_subsampled.obs['modality'] == 'scRNA-seq'], color=['cell_types','CN'],",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged_subsampled.obs['CN']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged_subsampled.obs['CN'] = tonsil_CN_assignments.loc[tonsil_merged_subsampled.obs_names.values, 'CN']\n# In[ ]:\nsc.pl.umap(tonsil_merged_subsampled, color=['modality','cell_types','CN'], \n           palette=tonsil_palette, s=10, wspace=0.2, save='_tonsil_merged_subsampled.pdf')\n# In[ ]:\nsc.pl.umap(tonsil_merged_subsampled[tonsil_merged_subsampled.obs['modality'] == 'scRNA-seq'], color=['cell_types','CN'],\n           palette=tonsil_palette, s=10, legend_loc=None)\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged_subsampled_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged_subsampled_copy = tonsil_merged_subsampled.copy() # prevent NA overwriting\nsc.pl.umap(tonsil_merged_subsampled_copy, color=['cell_types','CN'], mask_obs=(tonsil_merged_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n           palette=tonsil_palette, s=10, legend_loc=None, save='_tonsil_merged_subsampled_RNA_only.pdf')\ntonsil_merged_subsampled_copy = tonsil_merged_subsampled.copy() # prevent NA overwriting\nsc.pl.umap(tonsil_merged_subsampled_copy, color=['cell_types','CN'], mask_obs=(tonsil_merged_subsampled_copy.obs['modality'] == 'CODEX'),\n           palette=tonsil_palette, s=10, legend_loc=None, save='_tonsil_merged_subsampled_prot_only.pdf')\n# ### visualize other integration embeddings - tonsil\n# In[ ]:\ntonsil_merged_subsampled_other_embeddings = tonsil_merged_subsampled.copy()\n# In[ ]:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged_subsampled_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged_subsampled_copy = tonsil_merged_subsampled.copy() # prevent NA overwriting\nsc.pl.umap(tonsil_merged_subsampled_copy, color=['cell_types','CN'], mask_obs=(tonsil_merged_subsampled_copy.obs['modality'] == 'CODEX'),\n           palette=tonsil_palette, s=10, legend_loc=None, save='_tonsil_merged_subsampled_prot_only.pdf')\n# ### visualize other integration embeddings - tonsil\n# In[ ]:\ntonsil_merged_subsampled_other_embeddings = tonsil_merged_subsampled.copy()\n# In[ ]:\n# Load scMODAL adata objects for tonsil and extract UMAP from obsm['X_umap']\ntonsil_scmodal_rna_files = glob.glob('model_comparison/outputs/scmodal_tonsil/*rna*.h5ad')\ntonsil_scmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_tonsil/*protein*.h5ad') + \\",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged_subsampled_other_embeddings",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged_subsampled_other_embeddings = tonsil_merged_subsampled.copy()\n# In[ ]:\n# Load scMODAL adata objects for tonsil and extract UMAP from obsm['X_umap']\ntonsil_scmodal_rna_files = glob.glob('model_comparison/outputs/scmodal_tonsil/*rna*.h5ad')\ntonsil_scmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_tonsil/*protein*.h5ad') + \\\n                               glob.glob('model_comparison/outputs/scmodal_tonsil/*prot*.h5ad')\nif not tonsil_scmodal_rna_files:\n    raise FileNotFoundError(\"scMODAL RNA output files not found in 'model_comparison/outputs/scmodal_tonsil/'\")\nif not tonsil_scmodal_protein_files:\n    raise FileNotFoundError(\"scMODAL protein output files not found in 'model_comparison/outputs/scmodal_tonsil/'\")",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_rna_files",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_rna_files = glob.glob('model_comparison/outputs/scmodal_tonsil/*rna*.h5ad')\ntonsil_scmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_tonsil/*protein*.h5ad') + \\\n                               glob.glob('model_comparison/outputs/scmodal_tonsil/*prot*.h5ad')\nif not tonsil_scmodal_rna_files:\n    raise FileNotFoundError(\"scMODAL RNA output files not found in 'model_comparison/outputs/scmodal_tonsil/'\")\nif not tonsil_scmodal_protein_files:\n    raise FileNotFoundError(\"scMODAL protein output files not found in 'model_comparison/outputs/scmodal_tonsil/'\")\ntonsil_scmodal_rna_file = max(tonsil_scmodal_rna_files, key=os.path.getmtime)\ntonsil_scmodal_protein_file = max(tonsil_scmodal_protein_files, key=os.path.getmtime)\ntonsil_scmodal_rna = sc.read_h5ad(tonsil_scmodal_rna_file)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_protein_files",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_protein_files = glob.glob('model_comparison/outputs/scmodal_tonsil/*protein*.h5ad') + \\\n                               glob.glob('model_comparison/outputs/scmodal_tonsil/*prot*.h5ad')\nif not tonsil_scmodal_rna_files:\n    raise FileNotFoundError(\"scMODAL RNA output files not found in 'model_comparison/outputs/scmodal_tonsil/'\")\nif not tonsil_scmodal_protein_files:\n    raise FileNotFoundError(\"scMODAL protein output files not found in 'model_comparison/outputs/scmodal_tonsil/'\")\ntonsil_scmodal_rna_file = max(tonsil_scmodal_rna_files, key=os.path.getmtime)\ntonsil_scmodal_protein_file = max(tonsil_scmodal_protein_files, key=os.path.getmtime)\ntonsil_scmodal_rna = sc.read_h5ad(tonsil_scmodal_rna_file)\ntonsil_scmodal_protein = sc.read_h5ad(tonsil_scmodal_protein_file)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_rna_file",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_rna_file = max(tonsil_scmodal_rna_files, key=os.path.getmtime)\ntonsil_scmodal_protein_file = max(tonsil_scmodal_protein_files, key=os.path.getmtime)\ntonsil_scmodal_rna = sc.read_h5ad(tonsil_scmodal_rna_file)\ntonsil_scmodal_protein = sc.read_h5ad(tonsil_scmodal_protein_file)\n# Align scMODAL tonsil data with ARCADIA tonsil data using the same logic as compare_results.py\nprint(\"Aligning scMODAL tonsil data with ARCADIA tonsil data...\")\ntonsil_rna_aligned, tonsil_scmodal_rna_aligned, _ = align_data(tonsil_rna, tonsil_scmodal_rna, \"rna\", \"scmodal\")\ntonsil_protein_aligned, tonsil_scmodal_protein_aligned, _ = align_data(tonsil_protein, tonsil_scmodal_protein, \"protein\", \"scmodal\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in tonsil_scmodal_rna_aligned.obsm:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_protein_file",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_protein_file = max(tonsil_scmodal_protein_files, key=os.path.getmtime)\ntonsil_scmodal_rna = sc.read_h5ad(tonsil_scmodal_rna_file)\ntonsil_scmodal_protein = sc.read_h5ad(tonsil_scmodal_protein_file)\n# Align scMODAL tonsil data with ARCADIA tonsil data using the same logic as compare_results.py\nprint(\"Aligning scMODAL tonsil data with ARCADIA tonsil data...\")\ntonsil_rna_aligned, tonsil_scmodal_rna_aligned, _ = align_data(tonsil_rna, tonsil_scmodal_rna, \"rna\", \"scmodal\")\ntonsil_protein_aligned, tonsil_scmodal_protein_aligned, _ = align_data(tonsil_protein, tonsil_scmodal_protein, \"protein\", \"scmodal\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in tonsil_scmodal_rna_aligned.obsm:\n    if 'latent' in tonsil_scmodal_rna_aligned.obsm:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_rna",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_rna = sc.read_h5ad(tonsil_scmodal_rna_file)\ntonsil_scmodal_protein = sc.read_h5ad(tonsil_scmodal_protein_file)\n# Align scMODAL tonsil data with ARCADIA tonsil data using the same logic as compare_results.py\nprint(\"Aligning scMODAL tonsil data with ARCADIA tonsil data...\")\ntonsil_rna_aligned, tonsil_scmodal_rna_aligned, _ = align_data(tonsil_rna, tonsil_scmodal_rna, \"rna\", \"scmodal\")\ntonsil_protein_aligned, tonsil_scmodal_protein_aligned, _ = align_data(tonsil_protein, tonsil_scmodal_protein, \"protein\", \"scmodal\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in tonsil_scmodal_rna_aligned.obsm:\n    if 'latent' in tonsil_scmodal_rna_aligned.obsm:\n        print(\"Computing UMAP for tonsil scMODAL RNA from latent representation...\")",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_protein",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_protein = sc.read_h5ad(tonsil_scmodal_protein_file)\n# Align scMODAL tonsil data with ARCADIA tonsil data using the same logic as compare_results.py\nprint(\"Aligning scMODAL tonsil data with ARCADIA tonsil data...\")\ntonsil_rna_aligned, tonsil_scmodal_rna_aligned, _ = align_data(tonsil_rna, tonsil_scmodal_rna, \"rna\", \"scmodal\")\ntonsil_protein_aligned, tonsil_scmodal_protein_aligned, _ = align_data(tonsil_protein, tonsil_scmodal_protein, \"protein\", \"scmodal\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in tonsil_scmodal_rna_aligned.obsm:\n    if 'latent' in tonsil_scmodal_rna_aligned.obsm:\n        print(\"Computing UMAP for tonsil scMODAL RNA from latent representation...\")\n        tonsil_scmodal_rna_aligned.obsm['X_latent'] = tonsil_scmodal_rna_aligned.obsm['latent']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_rna_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_rna_aligned.obs['modality'] = 'scRNA-seq'\ntonsil_scmodal_protein_aligned.obs['modality'] = 'CODEX'\ntonsil_scmodal_adata = sc.concat([tonsil_scmodal_protein_aligned, tonsil_scmodal_rna_aligned], join='outer', label='modality', keys=['CODEX', 'scRNA-seq'])\ntonsil_scmodal_adata.obsm['X_scmodal'] = np.vstack([\n    tonsil_scmodal_protein_aligned.obsm['X_umap'],\n    tonsil_scmodal_rna_aligned.obsm['X_umap']\n])\n# subsample protein 20%\ntonsil_scmodal_adata_subsampled = []\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'CODEX'].copy())",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_protein_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_protein_aligned.obs['modality'] = 'CODEX'\ntonsil_scmodal_adata = sc.concat([tonsil_scmodal_protein_aligned, tonsil_scmodal_rna_aligned], join='outer', label='modality', keys=['CODEX', 'scRNA-seq'])\ntonsil_scmodal_adata.obsm['X_scmodal'] = np.vstack([\n    tonsil_scmodal_protein_aligned.obsm['X_umap'],\n    tonsil_scmodal_rna_aligned.obsm['X_umap']\n])\n# subsample protein 20%\ntonsil_scmodal_adata_subsampled = []\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'CODEX'].copy())\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'scRNA-seq'].copy())",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_adata",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_adata = sc.concat([tonsil_scmodal_protein_aligned, tonsil_scmodal_rna_aligned], join='outer', label='modality', keys=['CODEX', 'scRNA-seq'])\ntonsil_scmodal_adata.obsm['X_scmodal'] = np.vstack([\n    tonsil_scmodal_protein_aligned.obsm['X_umap'],\n    tonsil_scmodal_rna_aligned.obsm['X_umap']\n])\n# subsample protein 20%\ntonsil_scmodal_adata_subsampled = []\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'CODEX'].copy())\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'scRNA-seq'].copy())\ntonsil_scmodal_adata_subsampled[0] = tonsil_scmodal_adata_subsampled[0][mask]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_adata.obsm['X_scmodal']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_adata.obsm['X_scmodal'] = np.vstack([\n    tonsil_scmodal_protein_aligned.obsm['X_umap'],\n    tonsil_scmodal_rna_aligned.obsm['X_umap']\n])\n# subsample protein 20%\ntonsil_scmodal_adata_subsampled = []\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'CODEX'].copy())\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'scRNA-seq'].copy())\ntonsil_scmodal_adata_subsampled[0] = tonsil_scmodal_adata_subsampled[0][mask]\ntonsil_scmodal_adata_subsampled = sc.concat(tonsil_scmodal_adata_subsampled)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_adata_subsampled",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_adata_subsampled = []\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'CODEX'].copy())\ntonsil_scmodal_adata_subsampled.append(tonsil_scmodal_adata[tonsil_scmodal_adata.obs['modality'] == 'scRNA-seq'].copy())\ntonsil_scmodal_adata_subsampled[0] = tonsil_scmodal_adata_subsampled[0][mask]\ntonsil_scmodal_adata_subsampled = sc.concat(tonsil_scmodal_adata_subsampled)\nrandom_indices = np.random.permutation(list(range(tonsil_scmodal_adata_subsampled.shape[0])))\nsc.pl.embedding(tonsil_scmodal_adata_subsampled[random_indices], 'scmodal', color=['modality','cell_types','CN'],\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal.pdf')\ntonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'CODEX'),",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_adata_subsampled[0]",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_adata_subsampled[0] = tonsil_scmodal_adata_subsampled[0][mask]\ntonsil_scmodal_adata_subsampled = sc.concat(tonsil_scmodal_adata_subsampled)\nrandom_indices = np.random.permutation(list(range(tonsil_scmodal_adata_subsampled.shape[0])))\nsc.pl.embedding(tonsil_scmodal_adata_subsampled[random_indices], 'scmodal', color=['modality','cell_types','CN'],\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal.pdf')\ntonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal_CN_codex.pdf', show=False)\ntonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_adata_subsampled",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_adata_subsampled = sc.concat(tonsil_scmodal_adata_subsampled)\nrandom_indices = np.random.permutation(list(range(tonsil_scmodal_adata_subsampled.shape[0])))\nsc.pl.embedding(tonsil_scmodal_adata_subsampled[random_indices], 'scmodal', color=['modality','cell_types','CN'],\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal.pdf')\ntonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal_CN_codex.pdf', show=False)\ntonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal_CN_rna.pdf', show=False)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "random_indices",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "random_indices = np.random.permutation(list(range(tonsil_scmodal_adata_subsampled.shape[0])))\nsc.pl.embedding(tonsil_scmodal_adata_subsampled[random_indices], 'scmodal', color=['modality','cell_types','CN'],\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal.pdf')\ntonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal_CN_codex.pdf', show=False)\ntonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal_CN_rna.pdf', show=False)\n# Compute scMODAL tonsil confusion matrix (using aligned data)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_adata_subsampled_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal_CN_codex.pdf', show=False)\ntonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal_CN_rna.pdf', show=False)\n# Compute scMODAL tonsil confusion matrix (using aligned data)\nprint(\"Computing scMODAL tonsil confusion matrix...\")\ncm_scmodal_tonsil = compute_confusion_matrix(tonsil_scmodal_rna_aligned, tonsil_scmodal_protein_aligned)\nct_cf_plot_tonsil(cm_scmodal_tonsil, 'scModal', 'XX%', 'fig_khh/tonsil_confusion_matrix_scmodal.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_scmodal_adata_subsampled_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_scmodal_adata_subsampled_copy = tonsil_scmodal_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_scmodal_adata_subsampled_copy, 'scmodal', color=['CN'], mask_obs=(tonsil_scmodal_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_scmodal_CN_rna.pdf', show=False)\n# Compute scMODAL tonsil confusion matrix (using aligned data)\nprint(\"Computing scMODAL tonsil confusion matrix...\")\ncm_scmodal_tonsil = compute_confusion_matrix(tonsil_scmodal_rna_aligned, tonsil_scmodal_protein_aligned)\nct_cf_plot_tonsil(cm_scmodal_tonsil, 'scModal', 'XX%', 'fig_khh/tonsil_confusion_matrix_scmodal.pdf')\n# In[ ]:\n# Load MaxFuse adata objects for tonsil and extract UMAP from obsm['X_umap']\ntonsil_maxfuse_rna_files = glob.glob('model_comparison/outputs/maxfuse_tonsil/*rna*.h5ad')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cm_scmodal_tonsil",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cm_scmodal_tonsil = compute_confusion_matrix(tonsil_scmodal_rna_aligned, tonsil_scmodal_protein_aligned)\nct_cf_plot_tonsil(cm_scmodal_tonsil, 'scModal', 'XX%', 'fig_khh/tonsil_confusion_matrix_scmodal.pdf')\n# In[ ]:\n# Load MaxFuse adata objects for tonsil and extract UMAP from obsm['X_umap']\ntonsil_maxfuse_rna_files = glob.glob('model_comparison/outputs/maxfuse_tonsil/*rna*.h5ad')\ntonsil_maxfuse_protein_files = glob.glob('model_comparison/outputs/maxfuse_tonsil/*protein*.h5ad') + \\\n                               glob.glob('model_comparison/outputs/maxfuse_tonsil/*prot*.h5ad')\nif not tonsil_maxfuse_rna_files:\n    raise FileNotFoundError(\"MaxFuse RNA output files not found in 'model_comparison/outputs/maxfuse_tonsil/'\")\nif not tonsil_maxfuse_protein_files:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_rna_files",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_rna_files = glob.glob('model_comparison/outputs/maxfuse_tonsil/*rna*.h5ad')\ntonsil_maxfuse_protein_files = glob.glob('model_comparison/outputs/maxfuse_tonsil/*protein*.h5ad') + \\\n                               glob.glob('model_comparison/outputs/maxfuse_tonsil/*prot*.h5ad')\nif not tonsil_maxfuse_rna_files:\n    raise FileNotFoundError(\"MaxFuse RNA output files not found in 'model_comparison/outputs/maxfuse_tonsil/'\")\nif not tonsil_maxfuse_protein_files:\n    raise FileNotFoundError(\"MaxFuse protein output files not found in 'model_comparison/outputs/maxfuse_tonsil/'\")\ntonsil_maxfuse_rna_file = max(tonsil_maxfuse_rna_files, key=os.path.getmtime)\ntonsil_maxfuse_protein_file = max(tonsil_maxfuse_protein_files, key=os.path.getmtime)\ntonsil_maxfuse_rna = sc.read_h5ad(tonsil_maxfuse_rna_file)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_protein_files",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_protein_files = glob.glob('model_comparison/outputs/maxfuse_tonsil/*protein*.h5ad') + \\\n                               glob.glob('model_comparison/outputs/maxfuse_tonsil/*prot*.h5ad')\nif not tonsil_maxfuse_rna_files:\n    raise FileNotFoundError(\"MaxFuse RNA output files not found in 'model_comparison/outputs/maxfuse_tonsil/'\")\nif not tonsil_maxfuse_protein_files:\n    raise FileNotFoundError(\"MaxFuse protein output files not found in 'model_comparison/outputs/maxfuse_tonsil/'\")\ntonsil_maxfuse_rna_file = max(tonsil_maxfuse_rna_files, key=os.path.getmtime)\ntonsil_maxfuse_protein_file = max(tonsil_maxfuse_protein_files, key=os.path.getmtime)\ntonsil_maxfuse_rna = sc.read_h5ad(tonsil_maxfuse_rna_file)\ntonsil_maxfuse_protein = sc.read_h5ad(tonsil_maxfuse_protein_file)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_rna_file",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_rna_file = max(tonsil_maxfuse_rna_files, key=os.path.getmtime)\ntonsil_maxfuse_protein_file = max(tonsil_maxfuse_protein_files, key=os.path.getmtime)\ntonsil_maxfuse_rna = sc.read_h5ad(tonsil_maxfuse_rna_file)\ntonsil_maxfuse_protein = sc.read_h5ad(tonsil_maxfuse_protein_file)\n# Align MaxFuse tonsil data with ARCADIA tonsil data using the same logic as compare_results.py\nprint(\"Aligning MaxFuse tonsil data with ARCADIA tonsil data...\")\ntonsil_rna_aligned_mf, tonsil_maxfuse_rna_aligned, _ = align_data(tonsil_rna, tonsil_maxfuse_rna, \"rna\", \"maxfuse\")\ntonsil_protein_aligned_mf, tonsil_maxfuse_protein_aligned, _ = align_data(tonsil_protein, tonsil_maxfuse_protein, \"protein\", \"maxfuse\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in tonsil_maxfuse_rna_aligned.obsm:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_protein_file",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_protein_file = max(tonsil_maxfuse_protein_files, key=os.path.getmtime)\ntonsil_maxfuse_rna = sc.read_h5ad(tonsil_maxfuse_rna_file)\ntonsil_maxfuse_protein = sc.read_h5ad(tonsil_maxfuse_protein_file)\n# Align MaxFuse tonsil data with ARCADIA tonsil data using the same logic as compare_results.py\nprint(\"Aligning MaxFuse tonsil data with ARCADIA tonsil data...\")\ntonsil_rna_aligned_mf, tonsil_maxfuse_rna_aligned, _ = align_data(tonsil_rna, tonsil_maxfuse_rna, \"rna\", \"maxfuse\")\ntonsil_protein_aligned_mf, tonsil_maxfuse_protein_aligned, _ = align_data(tonsil_protein, tonsil_maxfuse_protein, \"protein\", \"maxfuse\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in tonsil_maxfuse_rna_aligned.obsm:\n    if 'latent' in tonsil_maxfuse_rna_aligned.obsm:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_rna",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_rna = sc.read_h5ad(tonsil_maxfuse_rna_file)\ntonsil_maxfuse_protein = sc.read_h5ad(tonsil_maxfuse_protein_file)\n# Align MaxFuse tonsil data with ARCADIA tonsil data using the same logic as compare_results.py\nprint(\"Aligning MaxFuse tonsil data with ARCADIA tonsil data...\")\ntonsil_rna_aligned_mf, tonsil_maxfuse_rna_aligned, _ = align_data(tonsil_rna, tonsil_maxfuse_rna, \"rna\", \"maxfuse\")\ntonsil_protein_aligned_mf, tonsil_maxfuse_protein_aligned, _ = align_data(tonsil_protein, tonsil_maxfuse_protein, \"protein\", \"maxfuse\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in tonsil_maxfuse_rna_aligned.obsm:\n    if 'latent' in tonsil_maxfuse_rna_aligned.obsm:\n        print(\"Computing UMAP for tonsil MaxFuse RNA from latent representation...\")",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_protein",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_protein = sc.read_h5ad(tonsil_maxfuse_protein_file)\n# Align MaxFuse tonsil data with ARCADIA tonsil data using the same logic as compare_results.py\nprint(\"Aligning MaxFuse tonsil data with ARCADIA tonsil data...\")\ntonsil_rna_aligned_mf, tonsil_maxfuse_rna_aligned, _ = align_data(tonsil_rna, tonsil_maxfuse_rna, \"rna\", \"maxfuse\")\ntonsil_protein_aligned_mf, tonsil_maxfuse_protein_aligned, _ = align_data(tonsil_protein, tonsil_maxfuse_protein, \"protein\", \"maxfuse\")\n# Check if UMAP exists in obsm, if not compute it from latent representation\nif 'X_umap' not in tonsil_maxfuse_rna_aligned.obsm:\n    if 'latent' in tonsil_maxfuse_rna_aligned.obsm:\n        print(\"Computing UMAP for tonsil MaxFuse RNA from latent representation...\")\n        tonsil_maxfuse_rna_aligned.obsm['X_latent'] = tonsil_maxfuse_rna_aligned.obsm['latent']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_rna_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_rna_aligned.obs['modality'] = 'scRNA-seq'\ntonsil_maxfuse_protein_aligned.obs['modality'] = 'CODEX'\ntonsil_maxfuse_adata = sc.concat([tonsil_maxfuse_protein_aligned, tonsil_maxfuse_rna_aligned], join='outer', label='modality', keys=['CODEX', 'scRNA-seq'])\ntonsil_maxfuse_adata.obsm['X_maxfuse'] = np.vstack([\n    tonsil_maxfuse_protein_aligned.obsm['X_umap'],\n    tonsil_maxfuse_rna_aligned.obsm['X_umap']\n])\n# subsample protein 20%\ntonsil_maxfuse_adata_subsampled = []\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'CODEX'].copy())",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_protein_aligned.obs['modality']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_protein_aligned.obs['modality'] = 'CODEX'\ntonsil_maxfuse_adata = sc.concat([tonsil_maxfuse_protein_aligned, tonsil_maxfuse_rna_aligned], join='outer', label='modality', keys=['CODEX', 'scRNA-seq'])\ntonsil_maxfuse_adata.obsm['X_maxfuse'] = np.vstack([\n    tonsil_maxfuse_protein_aligned.obsm['X_umap'],\n    tonsil_maxfuse_rna_aligned.obsm['X_umap']\n])\n# subsample protein 20%\ntonsil_maxfuse_adata_subsampled = []\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'CODEX'].copy())\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'scRNA-seq'].copy())",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_adata",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_adata = sc.concat([tonsil_maxfuse_protein_aligned, tonsil_maxfuse_rna_aligned], join='outer', label='modality', keys=['CODEX', 'scRNA-seq'])\ntonsil_maxfuse_adata.obsm['X_maxfuse'] = np.vstack([\n    tonsil_maxfuse_protein_aligned.obsm['X_umap'],\n    tonsil_maxfuse_rna_aligned.obsm['X_umap']\n])\n# subsample protein 20%\ntonsil_maxfuse_adata_subsampled = []\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'CODEX'].copy())\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'scRNA-seq'].copy())\ntonsil_maxfuse_adata_subsampled[0] = tonsil_maxfuse_adata_subsampled[0][mask]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_adata.obsm['X_maxfuse']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_adata.obsm['X_maxfuse'] = np.vstack([\n    tonsil_maxfuse_protein_aligned.obsm['X_umap'],\n    tonsil_maxfuse_rna_aligned.obsm['X_umap']\n])\n# subsample protein 20%\ntonsil_maxfuse_adata_subsampled = []\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'CODEX'].copy())\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'scRNA-seq'].copy())\ntonsil_maxfuse_adata_subsampled[0] = tonsil_maxfuse_adata_subsampled[0][mask]\ntonsil_maxfuse_adata_subsampled = sc.concat(tonsil_maxfuse_adata_subsampled)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_adata_subsampled",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_adata_subsampled = []\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'CODEX'].copy())\ntonsil_maxfuse_adata_subsampled.append(tonsil_maxfuse_adata[tonsil_maxfuse_adata.obs['modality'] == 'scRNA-seq'].copy())\ntonsil_maxfuse_adata_subsampled[0] = tonsil_maxfuse_adata_subsampled[0][mask]\ntonsil_maxfuse_adata_subsampled = sc.concat(tonsil_maxfuse_adata_subsampled)\nrandom_indices = np.random.permutation(list(range(tonsil_maxfuse_adata_subsampled.shape[0])))\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled[random_indices], 'maxfuse', color=['modality','cell_types','CN'],\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse.pdf')\ntonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'CODEX'),",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_adata_subsampled[0]",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_adata_subsampled[0] = tonsil_maxfuse_adata_subsampled[0][mask]\ntonsil_maxfuse_adata_subsampled = sc.concat(tonsil_maxfuse_adata_subsampled)\nrandom_indices = np.random.permutation(list(range(tonsil_maxfuse_adata_subsampled.shape[0])))\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled[random_indices], 'maxfuse', color=['modality','cell_types','CN'],\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse.pdf')\ntonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse_CN_codex.pdf', show=False)\ntonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_adata_subsampled",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_adata_subsampled = sc.concat(tonsil_maxfuse_adata_subsampled)\nrandom_indices = np.random.permutation(list(range(tonsil_maxfuse_adata_subsampled.shape[0])))\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled[random_indices], 'maxfuse', color=['modality','cell_types','CN'],\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse.pdf')\ntonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse_CN_codex.pdf', show=False)\ntonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse_CN_rna.pdf', show=False)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "random_indices",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "random_indices = np.random.permutation(list(range(tonsil_maxfuse_adata_subsampled.shape[0])))\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled[random_indices], 'maxfuse', color=['modality','cell_types','CN'],\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse.pdf')\ntonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse_CN_codex.pdf', show=False)\ntonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse_CN_rna.pdf', show=False)\n# Compute MaxFuse tonsil confusion matrix (using aligned data)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_adata_subsampled_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse_CN_codex.pdf', show=False)\ntonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse_CN_rna.pdf', show=False)\n# Compute MaxFuse tonsil confusion matrix (using aligned data)\nprint(\"Computing MaxFuse tonsil confusion matrix...\")\ncm_maxfuse_tonsil = compute_confusion_matrix(tonsil_maxfuse_rna_aligned, tonsil_maxfuse_protein_aligned)\nct_cf_plot_tonsil(cm_maxfuse_tonsil, 'MaxFuse', 'XX%', 'fig_khh/tonsil_confusion_matrix_maxfuse.pdf')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_maxfuse_adata_subsampled_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_maxfuse_adata_subsampled_copy = tonsil_maxfuse_adata_subsampled.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_maxfuse_adata_subsampled_copy, 'maxfuse', color=['CN'], mask_obs=(tonsil_maxfuse_adata_subsampled_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_maxfuse_CN_rna.pdf', show=False)\n# Compute MaxFuse tonsil confusion matrix (using aligned data)\nprint(\"Computing MaxFuse tonsil confusion matrix...\")\ncm_maxfuse_tonsil = compute_confusion_matrix(tonsil_maxfuse_rna_aligned, tonsil_maxfuse_protein_aligned)\nct_cf_plot_tonsil(cm_maxfuse_tonsil, 'MaxFuse', 'XX%', 'fig_khh/tonsil_confusion_matrix_maxfuse.pdf')\n# In[ ]:\nrandom_indices = np.random.permutation(list(range(tonsil_merged_subsampled_other_embeddings.shape[0])))\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings[random_indices], 'umap', color=['modality','major_cell_types'], ",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cm_maxfuse_tonsil",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cm_maxfuse_tonsil = compute_confusion_matrix(tonsil_maxfuse_rna_aligned, tonsil_maxfuse_protein_aligned)\nct_cf_plot_tonsil(cm_maxfuse_tonsil, 'MaxFuse', 'XX%', 'fig_khh/tonsil_confusion_matrix_maxfuse.pdf')\n# In[ ]:\nrandom_indices = np.random.permutation(list(range(tonsil_merged_subsampled_other_embeddings.shape[0])))\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings[random_indices], 'umap', color=['modality','major_cell_types'], \n                palette=tonsil_palette, s=10, save='_tonsil_merged_arcadia.pdf')\ntonsil_merged_subsampled_other_embeddings_copy = tonsil_merged_subsampled_other_embeddings.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings_copy, 'umap', color=['CN'], mask_obs=(tonsil_merged_subsampled_other_embeddings_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_arcadia_CN_codex.pdf')\ntonsil_merged_subsampled_other_embeddings_copy = tonsil_merged_subsampled_other_embeddings.copy() # prevent NA overwriting",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "random_indices",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "random_indices = np.random.permutation(list(range(tonsil_merged_subsampled_other_embeddings.shape[0])))\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings[random_indices], 'umap', color=['modality','major_cell_types'], \n                palette=tonsil_palette, s=10, save='_tonsil_merged_arcadia.pdf')\ntonsil_merged_subsampled_other_embeddings_copy = tonsil_merged_subsampled_other_embeddings.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings_copy, 'umap', color=['CN'], mask_obs=(tonsil_merged_subsampled_other_embeddings_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_arcadia_CN_codex.pdf')\ntonsil_merged_subsampled_other_embeddings_copy = tonsil_merged_subsampled_other_embeddings.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings_copy, 'umap', color=['CN'], mask_obs=(tonsil_merged_subsampled_other_embeddings_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_arcadia_CN_rna.pdf')\n# ## counterfactual spatial neighborhood DEG analysis - tonsil dataset",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged_subsampled_other_embeddings_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged_subsampled_other_embeddings_copy = tonsil_merged_subsampled_other_embeddings.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings_copy, 'umap', color=['CN'], mask_obs=(tonsil_merged_subsampled_other_embeddings_copy.obs['modality'] == 'CODEX'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_arcadia_CN_codex.pdf')\ntonsil_merged_subsampled_other_embeddings_copy = tonsil_merged_subsampled_other_embeddings.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings_copy, 'umap', color=['CN'], mask_obs=(tonsil_merged_subsampled_other_embeddings_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_arcadia_CN_rna.pdf')\n# ## counterfactual spatial neighborhood DEG analysis - tonsil dataset\n# In[ ]:\ntonsil_rna.X = tonsil_rna.layers['counts'].copy()\nsc.pp.normalize_total(tonsil_rna)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_merged_subsampled_other_embeddings_copy",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_merged_subsampled_other_embeddings_copy = tonsil_merged_subsampled_other_embeddings.copy() # prevent NA overwriting\nsc.pl.embedding(tonsil_merged_subsampled_other_embeddings_copy, 'umap', color=['CN'], mask_obs=(tonsil_merged_subsampled_other_embeddings_copy.obs['modality'] == 'scRNA-seq'),\n                palette=tonsil_palette, s=10, save='_tonsil_merged_arcadia_CN_rna.pdf')\n# ## counterfactual spatial neighborhood DEG analysis - tonsil dataset\n# In[ ]:\ntonsil_rna.X = tonsil_rna.layers['counts'].copy()\nsc.pp.normalize_total(tonsil_rna)\nsc.pp.log1p(tonsil_rna)\n# In[ ]:\ntonsil_rna.var['pct_cells'] = tonsil_rna.var['n_cells'] / tonsil_rna.shape[0]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_rna.X",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_rna.X = tonsil_rna.layers['counts'].copy()\nsc.pp.normalize_total(tonsil_rna)\nsc.pp.log1p(tonsil_rna)\n# In[ ]:\ntonsil_rna.var['pct_cells'] = tonsil_rna.var['n_cells'] / tonsil_rna.shape[0]\ngene_mask = tonsil_rna.var[tonsil_rna.var['pct_cells'] > 0.05].index\n# ### B-Ki67\n# In[ ]:\n# B-Ki67: CN_3, CN_7, CN_9 (germinal centers)\nbcells = tonsil_rna[tonsil_rna.obs['cell_types'] == 'B-Ki67']",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "tonsil_rna.var['pct_cells']",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "tonsil_rna.var['pct_cells'] = tonsil_rna.var['n_cells'] / tonsil_rna.shape[0]\ngene_mask = tonsil_rna.var[tonsil_rna.var['pct_cells'] > 0.05].index\n# ### B-Ki67\n# In[ ]:\n# B-Ki67: CN_3, CN_7, CN_9 (germinal centers)\nbcells = tonsil_rna[tonsil_rna.obs['cell_types'] == 'B-Ki67']\nif bcells.n_obs > 0:\n    sc.tl.rank_genes_groups(bcells, groupby='CN', method='wilcoxon')\n    deg_df = sc.get.rank_genes_groups_df(bcells, group=None)\n    if len(deg_df) > 0 and 'group' in deg_df.columns:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "gene_mask",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "gene_mask = tonsil_rna.var[tonsil_rna.var['pct_cells'] > 0.05].index\n# ### B-Ki67\n# In[ ]:\n# B-Ki67: CN_3, CN_7, CN_9 (germinal centers)\nbcells = tonsil_rna[tonsil_rna.obs['cell_types'] == 'B-Ki67']\nif bcells.n_obs > 0:\n    sc.tl.rank_genes_groups(bcells, groupby='CN', method='wilcoxon')\n    deg_df = sc.get.rank_genes_groups_df(bcells, group=None)\n    if len(deg_df) > 0 and 'group' in deg_df.columns:\n        deg_df = deg_df[deg_df['group'].isin(['CN_3', 'CN_7', 'CN_9'])].sort_values('logfoldchanges', ascending=False)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "bcells",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "bcells = tonsil_rna[tonsil_rna.obs['cell_types'] == 'B-Ki67']\nif bcells.n_obs > 0:\n    sc.tl.rank_genes_groups(bcells, groupby='CN', method='wilcoxon')\n    deg_df = sc.get.rank_genes_groups_df(bcells, group=None)\n    if len(deg_df) > 0 and 'group' in deg_df.columns:\n        deg_df = deg_df[deg_df['group'].isin(['CN_3', 'CN_7', 'CN_9'])].sort_values('logfoldchanges', ascending=False)\n        deg_df_filtered = deg_df[deg_df['names'].isin(gene_mask)]\n        deg_df_filtered = deg_df_filtered[deg_df_filtered['pvals_adj'] < 0.05]\n        deg_df_filtered.to_csv('B_Ki67_deg_df.csv')\n    else:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "keep_cn",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "keep_cn = ['CN_0', 'CN_1', 'CN_2', 'CN_3', 'CN_6','CN_7', 'CN_9'] # do not examine CN4, CN5, and CN8 due to low counts\n# In[ ]:\nif len(deg_df_filtered) > 0 and 'group' in deg_df_filtered.columns and 'names' in deg_df_filtered.columns:\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_3') & (deg_df_filtered['logfoldchanges'] > 0)].sort_values('logfoldchanges', ascending=False)\n    print('upregulated genes in CN_3:')\n    print(df.iloc[:100]['names'].tolist() if len(df) > 0 else [])\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_3') & (deg_df_filtered['logfoldchanges'] < 0)].sort_values('logfoldchanges', ascending=True)\n    print('downregulated genes in CN_3:')\n    print(df.iloc[:100]['names'].tolist() if len(df) > 0 else [])\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_7') & (deg_df_filtered['logfoldchanges'] > 0)].sort_values('logfoldchanges', ascending=False)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_3",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_3 = ['PIF1', 'PLK1', 'TOP2A', 'CENPF', 'CENPE', 'ASPM', 'UBE2C', 'DEPDC1', 'AURKA', 'HMMR', 'SGO2', 'KIF14', 'DLGAP5', 'CDC20', 'TPX2', 'CCNB2', 'GTSE1', 'CDK1', 'NUF2', 'CDKN3', 'UBE2S', 'CCNB1', 'TUBB4B', 'AURKB', 'MKI67', 'NUSAP1', 'AICDA', 'HIST1H4C', 'BIRC5', 'LPP', 'CCNA2', 'MYBL1', 'BACH2', 'KIF11', 'HIST1H1B', 'NCAPG', 'H1FX', 'HMGB2', 'KIF20B', 'PTTG1', 'NEIL1', 'HMCES', 'SMC4', 'CD84', 'KNL1', 'TMEM131L', 'TCL1A', 'HIST1H1C', 'TBC1D4', 'DAAM1', 'AC025569.1', 'SPN', 'TUBA1B', 'FAM107B', 'SEC14L1', 'SYNE2', 'HIST1H1E', 'HIST1H1D', 'STMN1', 'LRMP', 'BRWD1', 'CXCR4', 'IKZF2', 'KLHL6', 'TMPO', 'MIS18BP1', 'DDX3Y', 'MZB1', 'BCL6', 'LNPEP', 'H2AFV', 'CD38', 'UBE2J1', 'TUBB', 'LBR', 'CCDC144A', 'CCDC88A', 'SUGCT', 'NUCKS1', 'ANP32E', 'BCL7A', 'HMGN2', 'GGA2', 'UCP2', 'RPS4Y1', 'PAG1', 'HMGB1', 'MME', 'RASSF6', 'VPREB3', 'PEG10', 'MALAT1', 'VIM', 'SEL1L3', 'HIST1H2BG', 'ZBTB20', 'MARCKSL1', 'H3F3A', 'SMC2', 'ZNF106']\nCN_7 = ['IRF4', 'PCNA', 'HSP90AB1', 'PRDX4', 'FAM111B', 'BATF', 'IL2RB', 'RRM2', 'MCM4', 'CLSPN', 'CYTOR', 'HELLS', 'DUSP2', 'CTSC', 'TNFRSF13B', 'ATAD2', 'SUB1', 'MPEG1', 'GPR183', 'DUT', 'LDHA', 'MCM3', 'HELB', 'KLF2', 'FKBP5', 'DHFR', 'TYMS', 'MIR155HG', 'BHLHE41', 'MCM7', 'BCL2A1', 'XBP1', 'PREX1', 'CD44', 'JUNB', 'FKBP11', 'S100A6', 'TK1', 'HSP90B1', 'PCLAF', 'CALR', 'HSPA5', 'PASK', 'PRDX1', 'DGKH', 'ZEB2', 'FCRL5', 'BCL9L', 'GABPB1-AS1', 'YBX1', 'RAN', 'SEC11C', 'HMGA1', 'SSR4', 'BRCA1', 'ODC1', 'MYBL2', 'CD83', 'PKM', 'GSTP1', 'IER2', 'SKAP1', 'LYST', 'ARAP2', 'CD69', 'SELL', 'SRGN', 'COTL1', 'HLA-DRB5', 'H2AFZ', 'NABP1', 'FOSB', 'HLA-DQB1', 'HLA-A', 'DERL3', 'DUSP1', 'XIST', 'DDIT4', 'MBP', 'JUN', 'RGS1', 'GAPDH', 'NAP1L1', 'NEAT1', 'PARP14', 'PFN1', 'BRCA2', 'PPIA', 'SLC25A5', 'HLA-DQA1', 'DNMT1', 'KIAA1551', 'LCP1', 'MACF1', 'RNF213', 'C12ORF75', 'PLEK', 'SMC2', 'VMP1', 'SPIB']\nCN_9 = ['HIST1H1B', 'FAM111B', 'TK1', 'DHFR', 'RRM2', 'DUT', 'CLSPN', 'LMO2', 'TYMS', 'BIRC5', 'MCM3', 'H2AFZ', 'DEK', 'PCLAF', 'TUBB', 'LDHA', 'HMGB1', 'HMGA1', 'ODC1', 'MYBL2', 'DNMT1', 'RAN', 'YBX1', 'GAPDH', 'PKM', 'PFN1']\n# In[ ]:\n# visualize top 50 in supplemental\nbcells_filtered = bcells[bcells.obs['CN'].isin(keep_cn)]\nif bcells_filtered.n_obs > 0:\n    # Check if genes exist in the data\n    cn3_genes = [g for g in CN_3[:50] if g in bcells_filtered.var_names]\n    cn7_genes = [g for g in CN_7[:50] if g in bcells_filtered.var_names]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_7",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_7 = ['IRF4', 'PCNA', 'HSP90AB1', 'PRDX4', 'FAM111B', 'BATF', 'IL2RB', 'RRM2', 'MCM4', 'CLSPN', 'CYTOR', 'HELLS', 'DUSP2', 'CTSC', 'TNFRSF13B', 'ATAD2', 'SUB1', 'MPEG1', 'GPR183', 'DUT', 'LDHA', 'MCM3', 'HELB', 'KLF2', 'FKBP5', 'DHFR', 'TYMS', 'MIR155HG', 'BHLHE41', 'MCM7', 'BCL2A1', 'XBP1', 'PREX1', 'CD44', 'JUNB', 'FKBP11', 'S100A6', 'TK1', 'HSP90B1', 'PCLAF', 'CALR', 'HSPA5', 'PASK', 'PRDX1', 'DGKH', 'ZEB2', 'FCRL5', 'BCL9L', 'GABPB1-AS1', 'YBX1', 'RAN', 'SEC11C', 'HMGA1', 'SSR4', 'BRCA1', 'ODC1', 'MYBL2', 'CD83', 'PKM', 'GSTP1', 'IER2', 'SKAP1', 'LYST', 'ARAP2', 'CD69', 'SELL', 'SRGN', 'COTL1', 'HLA-DRB5', 'H2AFZ', 'NABP1', 'FOSB', 'HLA-DQB1', 'HLA-A', 'DERL3', 'DUSP1', 'XIST', 'DDIT4', 'MBP', 'JUN', 'RGS1', 'GAPDH', 'NAP1L1', 'NEAT1', 'PARP14', 'PFN1', 'BRCA2', 'PPIA', 'SLC25A5', 'HLA-DQA1', 'DNMT1', 'KIAA1551', 'LCP1', 'MACF1', 'RNF213', 'C12ORF75', 'PLEK', 'SMC2', 'VMP1', 'SPIB']\nCN_9 = ['HIST1H1B', 'FAM111B', 'TK1', 'DHFR', 'RRM2', 'DUT', 'CLSPN', 'LMO2', 'TYMS', 'BIRC5', 'MCM3', 'H2AFZ', 'DEK', 'PCLAF', 'TUBB', 'LDHA', 'HMGB1', 'HMGA1', 'ODC1', 'MYBL2', 'DNMT1', 'RAN', 'YBX1', 'GAPDH', 'PKM', 'PFN1']\n# In[ ]:\n# visualize top 50 in supplemental\nbcells_filtered = bcells[bcells.obs['CN'].isin(keep_cn)]\nif bcells_filtered.n_obs > 0:\n    # Check if genes exist in the data\n    cn3_genes = [g for g in CN_3[:50] if g in bcells_filtered.var_names]\n    cn7_genes = [g for g in CN_7[:50] if g in bcells_filtered.var_names]\n    cn9_genes = [g for g in CN_9[:50] if g in bcells_filtered.var_names]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_9",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_9 = ['HIST1H1B', 'FAM111B', 'TK1', 'DHFR', 'RRM2', 'DUT', 'CLSPN', 'LMO2', 'TYMS', 'BIRC5', 'MCM3', 'H2AFZ', 'DEK', 'PCLAF', 'TUBB', 'LDHA', 'HMGB1', 'HMGA1', 'ODC1', 'MYBL2', 'DNMT1', 'RAN', 'YBX1', 'GAPDH', 'PKM', 'PFN1']\n# In[ ]:\n# visualize top 50 in supplemental\nbcells_filtered = bcells[bcells.obs['CN'].isin(keep_cn)]\nif bcells_filtered.n_obs > 0:\n    # Check if genes exist in the data\n    cn3_genes = [g for g in CN_3[:50] if g in bcells_filtered.var_names]\n    cn7_genes = [g for g in CN_7[:50] if g in bcells_filtered.var_names]\n    cn9_genes = [g for g in CN_9[:50] if g in bcells_filtered.var_names]\n    if len(cn3_genes) > 0:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "bcells_filtered",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "bcells_filtered = bcells[bcells.obs['CN'].isin(keep_cn)]\nif bcells_filtered.n_obs > 0:\n    # Check if genes exist in the data\n    cn3_genes = [g for g in CN_3[:50] if g in bcells_filtered.var_names]\n    cn7_genes = [g for g in CN_7[:50] if g in bcells_filtered.var_names]\n    cn9_genes = [g for g in CN_9[:50] if g in bcells_filtered.var_names]\n    if len(cn3_genes) > 0:\n        dp = sc.pl.dotplot(bcells_filtered, cn3_genes, groupby='CN', standard_scale='var', show=False)\n        ax = dp[\"mainplot_ax\"]\n        for l in ax.get_yticklabels():",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "bcell_degs",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "bcell_degs = { \n    'CN_3 B-Ki67 DEGs' : [ # high in somatic hypermutation, B cell activation / BCR signaling, GC and DZ patterns, and proliferation\n              'BCL6', 'AICDA', 'MYBL1', 'BACH2', 'ZBTB20', 'BRWD1', 'BCL7A',\n              'CD38', 'CD84', 'MME', 'LRMP', 'TCL1A', 'KLHL6', 'PAG1', 'CXCR4', 'IKZF2',\n              'MKI67', 'BIRC5'],\n    'CN_7 B-Ki67 DEGs' : [ # high in plasma cell differentiation, activation and signaling, metabolic remodeling, and immune presentation\n              'IRF4', 'XBP1', 'FKBP11', 'CALR', 'HSPA5', 'HSP90B1', 'SSR4', 'PRDX4', 'PARP14',\n              'CD83', 'CD69', 'TNFRSF13B', 'IL2RB', 'FCRL5', 'PREX1', 'GPR183', 'CD44', 'SELL', 'RGS1', 'SRGN', 'LCP1', 'PLEK',\n              'GAPDH', 'PKM', 'LDHA', 'ODC1', 'SLC25A5', 'VMP1',\n              'HLA-A', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DRB5', 'CTSC', 'DERL3'],",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "bcell_degs_selected",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "bcell_degs_selected = {\n    'CN_3 B-Ki67 DEGs' : [ # high in somatic hypermutation, B cell activation / BCR signaling, GC and DZ patterns, and proliferation\n              'BCL6', 'AICDA', 'MYBL1', 'BACH2', 'ZBTB20', 'BRWD1', 'BCL7A',\n              'CD38', 'CD84', 'MME', 'LRMP', 'TCL1A', 'KLHL6', 'PAG1', 'CXCR4',\n              'MKI67', 'BIRC5'],\n    'CN_7 B-Ki67 DEGs' : [ # high in plasma cell differentiation, activation and signaling, metabolic remodeling, and immune presentation\n              'CD83', 'FCRL5', \n              'LCP1', 'PLEK',\n              'GAPDH', 'PKM', 'LDHA', 'ODC1', 'SLC25A5',\n              'HLA-A', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DRB5'],",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "bcell_degs_selected_interpretation",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "bcell_degs_selected_interpretation = {\n    'CN_3 B-Ki67 DEGs' : [ # high in somatic hypermutation, B cell activation / BCR signaling, and GC and DZ proliferation\n              'BCL6', 'AICDA', 'MYBL1', 'BACH2', 'ZBTB20', 'BRWD1', 'BCL7A',\n              'CD84', 'MME', 'LRMP', 'KLHL6', 'CXCR4',\n              'MKI67', 'BIRC5'],\n    'CN_7 and CN_9 B-Ki67 DEGs' : [ # high in plasma cell differentiation, activation and signaling, survival and metabolic remodeling, and immune presentation\n              'CD83', 'FCRL5', \n              'LCP1', 'PLEK',\n              'GAPDH', 'LDHA', 'ODC1', \n              'HLA-A', 'HLA-DQA1', 'HLA-DQB1'],",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "bcells_cn379",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "bcells_cn379 = bcells[bcells.obs['CN'].isin(['CN_3','CN_7','CN_9'])]\nif bcells_cn379.n_obs > 0:\n    # Filter genes to only those that exist in the data\n    bcell_degs_filtered = {}\n    for key, genes in bcell_degs_selected_interpretation.items():\n        filtered_genes = [g for g in genes if g in bcells_cn379.var_names]\n        if len(filtered_genes) > 0:\n            bcell_degs_filtered[key] = filtered_genes\n    if len(bcell_degs_filtered) > 0:\n        dp = sc.pl.dotplot(bcells_cn379, ",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd8t",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd8t = tonsil_rna[tonsil_rna.obs['cell_types'] == 'CD8 T']\nif cd8t.n_obs > 0:\n    # Check which CN groups are actually present\n    available_cns = cd8t.obs['CN'].unique()\n    requested_cns = ['CN_0','CN_1','CN_5','CN_8']\n    valid_cns = [cn for cn in requested_cns if cn in available_cns]\n    if len(valid_cns) > 1:  # Need at least 2 groups for comparison\n        sc.tl.rank_genes_groups(cd8t, groupby='CN', method='wilcoxon', groups=valid_cns)\n        deg_df = sc.get.rank_genes_groups_df(cd8t, group=None)\n        if len(deg_df) > 0 and 'group' in deg_df.columns:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "keep_cn",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "keep_cn = ['CN_0', 'CN_1', 'CN_4', 'CN_5', 'CN_8'] # do not examine CN2, CN3, CN6, CN7, and CN9 due to low counts\n# In[ ]:\nif len(deg_df_filtered) > 0 and 'group' in deg_df_filtered.columns and 'names' in deg_df_filtered.columns:\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_0') & (deg_df_filtered['logfoldchanges'] > 0)].sort_values('logfoldchanges', ascending=False)\n    print('upregulated genes in CN_0:')\n    print(df.iloc[:100]['names'].tolist() if len(df) > 0 else [])\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_0') & (deg_df_filtered['logfoldchanges'] < 0)].sort_values('logfoldchanges', ascending=True)\n    print('downregulated genes in CN_0:')\n    print(df.iloc[:100]['names'].tolist() if len(df) > 0 else [])\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_1') & (deg_df_filtered['logfoldchanges'] > 0)].sort_values('logfoldchanges', ascending=False)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_0",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_0 = ['TNFRSF4', 'TNFRSF18', 'KLRB1', 'TXK', 'SRGAP3', 'GNAQ', 'LAIR1', 'HOPX', 'LYN', 'BHLHE40', 'TNFRSF25', 'FOS', 'NOL4L', 'CD7', 'ID2', 'PLAC8', 'AC044849.1', 'LTB', 'IFITM2', 'IL7R', 'DUSP1', 'BIRC3', 'CTSW', 'DDIT4', 'AKT3', 'DUT', 'TSC22D3', 'IKZF2', 'SELL', 'SATB1', 'TCF7', 'GABPB1-AS1', 'XIST', 'IER2', 'FOSB', 'ZFP36L1', 'HMGN1', 'HSP90AB1', 'MACF1', 'NAP1L1', 'H3F3A']\nCN_8 = ['CCL4', 'DTHD1', 'GZMA', 'CCL5', 'GRAP2', 'SH2D1A', 'MIAT', 'GZMK', 'GZMM', 'CYTOR', 'ITGA1', 'COTL1', 'CST7', 'CD3D', 'NKG7', 'BCL11B', 'ITM2A', 'ATXN1', 'PYHIN1', 'TRAT1', 'A2M-AS1', 'CD6', 'EOMES', 'TIGIT', 'KLRG1', 'TC2N', 'SLAMF7', 'LAPTM5', 'IKZF3', 'CD84', 'ARAP2', 'TRAC', 'RARRES3', 'TRBC2', 'SYNE2', 'CD3G', 'FYN', 'PDCD4', 'RNF213', 'LCP1', 'PTPRC', 'HLA-A']\nprint(len(CN_0))\nprint(len(CN_8))\n# In[ ]:\n# visualize top 50 in supplemental\ncd8t_filtered = cd8t[cd8t.obs['CN'].isin(keep_cn)]\nif cd8t_filtered.n_obs > 0:\n    # Check if genes exist in the data\n    cn0_genes = [g for g in CN_0[:50] if g in cd8t_filtered.var_names]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_8",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_8 = ['CCL4', 'DTHD1', 'GZMA', 'CCL5', 'GRAP2', 'SH2D1A', 'MIAT', 'GZMK', 'GZMM', 'CYTOR', 'ITGA1', 'COTL1', 'CST7', 'CD3D', 'NKG7', 'BCL11B', 'ITM2A', 'ATXN1', 'PYHIN1', 'TRAT1', 'A2M-AS1', 'CD6', 'EOMES', 'TIGIT', 'KLRG1', 'TC2N', 'SLAMF7', 'LAPTM5', 'IKZF3', 'CD84', 'ARAP2', 'TRAC', 'RARRES3', 'TRBC2', 'SYNE2', 'CD3G', 'FYN', 'PDCD4', 'RNF213', 'LCP1', 'PTPRC', 'HLA-A']\nprint(len(CN_0))\nprint(len(CN_8))\n# In[ ]:\n# visualize top 50 in supplemental\ncd8t_filtered = cd8t[cd8t.obs['CN'].isin(keep_cn)]\nif cd8t_filtered.n_obs > 0:\n    # Check if genes exist in the data\n    cn0_genes = [g for g in CN_0[:50] if g in cd8t_filtered.var_names]\n    cn8_genes = [g for g in CN_8[:50] if g in cd8t_filtered.var_names]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd8t_filtered",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd8t_filtered = cd8t[cd8t.obs['CN'].isin(keep_cn)]\nif cd8t_filtered.n_obs > 0:\n    # Check if genes exist in the data\n    cn0_genes = [g for g in CN_0[:50] if g in cd8t_filtered.var_names]\n    cn8_genes = [g for g in CN_8[:50] if g in cd8t_filtered.var_names]\n    if len(cn0_genes) > 0:\n        dp = sc.pl.dotplot(cd8t_filtered, cn0_genes, groupby='CN', standard_scale='var', show=False)\n        ax = dp[\"mainplot_ax\"]\n        for l in ax.get_yticklabels():\n            l.set_color(tonsil_palette[l.get_text()])",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd8t_degs",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd8t_degs = { \n    'CN_0 CD8 T cell DEGs' : [\n               'TNFRSF4', 'TNFRSF18', 'KLRB1', 'TXK', 'HOPX', 'BHLHE40', 'TNFRSF25', 'FOS', 'CD7', 'ID2', 'LTB',\n               'IFITM2', 'IL7R', 'CTSW', 'DDIT4', 'SELL', 'SATB1', 'TCF7', 'IER2', 'FOSB', 'ZFP36L1', ],\n    'CN_8 CD8 T cell DEGs' : [\n               'CCL4', 'GZMA', 'CCL5', 'GRAP2', 'SH2D1A', 'GZMK', 'GZMM', 'ITGA1', 'COTL1', 'CST7', 'NKG7', \n               'BCL11B', 'ITM2A', 'PYHIN1', 'TRAT1', 'CD6', 'EOMES', 'TIGIT', 'KLRG1', 'SLAMF7', 'CD84',\n               'TRAC', 'RARRES3', 'TRBC2', 'FYN', 'PDCD4', 'PTPRC', 'HLA-A']\n}\ncd8t_degs_selected = {",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd8t_degs_selected",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd8t_degs_selected = {\n}\ncd8t_filtered = cd8t[cd8t.obs['CN'].isin(keep_cn)]\nif cd8t_filtered.n_obs > 0:\n    # Filter genes to only those that exist in the data\n    cd8t_degs_filtered = {}\n    for key, genes in cd8t_degs.items():\n        filtered_genes = [g for g in genes if g in cd8t_filtered.var_names]\n        if len(filtered_genes) > 0:\n            cd8t_degs_filtered[key] = filtered_genes",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd8t_filtered",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd8t_filtered = cd8t[cd8t.obs['CN'].isin(keep_cn)]\nif cd8t_filtered.n_obs > 0:\n    # Filter genes to only those that exist in the data\n    cd8t_degs_filtered = {}\n    for key, genes in cd8t_degs.items():\n        filtered_genes = [g for g in genes if g in cd8t_filtered.var_names]\n        if len(filtered_genes) > 0:\n            cd8t_degs_filtered[key] = filtered_genes\n    if len(cd8t_degs_filtered) > 0:\n        dp = sc.pl.dotplot(cd8t_filtered, ",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd4t",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd4t = tonsil_rna[tonsil_rna.obs['cell_types'] == 'CD4 T']\nif cd4t.n_obs > 0:\n    # Check which CN groups are actually present\n    available_cns = cd4t.obs['CN'].unique()\n    requested_cns = ['CN_0', 'CN_1', 'CN_5', 'CN_8']\n    valid_cns = [cn for cn in requested_cns if cn in available_cns]\n    if len(valid_cns) > 1:  # Need at least 2 groups for comparison\n        sc.tl.rank_genes_groups(cd4t, groupby='CN', method='wilcoxon', groups=valid_cns)\n        deg_df = sc.get.rank_genes_groups_df(cd4t, group=None)\n        if len(deg_df) > 0 and 'group' in deg_df.columns:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "keep_cn",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "keep_cn = ['CN_0', 'CN_1', 'CN_4', 'CN_5', 'CN_8'] # do not examine CN2, CN3, CN6, CN7, and CN9 due to low counts\n# In[ ]:\nif len(deg_df_filtered) > 0 and 'group' in deg_df_filtered.columns and 'names' in deg_df_filtered.columns:\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_0') & (deg_df_filtered['logfoldchanges'] > 0)].sort_values('logfoldchanges', ascending=False)\n    print('upregulated genes in CN_0:')\n    print(df.iloc[:100]['names'].tolist() if len(df) > 0 else [])\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_0') & (deg_df_filtered['logfoldchanges'] < 0)].sort_values('logfoldchanges', ascending=True)\n    print('downregulated genes in CN_0:')\n    print(df.iloc[:100]['names'].tolist() if len(df) > 0 else [])\n    df = deg_df_filtered[(deg_df_filtered['group'] == 'CN_1') & (deg_df_filtered['logfoldchanges'] > 0)].sort_values('logfoldchanges', ascending=False)",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_0",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_0 = ['EGR2', 'ASCL2', 'ITGB8', 'LAG3', 'ZEB2', 'DRAIC', 'AC022239.1', 'KIAA1324', 'LINC01480', 'TNFRSF18', 'BCL6', 'KSR2', 'IGHM', 'IER5L', 'PDCD1', 'PTMS', 'DUSP6', 'SRGN', 'CTLA4', 'EGR1', 'FGFR1', 'CD200', 'PKM', 'MYO6', 'TNFRSF4', 'ICA1', 'POU2AF1', 'SPATS2L', 'MCTP1', 'TENT5C', 'TNFRSF1B', 'DUSP2', 'PRDX4', 'ODC1', 'BATF', 'GBP2', 'TIGIT', 'TSPAN5', 'UCP2', 'MAF', 'TOX2', 'CORO1B', 'DTHD1', 'PRDX1', 'KIAA1671', 'ARHGAP10', 'ITM2A', 'SH2D1A', 'PASK', 'MTUS1', 'EZR', 'TBC1D4', 'IL6ST', 'XIST', 'AC004585.1', 'PGGHG', 'ACTN1', 'ICOS', 'HMCES', 'LYST', 'GAPDH', 'LDHA', 'SEC11C', 'CALR', 'LRMP', 'IL2RB', 'CD38', 'H2AFV', 'COTL1', 'SLC25A5', 'POU2F2', 'VMP1', 'CD69', 'PARP1', 'H3F3A', 'CYTOR', 'HNRNPLL', 'BTLA', 'SIRPG', 'SUB1', 'ISG20', 'FBLN7', 'ANP32E', 'HERPUD1', 'METAP2', 'PHACTR2', 'ARPC3', 'FAM107B', 'BCL2', 'FKBP5', 'PFN1', 'RAN', 'CHI3L2', 'IKZF3', 'HSP90AB1', 'SPN', 'CEMIP2', 'IPCEF1', 'CDK5R1', 'HCST']\nCN_1 = ['TENT5C', 'DRAIC', 'PDCD1', 'IGHM', 'DUSP6', 'XIST', 'ICA1', 'TOX2', 'TNFRSF1B', 'BCL6', 'MAF', 'TIGIT', 'CTLA4', 'CORO1B', 'AC004585.1', 'ISG20', 'PKM', 'SH2D1A', 'TBC1D4', 'UCP2', 'IL2RB', 'MIS18BP1', 'SRGN', 'IKZF3', 'GAPDH', 'COTL1', 'PHACTR2', 'H2AFZ', 'EZR', 'H3F3A', 'HLA-A']\nCN_5 = ['CCR7', 'LINC00861', 'CAMK4', 'TXNIP', 'VIM', 'HELB', 'RPS4Y1', 'IL7R', 'SLFN5', 'GIMAP7', 'AAK1', 'ARL4C', 'SARAF', 'GIMAP4', 'TRAF3IP3', 'ZFP36L2', 'FYB1', 'MALAT1']\nCN_8 = ['IL7R', 'TXNIP', 'SCML4', 'VIM', 'LINC00861', 'SORL1', 'HELB', 'GIMAP5', 'AHNAK', 'ARL4C', 'ZFP36L2', 'GPR183', 'AAK1', 'CAMK4', 'DYRK2', 'CCR7', 'TSC22D3', 'GIMAP1', 'GIMAP7', 'TRAF3IP3', 'MALAT1', 'GIMAP4', 'FYB1', 'BCL11B']\nprint(len(CN_0))\nprint(len(CN_1))\nprint(len(CN_5))\nprint(len(CN_8))\n# In[ ]:\n# visualize top 50 in supplemental",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_1",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_1 = ['TENT5C', 'DRAIC', 'PDCD1', 'IGHM', 'DUSP6', 'XIST', 'ICA1', 'TOX2', 'TNFRSF1B', 'BCL6', 'MAF', 'TIGIT', 'CTLA4', 'CORO1B', 'AC004585.1', 'ISG20', 'PKM', 'SH2D1A', 'TBC1D4', 'UCP2', 'IL2RB', 'MIS18BP1', 'SRGN', 'IKZF3', 'GAPDH', 'COTL1', 'PHACTR2', 'H2AFZ', 'EZR', 'H3F3A', 'HLA-A']\nCN_5 = ['CCR7', 'LINC00861', 'CAMK4', 'TXNIP', 'VIM', 'HELB', 'RPS4Y1', 'IL7R', 'SLFN5', 'GIMAP7', 'AAK1', 'ARL4C', 'SARAF', 'GIMAP4', 'TRAF3IP3', 'ZFP36L2', 'FYB1', 'MALAT1']\nCN_8 = ['IL7R', 'TXNIP', 'SCML4', 'VIM', 'LINC00861', 'SORL1', 'HELB', 'GIMAP5', 'AHNAK', 'ARL4C', 'ZFP36L2', 'GPR183', 'AAK1', 'CAMK4', 'DYRK2', 'CCR7', 'TSC22D3', 'GIMAP1', 'GIMAP7', 'TRAF3IP3', 'MALAT1', 'GIMAP4', 'FYB1', 'BCL11B']\nprint(len(CN_0))\nprint(len(CN_1))\nprint(len(CN_5))\nprint(len(CN_8))\n# In[ ]:\n# visualize top 50 in supplemental\ncd4t_filtered = cd4t[cd4t.obs['CN'].isin(keep_cn)]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_5",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_5 = ['CCR7', 'LINC00861', 'CAMK4', 'TXNIP', 'VIM', 'HELB', 'RPS4Y1', 'IL7R', 'SLFN5', 'GIMAP7', 'AAK1', 'ARL4C', 'SARAF', 'GIMAP4', 'TRAF3IP3', 'ZFP36L2', 'FYB1', 'MALAT1']\nCN_8 = ['IL7R', 'TXNIP', 'SCML4', 'VIM', 'LINC00861', 'SORL1', 'HELB', 'GIMAP5', 'AHNAK', 'ARL4C', 'ZFP36L2', 'GPR183', 'AAK1', 'CAMK4', 'DYRK2', 'CCR7', 'TSC22D3', 'GIMAP1', 'GIMAP7', 'TRAF3IP3', 'MALAT1', 'GIMAP4', 'FYB1', 'BCL11B']\nprint(len(CN_0))\nprint(len(CN_1))\nprint(len(CN_5))\nprint(len(CN_8))\n# In[ ]:\n# visualize top 50 in supplemental\ncd4t_filtered = cd4t[cd4t.obs['CN'].isin(keep_cn)]\nif cd4t_filtered.n_obs > 0:",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "CN_8",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "CN_8 = ['IL7R', 'TXNIP', 'SCML4', 'VIM', 'LINC00861', 'SORL1', 'HELB', 'GIMAP5', 'AHNAK', 'ARL4C', 'ZFP36L2', 'GPR183', 'AAK1', 'CAMK4', 'DYRK2', 'CCR7', 'TSC22D3', 'GIMAP1', 'GIMAP7', 'TRAF3IP3', 'MALAT1', 'GIMAP4', 'FYB1', 'BCL11B']\nprint(len(CN_0))\nprint(len(CN_1))\nprint(len(CN_5))\nprint(len(CN_8))\n# In[ ]:\n# visualize top 50 in supplemental\ncd4t_filtered = cd4t[cd4t.obs['CN'].isin(keep_cn)]\nif cd4t_filtered.n_obs > 0:\n    # Check if genes exist in the data",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd4t_filtered",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd4t_filtered = cd4t[cd4t.obs['CN'].isin(keep_cn)]\nif cd4t_filtered.n_obs > 0:\n    # Check if genes exist in the data\n    cn0_genes = [g for g in CN_0[:50] if g in cd4t_filtered.var_names]\n    cn1_genes = [g for g in CN_1[:50] if g in cd4t_filtered.var_names]\n    cn5_genes = [g for g in CN_5[:50] if g in cd4t_filtered.var_names]\n    cn8_genes = [g for g in CN_8[:50] if g in cd4t_filtered.var_names]\n    if len(cn0_genes) > 0:\n        dp = sc.pl.dotplot(cd4t_filtered, cn0_genes, groupby='CN', standard_scale='var', show=False)\n        ax = dp[\"mainplot_ax\"]",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd4t_degs",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd4t_degs = { \n    'CN_0 CD4 T cell DEGs' : [\n        'EGR2', 'ASCL2', 'ITGB8', 'LAG3', 'ZEB2', 'TNFRSF18', 'BCL6', 'PDCD1', 'SRGN', 'CTLA4',\n        'EGR1', 'CD200', 'PKM', 'TNFRSF4', 'TNFRSF1B', 'BATF', 'GBP2', 'TIGIT', 'MAF', 'TOX2', 'ITM2A', 'SH2D1A'],\n    'CN_1 CD4 T cell DEGs' : [\n        'PDCD1', 'TOX2', 'TNFRSF1B', 'BCL6', 'MAF', 'TIGIT', 'CTLA4', 'ISG20', 'GAPDH', 'HLA-A'],\n    'CN_5 CD4 T cell DEGs' : [\n        'CCR7', 'CAMK4', 'IL7R', 'SLFN5', 'GIMAP7', 'GIMAP4', 'TRAF3IP3'],\n    'CN_8 CD4 T cell DEGs' : [\n        'IL7R', 'GIMAP5', 'ZFP36L2', 'GPR183', 'CCR7', 'GIMAP1', 'GIMAP7', 'TRAF3IP3', 'MALAT1', 'GIMAP4', 'FYB1', 'BCL11B'],",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "cd4t_degs_selected",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "cd4t_degs_selected = {\n}\ndp = sc.pl.dotplot(cd4t[cd4t.obs['CN'].isin(keep_cn)], \n                   cd4t_degs, \n                   groupby='CN', \n                   standard_scale='var', \n                   show=False)\nax = dp[\"mainplot_ax\"]\nfor l in ax.get_yticklabels():\n    l.set_color(tonsil_palette[l.get_text()])",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "dp",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "dp = sc.pl.dotplot(cd4t[cd4t.obs['CN'].isin(keep_cn)], \n                   cd4t_degs, \n                   groupby='CN', \n                   standard_scale='var', \n                   show=False)\nax = dp[\"mainplot_ax\"]\nfor l in ax.get_yticklabels():\n    l.set_color(tonsil_palette[l.get_text()])\n    l.set_fontweight(\"bold\")\nplt.savefig('fig_khh/dotplot_tonsil_rna_cd4t_CN_0158.pdf', bbox_inches='tight')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    },
    {
        "label": "ax",
        "kind": 5,
        "importPath": "generate_publication_figures_github",
        "description": "generate_publication_figures_github",
        "peekOfCode": "ax = dp[\"mainplot_ax\"]\nfor l in ax.get_yticklabels():\n    l.set_color(tonsil_palette[l.get_text()])\n    l.set_fontweight(\"bold\")\nplt.savefig('fig_khh/dotplot_tonsil_rna_cd4t_CN_0158.pdf', bbox_inches='tight')",
        "detail": "generate_publication_figures_github",
        "documentation": {}
    }
]